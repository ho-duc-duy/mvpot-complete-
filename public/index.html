<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be updated by JS -->
    <title
        data-lang-en="MV Concept Generator"
        data-lang-es="Generador de Conceptos MV"
        data-lang-vi="Trình tạo ý tưởng MV"
        data-lang-ja="MVコンセプトジェネレーター"
        data-lang-zhcn="MV概念生成器"
    >MV Concept Generator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Add common fonts requested by the AI (Optional, improves display if generated) -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Playfair+Display:wght@400;700&family=Roboto+Mono:wght@400&family=Lora:wght@400;700&family=Oswald:wght@400;700&display=swap" rel="stylesheet">


    <style>
        /* --- NEW DESIGN SYSTEM --- */

        /* CSS Variables for Theme */
        :root {
            --bg-dark: #1a1a1d; /* Very dark grey, almost black */
            --bg-card: #2c2c30; /* Slightly lighter card background */
            --bg-card-hover: #35353a;
            --text-primary: #f0f0f5; /* Off-white */
            --text-secondary: #a9a9b3; /* Lighter grey */
            --accent-primary: #6a8ee7; /* Soft blue */
            --accent-secondary: #e476e4; /* Soft magenta/purple */
            --accent-gradient: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            --border-color: #404045;
            --success-color: #57cc99;
            --warning-color: #ffb703;
            --error-color: #e63946;
            --font-family: 'Poppins', sans-serif;
            --nav-height: 70px;
            --border-radius-sm: 6px;
            --border-radius-md: 10px;
            --box-shadow-soft: 0 4px 15px rgba(0, 0, 0, 0.2);
            --box-shadow-glow: 0 0 15px rgba(106, 142, 231, 0.3); /* Glow for accent elements */
        }

        /* Basic Reset & Defaults */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family);
            line-height: 1.7;
            color: var(--text-primary);
            background-color: var(--bg-dark);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease;
        }
        main {
            flex-grow: 1;
            padding-top: calc(var(--nav-height) + 2rem);
            padding-bottom: 4rem;
            width: 100%;
        }

        /* --- LOADING OVERLAY --- */
        #loading-overlay {
            position: fixed; inset: 0;
            background-color: rgba(26, 26, 29, 0.85);
            backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center;
            z-index: 9999; flex-direction: column;
            opacity: 0; transition: opacity 0.4s ease-in-out;
        }
        #loading-overlay.show { display: flex; opacity: 1; }
        #loading-overlay p {
            font-weight: 500; color: var(--text-primary);
            margin-bottom: 20px; font-size: 1.2em;
            text-align: center; max-width: 80%;
        }
        .loading-spinner {
            width: 55px; height: 55px; border-radius: 50%;
            display: inline-block; position: relative; border: 4px solid;
            border-color: var(--accent-primary) var(--accent-primary) transparent transparent;
            animation: spin 1.2s linear infinite;
        }
        .loading-spinner::before, .loading-spinner::after {
            content: ''; position: absolute; left: 0; right: 0; bottom: 0; top: 0;
            border-radius: 50%; border: 4px solid transparent;
        }
        .loading-spinner::before { border-top-color: var(--accent-secondary); animation: spin 1.5s linear infinite; }
        .loading-spinner::after { border-left-color: rgba(240, 240, 245, 0.5); animation: spin 0.7s linear infinite; animation-direction: reverse; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Navigation --- */
        .main-nav {
            background-color: rgba(44, 44, 48, 0.8); backdrop-filter: blur(10px);
            color: var(--text-primary); position: fixed; top: 0; left: 0; width: 100%;
            z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex;
            justify-content: space-between; align-items: center; padding: 0 2rem; height: var(--nav-height);
        }
        .logo {
            font-weight: 600; font-size: 1.4rem; color: var(--text-primary); text-decoration: none;
            user-select: none; display: flex; align-items: center; gap: 0.5rem;
        }
        .logo img { max-height: 40px; width: auto; object-fit: contain; vertical-align: middle; }
        .main-nav ul { list-style: none; display: flex; align-items: center; gap: 1.5rem; }
        .main-nav ul li a {
            color: var(--text-secondary); text-decoration: none; padding: 0.5rem 0.8rem;
            font-size: 1rem; font-weight: 500; border-radius: var(--border-radius-sm);
            transition: color 0.3s ease, background-color 0.3s ease; position: relative; overflow: hidden; cursor: pointer;
        }
        .main-nav ul li a::after {
            content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px;
            background: var(--accent-gradient); transform: scaleX(0); transform-origin: right;
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .main-nav ul li a:hover, .main-nav ul li a.active { color: var(--text-primary); background-color: rgba(255, 255, 255, 0.05); }
        .main-nav ul li a.active::after { transform: scaleX(1); transform-origin: left; }

        /* --- Settings Box (Language) --- */
        #settings-box { display: flex; align-items: center; gap: 0.6rem; }
        #settings-box label { font-size: 0.9rem; color: var(--text-secondary); }
        #settings-box select {
            padding: 0.4rem 0.6rem; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color);
            background-color: var(--bg-card); color: var(--text-primary); font-size: 0.9rem; cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #settings-box select:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 2px rgba(106, 142, 231, 0.3); }

        /* --- General Content & Pages --- */
        .container { max-width: 1100px; margin: 0 auto; padding: 0 1.5rem; }
        .page { display: none; animation: sectionFadeIn 0.8s ease-out forwards; min-height: calc(100vh - var(--nav-height) - 6rem); }
        .page.active { display: block; }
        @keyframes sectionFadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Home Page --- */
        #home-page { text-align: center; padding-top: 3rem; }
        .hero-section {
            padding: 4rem 1rem; border-radius: var(--border-radius-md); background: rgba(44, 44, 48, 0.5);
            margin-bottom: 3rem; position: relative; overflow: hidden;
        }
        .hero-section::before {
            content: ''; position: absolute; inset: 0; z-index: 0; opacity: 0.7;
            background: radial-gradient(circle at top left, rgba(106, 142, 231, 0.1), transparent 60%),
                        radial-gradient(circle at bottom right, rgba(228, 118, 228, 0.1), transparent 60%);
            animation: pulseGlow 10s infinite alternate ease-in-out;
        }
        @keyframes pulseGlow { from { opacity: 0.5; transform: scale(1); } to { opacity: 1; transform: scale(1.05); } }
        .hero-content { position: relative; z-index: 1; }
        .hero-section h1 {
            font-size: clamp(2rem, 5vw, 3.2rem); font-weight: 700; margin-bottom: 1.5rem; color: var(--text-primary);
            line-height: 1.3; animation: textFadeUp 1s 0.2s ease-out forwards; opacity: 0;
        }
        @keyframes textFadeUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .hero-section .tagline {
            font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 2.5rem; max-width: 650px; margin-left: auto; margin-right: auto;
            animation: textFadeUp 1s 0.4s ease-out forwards; opacity: 0;
        }
        .hero-section .btn { animation: buttonScaleIn 0.8s 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; opacity: 0; transform: scale(0.8); }
        @keyframes buttonScaleIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        /* --- About Page --- */
        #about-page .content-container {
            max-width: 850px; margin: 2rem auto; padding: 2.5rem; background-color: var(--bg-card);
            border-radius: var(--border-radius-md); box-shadow: var(--box-shadow-soft);
        }
        #about-page h2 {
            font-size: 2rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--accent-primary);
            text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 0.8rem;
        }
        #about-page p { font-size: 1.05rem; color: var(--text-secondary); text-align: justify; line-height: 1.8; }
        #about-page .btn-back { display: block; width: fit-content; margin: 2rem auto 0 auto; }

        /* --- Feature Page (Input & Results) --- */
        .input-section, .results-section { margin-bottom: 3rem; }
        .form-container {
            background-color: var(--bg-card); padding: 2.5rem; border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow-soft); max-width: 900px; margin: 0 auto;
        }
        .form-container h1 {
            font-size: 2.2rem; font-weight: 600; text-align: center; margin-bottom: 2rem;
            background: var(--accent-gradient); -webkit-background-clip: text; background-clip: text; color: transparent;
        }
        .form-group { margin-bottom: 1.8rem; }
        .form-group label { display: block; margin-bottom: 0.7rem; font-weight: 500; color: var(--text-secondary); font-size: 1rem; }
        .form-group input[type="text"], .form-group textarea, .form-group select {
            width: 100%; padding: 0.9rem 1rem; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm);
            font-size: 1rem; background-color: var(--bg-dark); color: var(--text-primary);
            transition: border-color 0.3s ease, box-shadow 0.3s ease; font-family: inherit;
        }
        .form-group input[type="text"]:focus, .form-group textarea:focus, .form-group select:focus {
             outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(106, 142, 231, 0.2);
        }
        .form-group textarea { resize: vertical; min-height: 140px; }
        /* Specific margin for the button below the lyrics textarea */
        #generate-lyrics-button { margin-top: 0.8rem; width: auto; /* Don't make it full width */ }

        .form-group select {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23a9a9b3" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat; background-position: right 1rem center; background-size: 20px; padding-right: 3rem; cursor: pointer;
        }
        .form-group select option[disabled] { color: #777; }
        .audio-input-group { display: flex; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .form-group input[type="file"] {
             padding: 0; cursor: pointer; flex-grow: 1; min-width: 200px; margin-bottom: 0;
             background-color: transparent; border: none; box-shadow: none; color: var(--text-secondary);
        }
        input[type="file"]::file-selector-button {
             padding: 0.7rem 1.2rem; margin-right: 1rem; border: none; border-radius: var(--border-radius-sm);
             background: linear-gradient(135deg, #444, #555); color: var(--text-primary);
             cursor: pointer; transition: background 0.3s ease, transform 0.1s ease; font-weight: 500;
        }
        input[type="file"]::file-selector-button:hover { background: linear-gradient(135deg, #555, #666); transform: translateY(-1px); }
        #record-status { margin-left: 1rem; font-style: italic; font-weight: 500; display: inline-flex; align-items: center; min-height: 24px; transition: color 0.3s ease; }
        #record-status.recording { color: var(--error-color); }
        #record-status.transcribing { color: var(--accent-primary); }
        #record-status.complete { color: var(--success-color); }
        #record-status.error { color: var(--error-color); }
        .recording-dots { display: inline-block; vertical-align: middle; margin-right: 6px; }
        .recording-dots span {
            display: inline-block; width: 9px; height: 9px; margin-left: 4px; border-radius: 50%; background-color: var(--error-color);
            animation: recordingPulse 1.4s infinite ease-in-out;
        }
        .recording-dots span:nth-child(1) { animation-delay: 0s; }
        .recording-dots span:nth-child(2) { animation-delay: 0.2s; }
        .recording-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes recordingPulse { 0%, 100% { transform: scale(0.5); opacity: 0.5; } 50% { transform: scale(1); opacity: 1; } }
        #transcript-group { display: none; margin-top: 1.5rem; }
        #transcript-output { background-color: #333; font-style: italic; color: var(--text-secondary); min-height: 90px; cursor: default; border-color: #444; }
        .form-group small { display: block; margin-top: 0.8rem; color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; }
        #generate-concept-button { display: block; width: 100%; max-width: 380px; margin: 2.5rem auto 0 auto; padding: 1rem 1.5rem; font-size: 1.1rem; }

        /* --- Results Section & Cards --- */
        .results-section { display: none; margin-top: 3rem; }
        .results-grid { display: grid; grid-template-columns: 1fr; gap: 1.8rem; } /* Single column layout */
        .result-card {
            background-color: var(--bg-card); border-radius: var(--border-radius-md); padding: 1.8rem;
            box-shadow: var(--box-shadow-soft); border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            opacity: 0; transform: translateY(30px); display: flex; flex-direction: column;
        }
        .result-card.visible { opacity: 1; transform: translateY(0); transition: opacity 0.6s ease-out, transform 0.6s ease-out; /* delay set by JS */ }
        .result-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3); border-color: var(--accent-primary); }
        .result-card h2 {
            font-size: 1.5rem; font-weight: 600; color: var(--accent-primary); margin-bottom: 1.2rem;
            padding-bottom: 0.6rem; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0;
        }
        .card-content { font-size: 0.95rem; color: var(--text-secondary); line-height: 1.7; flex-grow: 1; overflow: hidden; }
        .card-content p { margin-bottom: 1rem; }
        .card-content p:last-child { margin-bottom: 0; }
        .card-content strong { color: var(--text-primary); font-weight: 600; }
        #result-concept > .card-content { white-space: pre-wrap; } /* Concept text wrapping */

        /* Requirements List */
        #result-requirements ul { margin: 0.5rem 0 0 0; padding-left: 0; list-style: none; }
        #result-requirements li { margin-bottom: 0.8rem; padding-left: 1.8rem; position: relative; }
        #result-requirements li::before {
            content: '✓'; color: var(--accent-primary); font-size: 1.1em; font-weight: 600;
            position: absolute; left: 0; top: 1px; transition: transform 0.3s ease;
        }
        #result-requirements li:hover::before { transform: scale(1.2) rotate(-10deg); }

        /* Budget Section Styles */
        .budget-columns-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Ensure 3 columns */
            gap: 1.2rem;
            margin-top: 1rem;
        }
        .budget-column {
            border: 1px solid var(--border-color);
            padding: 1.2rem;
            border-radius: var(--border-radius-sm);
            background-color: rgba(26, 26, 29, 0.7);
            display: flex; flex-direction: column; /* Stack elements vertically */
            transition: background-color 0.3s ease;
            min-height: 180px; /* Ensure columns have some base height */
        }
        .budget-column:hover { background-color: rgba(40, 40, 43, 0.8); }
        .budget-column h3 {
            margin-top: 0; margin-bottom: 1rem; padding-bottom: 0.5rem;
            border-bottom: 1px solid #555; color: var(--text-primary);
            font-size: 1.1rem; font-weight: 600; flex-shrink: 0; /* Prevent shrinking */
            text-align: center;
        }
        .budget-column p { /* Holds the main description and item boxes */
            font-size: 0.95rem; /* Matches .card-content */
            line-height: 1.7;    /* Matches .card-content */
            color: var(--text-secondary);
            white-space: normal; /* Allow wrapping */
            margin-bottom: 0;
            flex-grow: 1; /* Allow description to take space */
        }
        /* Style for individual cost items within the description */
        .budget-column .budget-item-box {
             border: 1px solid #555;
             background-color: var(--bg-dark);
             padding: 0.6rem 0.8rem;
             margin-top: 0.8rem; /* Space above item */
             margin-bottom: 0.6rem; /* Space below item */
             border-radius: 4px;
             font-size: 0.85em; /* Relative to parent p */
             box-shadow: 0 1px 2px rgba(0,0,0,0.1);
             display: flex; /* Put item name and cost side-by-side */
             justify-content: space-between;
             align-items: center;
        }
        .budget-column .budget-item-box strong { /* Style the cost part */
            color: var(--text-primary);
            margin-left: 0.5rem; /* Space between item and cost */
            white-space: nowrap; /* Prevent cost from wrapping */
            font-weight: 600;
        }
        /* Placeholder styling specifically for budget columns */
        .budget-column.placeholder-notice {
            border-style: dashed;
            opacity: 0.7;
        }
        .budget-column.placeholder-notice h3 {
            color: var(--text-secondary);
            border-bottom-color: rgba(85, 85, 85, 0.5);
        }
        .budget-column.placeholder-notice p.placeholder-notice { /* Style placeholder text inside budget P */
            text-align: center;
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 1rem;
            font-size: 0.95rem; /* Ensure placeholder text also matches */
            line-height: 1.7;
        }
        /* Main container placeholder */
        .budget-columns-container.placeholder-notice {
            display: block; /* Override grid for single placeholder text */
            text-align: center;
            padding: 1rem;
        }
        .budget-columns-container.placeholder-notice .budget-column {
            display: none; /* Hide columns when main container has placeholder */
        }
        /* Style for raw text display on parsing error */
        .card-content .raw-budget-output pre { /* Target pre inside raw-budget-output class */
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 1.2em; /* Increased font size */
            text-align: left;
            background-color: rgba(0,0,0,0.3); /* Slightly darker background */
            border: 1px dashed var(--border-color); /* Dashed border */
            color: var(--text-secondary);
            padding: 1rem;
            border-radius: var(--border-radius-sm);
            margin-top: 0.5rem;
            max-height: 250px; /* Increased max-height */
            overflow-y: auto;
        }


        /* Image Placeholder (Inside Card) */
        .image-placeholder-container { display: grid; gap: 1.2rem; margin-top: 1rem; }
        #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
        #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
        .image-placeholder {
            border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); background-color: var(--bg-dark);
            overflow: hidden; text-align: center; color: var(--text-secondary); box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease; position: relative;
        }
        .image-placeholder:hover { transform: scale(1.03); box-shadow: 0 5px 12px rgba(0,0,0,0.3); z-index: 5; }
        .image-placeholder img {
            display: block; width: 100%; object-fit: cover; background-color: #444; border-bottom: 1px solid var(--border-color);
            opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        .image-placeholder img[src]:not([src=""]) { opacity: 1; }
        #result-visuals .image-placeholder img { height: 160px; }
        #result-moodboard .image-placeholder img { height: 130px; }
        .image-placeholder figcaption {
            font-size: 0.85em; padding: 0.8rem; background-color: var(--bg-card);
            min-height: 55px; line-height: 1.4; color: var(--text-secondary);
        }
        .image-placeholder figcaption strong { color: var(--text-primary); }
        /* Style for Backend/Fallback source note */
        .image-placeholder figcaption .generation-source,
        .image-placeholder figcaption .fallback-notice {
            font-size: 0.8em; display: block; margin-top: 5px;
        }
        .image-placeholder figcaption .generation-source { color: var(--accent-primary); font-style: italic; } /* Backend note */
        .image-placeholder figcaption .fallback-notice { color: #888; font-style: italic; } /* Fallback notice */


        /* --- START: Color Palette Update Styles --- */
        .color-palette-display { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 1rem; align-items: stretch; /* Stretch items */ }
        .color-swatch {
            min-width: 120px; /* Slightly wider */
            /* height: auto; Remove fixed height */
            border-radius: var(--border-radius-sm); border: 1px solid var(--border-color);
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start; /* Align top */
            font-size: 0.85em; font-weight: 500; text-align: center; overflow: hidden;
            box-shadow: 0 1px 4px rgba(0,0,0,0.15); transition: transform 0.25s ease, box-shadow 0.25s ease;
            flex-grow: 1; opacity: 0; transform: scale(0.8); padding: 0; /* Remove padding here */
        }
        .color-swatch.visible { opacity: 1; transform: scale(1); transition: opacity 0.4s ease-out, transform 0.4s ease-out; /* delay handled by JS */ }
        .color-swatch:hover { transform: scale(1.05); box-shadow: 0 4px 10px rgba(0,0,0,0.25); z-index: 5; }

        .color-swatch .color-block { /* New element for the colored block */
            width: 100%; height: 70px; /* Fixed height for color area */
            display: flex; align-items: center; justify-content: center; /* Center hex inside block */
            border-bottom: 1px solid rgba(0,0,0,0.1); /* Subtle divider */
        }
        .color-swatch .hex-code {
            margin-top: 0; /* Remove top margin */
            font-size: 0.9em; font-family: monospace; user-select: all; opacity: 0.8;
            padding: 0.3rem; /* Add padding */
        }
        .color-swatch .color-info { /* Container for name and application */
            padding: 0.8rem; width: 100%; flex-grow: 1; /* Take remaining space */
            display: flex; flex-direction: column; /* Stack name and desc */
            background-color: rgba(0,0,0,0.1); /* Slight bg tint */
        }
        .color-swatch .color-name { font-weight: 600; display: block; margin-bottom: 0.4rem; word-break: break-word; }
        .color-swatch .color-application {
            font-size: 0.9em; line-height: 1.4; color: var(--text-secondary);
            word-break: break-word; /* Allow long words to wrap */
            text-align: left; /* Left-align description */
        }
        /* Style for Dominant Color */
        .color-swatch.dominant-swatch { border: 2px solid var(--accent-primary); box-shadow: 0 2px 8px rgba(106, 142, 231, 0.2); }
        /* --- END: Color Palette Update Styles --- */

        /* --- START: Font Suggestion Styles --- */
        #result-fonts .font-suggestion {
            margin-bottom: 1.8rem; padding-bottom: 1.5rem;
            border-bottom: 1px dashed var(--border-color);
        }
        #result-fonts .font-suggestion:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        #result-fonts h3 { /* Combination Title */
            font-size: 1.2rem; color: var(--text-primary); margin-bottom: 0.6rem; font-weight: 600;
        }
        #result-fonts .font-reason {
            font-style: italic; margin-bottom: 1rem; font-size: 0.95em;
        }
        #result-fonts .font-sample {
            background-color: rgba(0,0,0,0.15); padding: 0.8rem 1rem; border-radius: var(--border-radius-sm);
            margin-bottom: 0.8rem; border-left: 3px solid var(--accent-secondary);
            font-size: 1.1em; /* Make samples slightly larger */
        }
        #result-fonts .font-sample strong { /* Label like "Title:" */
            color: var(--accent-primary); font-weight: 600; margin-right: 0.5rem;
        }
        /* --- END: Font Suggestion Styles --- */


        /* Action Buttons */
        .action-buttons {
            margin-top: 2rem; padding-top: 2rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; flex-shrink: 0;
        }

        /* --- General Button Styling --- */
        .btn {
            display: inline-block; padding: 0.8rem 1.8rem; border: none; border-radius: var(--border-radius-sm);
            cursor: pointer; font-size: 1rem; font-weight: 600; text-align: center; text-decoration: none;
            color: var(--text-primary); background: var(--accent-gradient);
            transition: transform 0.2s ease, box-shadow 0.3s ease, background-size 0.4s ease, opacity 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); position: relative; overflow: hidden; z-index: 1;
            user-select: none; /* Prevent text selection on buttons */
        }
        .btn::before { /* Subtle shine effect on hover */
             content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
             background: linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
             transition: left 0.5s ease; z-index: -1;
        }
        .btn:hover:not(:disabled) { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 15px rgba(106, 142, 231, 0.3); }
        .btn:hover:not(:disabled)::before { left: 100%; }
        .btn:active:not(:disabled) { transform: translateY(0) scale(0.98); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; background: #555; box-shadow: none; }
        .btn-secondary { background: linear-gradient(135deg, #5a5a60, #404045); }
        .btn-secondary:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(80, 80, 80, 0.3); }
        .btn-warning { background: linear-gradient(135deg, var(--warning-color), #d4a00e); color: #222; }
        .btn-warning:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(255, 183, 3, 0.4); color: #000; }
        .btn-danger { background: linear-gradient(135deg, var(--error-color), #b82c3a); }
        .btn-danger:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(230, 57, 70, 0.4); }
        #home-page .btn-back { display: none; } /* Hide back button on home */

        /* --- Error Message --- */
        .error-message {
            background-color: rgba(230, 57, 70, 0.15); color: var(--error-color); border: 1px solid rgba(230, 57, 70, 0.5);
            padding: 1.2rem 1.5rem; border-radius: var(--border-radius-sm); margin: 1.5rem auto; text-align: center;
            font-weight: 500; display: none; max-width: 800px; white-space: pre-wrap;
        }
        /* Specific styling for error paragraphs inside card content */
        .card-content p.error {
            color: var(--error-color);
            font-weight: 500;
        }


        /* --- Footer --- */
        .main-footer {
            background-color: #111; color: var(--text-secondary); padding: 1.5rem 0;
            text-align: center; font-size: 0.9rem; margin-top: auto;
        }
        .main-footer p { margin: 0; }
        .main-footer a { color: var(--accent-primary); text-decoration: none; transition: color 0.3s ease; }
        .main-footer a:hover { color: var(--accent-secondary); }

        /* --- Utility Placeholders --- */
        .placeholder-notice {
            font-style: italic; color: var(--text-secondary); opacity: 0.8;
            text-align: center; padding: 1rem; font-size: 0.9em;
        }
        #result-requirements ul .placeholder-notice { padding: 0; text-align: left; list-style: none; margin-left: 1.8rem; }
        #result-requirements ul .placeholder-notice::before { display: none; }
        /* Ensure image/color/font placeholders inside cards look right */
        .image-placeholder-container.placeholder-notice,
        .color-palette-display.placeholder-notice,
        #result-fonts.placeholder-notice { /* Added font placeholder */
            display: block; /* Override grid/flex for placeholder text */
            text-align: center; padding: 1rem;
        }
         /* Ensure budget note is always visible, even with placeholders */
         #result-budget > small { display: block; text-align: center; margin-top: 1rem; font-size: 0.85em; opacity: 0.8; }

        /* --- How to Use Button and Modal --- */
        #how-to-use-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
            padding: 0.6rem 1.2rem; /* Slightly smaller */
            font-size: 0.9rem;
            border-radius: 50px; /* Rounded */
            background: var(--accent-secondary);
            box-shadow: var(--box-shadow-soft);
        }
         #how-to-use-button:hover:not(:disabled) {
            box-shadow: 0 5px 15px rgba(228, 118, 228, 0.4);
            transform: translateY(-2px) scale(1.05);
        }

        #guide-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(26, 26, 29, 0.8); /* Darker overlay */
            backdrop-filter: blur(4px);
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            z-index: 1002;
            padding: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
         #guide-modal.show {
            display: flex;
            opacity: 1;
        }

        #guide-modal-content {
            background-color: var(--bg-card);
            padding: 2.5rem;
            border-radius: var(--border-radius-md);
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color);
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
         #guide-modal.show #guide-modal-content {
             transform: scale(1);
         }

        #guide-modal-content h3 {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent-primary);
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid var(--border-color);
        }
        #guide-modal-content h4 {
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-top: 1.5rem;
            margin-bottom: 0.6rem;
            font-weight: 600;
        }
        #guide-modal-content p, #guide-modal-content li {
            font-size: 0.95rem;
            color: var(--text-secondary);
            line-height: 1.7;
            margin-bottom: 0.5rem;
        }
        #guide-modal-content ul {
            padding-left: 20px;
            margin-top: 0.5rem;
        }
        #guide-modal-content strong {
            color: var(--text-primary);
            font-weight: 500;
        }

        #close-guide-modal {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.8rem; /* Larger close icon */
            color: var(--text-secondary);
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        #close-guide-modal:hover {
            color: var(--text-primary);
            transform: scale(1.1) rotate(90deg);
        }


        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
            .container { max-width: 90%; }
            .main-nav ul { gap: 1rem; }
            .main-nav ul li a { font-size: 0.95rem; padding: 0.4rem 0.6rem; }
            #settings-box label { display: none; }
            .form-container { padding: 2rem; }
            #guide-modal-content { padding: 2rem; }
        }

        @media (max-width: 768px) {
            html { font-size: 15px; }
            :root { --nav-height: 60px; }
            main { padding-top: calc(var(--nav-height) + 1.5rem); }
            .main-nav { padding: 0 1.5rem; flex-wrap: wrap; height: auto; min-height: var(--nav-height); align-content: center; }
            .logo { font-size: 1.2rem; }
            .main-nav ul { order: 3; width: 100%; justify-content: center; padding: 0.5rem 0; border-top: 1px solid var(--border-color); margin-top: 0.5rem; gap: 0.8rem; }
            #settings-box { order: 2; margin-left: auto; padding-bottom: 0.5rem; }
            .hero-section { padding: 3rem 0.5rem; }
            .hero-section h1 { font-size: clamp(1.8rem, 6vw, 2.5rem); }
            .hero-section .tagline { font-size: 1rem; }
            /* Stack budget columns on smaller screens */
            .budget-columns-container { grid-template-columns: 1fr; gap: 1rem; }
            .budget-column { min-height: auto; } /* Let height adjust */
            .result-card { padding: 1.5rem; }
            .result-card h2 { font-size: 1.4rem; }
            #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            #about-page .content-container { padding: 1.5rem; }
            .color-swatch { min-width: 100px; } /* Adjust color swatch min width */
            #how-to-use-button { bottom: 15px; right: 15px; padding: 0.5rem 1rem; font-size: 0.85rem; }
            #guide-modal-content { padding: 1.5rem; max-height: 80vh; }
            #guide-modal-content h3 { font-size: 1.5rem; }
            #close-guide-modal { top: 10px; right: 15px; font-size: 1.6rem; }
        }

        @media (max-width: 480px) {
            html { font-size: 14px; }
            .main-nav { padding: 0 1rem; }
            .main-nav ul { gap: 0.5rem; flex-wrap: wrap; justify-content: space-around; }
            .main-nav ul li a { padding: 0.4rem; font-size: 0.9rem; }
            #settings-box { width: 100%; order: 3; justify-content: center; margin-left: 0; margin-top: 0.5rem; padding-bottom: 0.5rem; }
            .container { padding: 0 1rem; }
            .form-container { padding: 1.5rem; }
            .form-container h1 { font-size: 1.8rem; margin-bottom: 1.5rem; }
            .form-group { margin-bottom: 1.5rem; }
            .audio-input-group { flex-direction: column; align-items: stretch; gap: 0.8rem; }
            input[type="file"]::file-selector-button { width: 100%; text-align: center; margin-right: 0; }
            .audio-input-group .btn { width: 100%; margin: 0;}
            #record-status { margin-left: 0; justify-content: center; width: 100%; margin-top: 0.3rem; }
            #generate-concept-button { max-width: 100%; padding: 0.9rem 1.2rem; font-size: 1rem; }
             /* Make generate lyrics button full width on small screens if desired */
             #generate-lyrics-button { width: 100%; margin-top: 1rem; }
            .btn { padding: 0.7rem 1.5rem; font-size: 0.95rem; }
            .action-buttons { gap: 1rem; }
            #result-visuals .image-placeholder-container,
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            #result-visuals .image-placeholder img { height: 130px; }
            #result-moodboard .image-placeholder img { height: 110px; }
            .color-palette-display { gap: 0.8rem; }
            .color-swatch { min-width: calc(50% - 0.4rem); } /* 2 columns */
            .color-swatch .color-block { height: 60px; }
            #result-fonts .font-sample { font-size: 1em; } /* Adjust font sample size */
            #how-to-use-button { bottom: 10px; right: 10px; padding: 0.4rem 0.8rem; font-size: 0.8rem; }
             #guide-modal-content { padding: 1.5rem 1rem; }
        }

    </style>
</head>
<body>

    <!-- Loading Overlay Div -->
    <div id="loading-overlay">
        <div class="loading-spinner"></div>
        <p
            data-lang-en="Generating creative sparks..."
            data-lang-es="Generando chispas creativas..."
            data-lang-vi="Đang tạo ra những tia sáng sáng tạo..."
            data-lang-ja="創造的な火花を生成中..."
            data-lang-zhcn="正在生成创意火花..."
            data-last-key="generatingCreativeSparks"
        >Generating creative sparks...</p>
    </div>

    <!-- Navigation -->
    <nav class="main-nav">
        <a href="#" data-page="home" class="logo nav-link">
             <!-- Assume logofinal(white).png exists or replace -->
             <img src="logofinal(white).png" alt="MV Generator Logo" style="max-height: 40px; width: auto; vertical-align: middle; border-radius: 3px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
             <span style="display: none;"
                data-lang-en="Logo"
                data-lang-es="Logo"
                data-lang-vi="Logo"
                data-lang-ja="ロゴ"
                data-lang-zhcn="标志"
             >Logo</span> <!-- Fallback Text -->
        </a>
        <ul>
            <li><a data-page="home" class="nav-link active"
                   data-lang-en="Home" data-lang-es="Inicio" data-lang-vi="Trang chủ" data-lang-ja="ホーム" data-lang-zhcn="首页"
                >Home</a></li>
            <li><a data-page="about" class="nav-link"
                   data-lang-en="About" data-lang-es="Acerca de" data-lang-vi="Giới thiệu" data-lang-ja="概要" data-lang-zhcn="关于"
                >About</a></li>
            <li><a data-page="feature" class="nav-link"
                   data-lang-en="Generate" data-lang-es="Generar" data-lang-vi="Tạo" data-lang-ja="生成" data-lang-zhcn="生成"
                >Generate</a></li>
        </ul>
        <!-- Settings Box for Language -->
        <div id="settings-box">
            <label for="language-select"
                data-lang-en="Language:" data-lang-es="Idioma:" data-lang-vi="Ngôn ngữ:" data-lang-ja="言語：" data-lang-zhcn="语言："
            >Language:</label>
            <select id="language-select">
                <option value="en">English</option>
                <option value="es">Español</option>
                <option value="vi">Tiếng Việt</option>
                <option value="ja">日本語</option>
                <option value="zh-CN">中文</option>
            </select>
        </div>
    </nav>

    <main>
        <!-- Home Page Section -->
        <section id="home-page" class="page active container">
            <div class="hero-section">
                <div class="hero-content">
                    <h1
                        data-lang-en="Unlock Visual Concepts for Your Music" data-lang-es="Desbloquea Conceptos Visuales para Tu Música" data-lang-vi="Mở khóa ý tưởng hình ảnh cho âm nhạc của bạn" data-lang-ja="あなたの音楽のためのビジュアルコンセプトを解き放つ" data-lang-zhcn="为您的音乐解锁视觉概念"
                    >Unlock Visual Concepts for Your Music</h1>
                    <p class="tagline"
                       data-lang-en="Transform your lyrics and ideas into stunning music video concepts with the power of AI." data-lang-es="Transforma tus letras e ideas en impresionantes conceptos de videos musicales con el poder de la IA." data-lang-vi="Biến lời bài hát và ý tưởng của bạn thành những ý tưởng video âm nhạc tuyệt đẹp với sức mạnh của AI." data-lang-ja="AIの力で、あなたの歌詞やアイデアを見事なミュージックビデオコンセプトに変えましょう。" data-lang-zhcn="借助人工智能的力量，将您的歌词和想法转化为令人惊叹的音乐视频概念。"
                    >Transform your lyrics and ideas into stunning music video concepts with the power of AI.</p>
                    <button id="explore-button" class="btn btn-primary"
                            data-lang-en="Start Generating" data-lang-es="Comenzar a Generar" data-lang-vi="Bắt đầu tạo" data-lang-ja="生成を開始" data-lang-zhcn="开始生成"
                        >Start Generating</button>
                </div>
            </div>
        </section>

        <!-- About Page Section -->
        <section id="about-page" class="page container">
            <div class="content-container">
                <h2
                    data-lang-en="About MV Generator" data-lang-es="Acerca del Generador MV" data-lang-vi="Về Trình tạo MV" data-lang-ja="MVジェネレーターについて" data-lang-zhcn="关于 MV 生成器"
                >About MV Generator</h2>
                <p
                   data-lang-en="Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, genre, and potentially audio transcript, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, color palettes, and even font suggestions. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!"
                   data-lang-es="¡Bienvenido al Generador de MV! Nos apasiona ayudar a los artistas a traducir sus creaciones musicales en historias visuales convincentes. Crear el concepto perfecto para un video musical puede ser desafiante, requiriendo una mezcla de visión artística y planificación práctica. Nuestra herramienta impulsada por IA está diseñada para cerrar esa brecha. Al analizar tus letras, palabras clave, género y potencialmente la transcripción de audio, el Generador de MV genera sugerencias personalizadas para conceptos de videos musicales, requisitos, estimaciones de presupuesto, inspiraciones visuales, paletas de colores e incluso sugerencias de fuentes. Nuestro objetivo es agilizar el proceso creativo, proporcionando una plataforma de lanzamiento para tus ideas y empoderándote para dar vida visual a tu música, ya seas un artista independiente o parte de una producción más grande. ¡Hagamos algo increíble juntos!"
                   data-lang-vi="Chào mừng bạn đến với Trình tạo MV! Chúng tôi đam mê giúp các nghệ sĩ chuyển đổi những sáng tạo âm nhạc của họ thành những câu chuyện hình ảnh hấp dẫn. Việc tạo ra ý tưởng video âm nhạc hoàn hảo có thể đầy thử thách, đòi hỏi sự kết hợp giữa tầm nhìn nghệ thuật và kế hoạch thực tế. Công cụ hỗ trợ AI của chúng tôi được thiết kế để thu hẹp khoảng cách đó. Bằng cách phân tích lời bài hát, từ khóa, thể loại và có thể cả bản ghi âm thanh của bạn, Trình tạo MV tạo ra các đề xuất phù hợp cho các khái niệm video âm nhạc, yêu cầu, ước tính ngân sách, nguồn cảm hứng trực quan, bảng màu và thậm chí cả đề xuất phông chữ. Chúng tôi mong muốn hợp lý hóa quy trình sáng tạo, cung cấp bệ phóng cho ý tưởng của bạn và trao quyền cho bạn để đưa âm nhạc của mình vào cuộc sống một cách trực quan, cho dù bạn là một nghệ sĩ độc lập hay là một phần của một nhà sản xuất lớn hơn. Hãy cùng nhau tạo ra điều gì đó tuyệt vời!"
                   data-lang-ja="MVジェネレーターへようこそ！私たちは、アーティストが音楽作品を魅力的なビジュアルストーリーに変換するお手伝いをすることに情熱を注いでいます。完璧なミュージックビデオのコンセプトを作り上げることは、芸術的なビジョンと実践的な計画の融合を必要とする、困難な作業となる場合があります。当社のAI搭載ツールは、そのギャップを埋めるために設計されています。あなたの歌詞、キーワード、ジャンル、そして場合によってはオーディオトランスクリプトを分析することにより、MVジェネレーターはミュージックビデオのコンセプト、要件、予算の見積もり、視覚的なインスピレーション、カラーパレット、さらにはフォントの提案に関するカスタマイズされた提案を生成します。私たちは、インディーズアーティストであろうと大規模なプロダクションの一部であろうと、あなたのアイデアの出発点を提供し、あなたの音楽を視覚的に実現する力を与えることで、創造的なプロセスを合理化することを目指しています。一緒に素晴らしいものを作りましょう！"
                   data-lang-zhcn="欢迎来到 MV 生成器！我们热衷于帮助艺术家将他们的音乐创作转化为引人入胜的视觉故事。制作完美的音乐视频概念可能具有挑战性，需要艺术视野和实际规划的结合。我们的人工智能工具旨在弥合这一差距。通过分析您的歌词、关键词、流派以及可能的音频转录稿，MV 生成器会生成量身定制的音乐视频概念、要求、预算估算、视觉灵感、调色板建议，甚至字体建议。我们的目标是简化创作过程，为您的想法提供一个启动平台，并使您能够将音乐以视觉方式呈现出来，无论您是独立艺术家还是大型制作团队的一员。让我们一起创造一些惊人的东西吧！"
                >
                    Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, genre, and potentially audio transcript, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, color palettes, and even font suggestions. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!
                </p>
                 <button class="btn btn-secondary btn-back" data-target="home"
                    data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页"
                >Back to Home</button>
            </div>
        </section>

        <!-- Feature Page Section (Input & Results) -->
        <section id="feature-page" class="page container">
            <!-- Input Form Area -->
            <div class="input-section">
                <div class="form-container">
                    <h1
                        data-lang-en="Generate Your MV Concept" data-lang-es="Genera Tu Concepto de MV" data-lang-vi="Tạo ý tưởng MV của bạn" data-lang-ja="MVコンセプトを生成" data-lang-zhcn="生成您的 MV 概念"
                    >Generate Your MV Concept</h1>

                    <form id="feature-form" onsubmit="return false;">
                        <div class="form-group">
                            <label for="lyrics-input"
                                data-lang-en="Music Lyrics:" data-lang-es="Letra de la Música:" data-lang-vi="Lời bài hát:" data-lang-ja="歌詞：" data-lang-zhcn="歌词："
                            >Music Lyrics:</label>
                            <textarea id="lyrics-input" rows="7" required
                                data-lang-en-placeholder="Paste your complete song lyrics here or generate random ones..." data-lang-es-placeholder="Pega la letra completa aquí o genera letras aleatorias..." data-lang-vi-placeholder="Dán lời bài hát đầy đủ vào đây hoặc tạo lời ngẫu nhiên..." data-lang-ja-placeholder="ここに完全な歌詞を貼り付けるか、ランダムな歌詞を生成します..." data-lang-zhcn-placeholder="在此处粘贴完整歌词或生成随机歌词..."
                                placeholder="Paste your complete song lyrics here or generate random ones..." ></textarea>
                            <!-- NEW: Generate Random Lyric Button -->
                            <button type="button" id="generate-lyrics-button" class="btn btn-secondary"
                                data-lang-en="Generate Random Lyric" data-lang-es="Generar Letra Aleatoria" data-lang-vi="Tạo lời ngẫu nhiên" data-lang-ja="ランダムな歌詞を生成" data-lang-zhcn="生成随机歌词"
                            >Generate Random Lyric</button>
                        </div>
                        <div class="form-group">
                            <label for="keywords-input"
                                data-lang-en="Keywords / Theme:" data-lang-es="Palabras Clave / Tema:" data-lang-vi="Từ khóa / Chủ đề:" data-lang-ja="キーワード / テーマ：" data-lang-zhcn="关键词/主题："
                            >Keywords / Theme:</label>
                            <input type="text" id="keywords-input" required
                                data-lang-en-placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle" data-lang-es-placeholder="ej., nostálgico, ambiente de verano, decadencia urbana, superación" data-lang-vi-placeholder="vd: hoài cổ, không khí mùa hè, suy tàn đô thị, vượt qua khó khăn" data-lang-ja-placeholder="例：ノスタルジック、夏の雰囲気、都市の荒廃、苦難の克服" data-lang-zhcn-placeholder="例如，怀旧、夏日氛围、城市衰败、克服困难"
                                placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle" >
                        </div>
                        <div class="form-group">
                            <label for="genre-select"
                                data-lang-en="Music Genre:" data-lang-es="Género Musical:" data-lang-vi="Thể loại âm nhạc:" data-lang-ja="音楽ジャンル：" data-lang-zhcn="音乐流派："
                            >Music Genre:</label>
                            <select id="genre-select" required>
                                <option value="" disabled selected
                                    data-lang-en="-- Select a Genre --" data-lang-es="-- Selecciona un Género --" data-lang-vi="-- Chọn một thể loại --" data-lang-ja="-- ジャンルを選択 --" data-lang-zhcn="-- 选择流派 --"
                                >-- Select a Genre --</option>
                                <option value="RnB">RnB / Soul</option>
                                <option value="Folk">Folk / Acoustic</option>
                                <option value="Rock">Rock</option>
                                <option value="Pop">Pop</option>
                                <option value="Hiphop">Hip-hop / Rap</option>
                                <option value="Electronic">Electronic</option>
                                <option value="Classical">Classical</option>
                                <option value="Country">Country</option>
                                <option value="Jazz">Jazz / Blues</option>
                                <option value="Reggae">Reggae</option>
                                <option value="Metal">Metal</option>
                                <option value="Other">Other / Fusion</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="track-upload"
                                data-lang-en="Track Input (Optional):" data-lang-es="Entrada de Pista (Opcional):" data-lang-vi="Nhập bản nhạc (Tùy chọn):" data-lang-ja="トラック入力（任意）：" data-lang-zhcn="音轨输入（可选）："
                            >Track Input (Optional):</label>
                            <div class="audio-input-group">
                                <input type="file" id="track-upload" accept="audio/*">
                                <button type="button" id="record-audio-button" class="btn btn-warning"
                                    data-lang-en-record="Record Audio" data-lang-es-record="Grabar Audio" data-lang-vi-record="Ghi âm" data-lang-ja-record="音声を録音" data-lang-zhcn-record="录制音频"
                                    data-lang-en-stop="Stop Recording" data-lang-es-stop="Detener Grabación" data-lang-vi-stop="Dừng ghi âm" data-lang-ja-stop="録音停止" data-lang-zhcn-stop="停止录制"
                                >Record Audio</button>
                                <span id="record-status" class="record-status-base">
                                    <span id="recording-animation" class="recording-dots" style="display: none;"><span></span><span></span><span></span></span>
                                    <span id="record-status-text"></span>
                                </span>
                            </div>
                            <small
                                data-lang-en="Upload an audio file or record your singing. Analysis enhances suggestions (requires browser support)." data-lang-es="Sube un archivo de audio o graba tu canto. El análisis mejora las sugerencias (requiere soporte del navegador)." data-lang-vi="Tải lên tệp âm thanh hoặc ghi âm giọng hát của bạn. Phân tích giúp cải thiện đề xuất (yêu cầu trình duyệt hỗ trợ)." data-lang-ja="オーディオファイルをアップロードするか、歌声を録音します。分析により提案が強化されます（ブラウザのサポートが必要です）。" data-lang-zhcn="上传音频文件或录制您的演唱。分析可增强建议（需要浏览器支持）。"
                            >
                                Upload an audio file or record your singing. Analysis enhances suggestions (requires browser support).
                            </small>
                        </div>
                        <div class="form-group" id="transcript-group" style="display: none;">
                            <label for="transcript-output"
                                data-lang-en="Singing Transcript (from recording):" data-lang-es="Transcripción del Canto (de grabación):" data-lang-vi="Bản ghi lời hát (từ ghi âm):" data-lang-ja="歌唱トランスクリプト（録音より）：" data-lang-zhcn="演唱转录稿（来自录音）："
                            >Singing Transcript (from recording):</label>
                            <textarea id="transcript-output" rows="4" readonly
                                data-lang-en-placeholder="Transcript will appear here..." data-lang-es-placeholder="La transcripción aparecerá aquí..." data-lang-vi-placeholder="Bản ghi sẽ xuất hiện ở đây..." data-lang-ja-placeholder="トランスクリプトがここに表示されます..." data-lang-zhcn-placeholder="转录稿将显示在此处..."
                                placeholder="Transcript will appear here..."></textarea>
                            <small
                                data-lang-en="This text will be analyzed along with lyrics." data-lang-es="Este texto se analizará junto con la letra." data-lang-vi="Văn bản này sẽ được phân tích cùng với lời bài hát." data-lang-ja="このテキストは歌詞とともに分析されます。" data-lang-zhcn="此文本将与歌词一起分析。"
                            >This text will be analyzed along with lyrics.</small>
                        </div>

                        <button type="button" id="generate-concept-button" class="btn btn-primary"
                            data-lang-en="Generate Concept" data-lang-es="Generar Concepto" data-lang-vi="Tạo ý tưởng" data-lang-ja="コンセプトを生成" data-lang-zhcn="生成概念"
                        >Generate Concept</button>
                    </form>
                </div>
            </div>

            <!-- Error Message Area -->
            <div id="error-message" class="error-message"
                 data-lang-en="An error occurred. Please check your input or try again later." data-lang-es="Ocurrió un error. Por favor, revisa tu entrada o inténtalo de nuevo más tarde." data-lang-vi="Đã xảy ra lỗi. Vui lòng kiểm tra đầu vào của bạn hoặc thử lại sau." data-lang-ja="エラーが発生しました。入力を確認するか、後でもう一度お試しください。" data-lang-zhcn="发生错误。请检查您的输入或稍后再试。"
                 data-error-key="errorUnknown"
            ></div>

            <!-- Results Area (Cards) -->
            <div class="results-section" id="results-output-area">
                <!-- Concept Card -->
                 <div id="result-concept-card" class="result-card" style="grid-column: 1 / -1; display: none;">
                     <h2>
                         <span data-lang-en="Concept / Key Visual" data-lang-es="Concepto / Visual Clave" data-lang-vi="Ý tưởng / Hình ảnh chủ đạo" data-lang-ja="コンセプト / キービジュアル" data-lang-zhcn="概念 / 关键视觉"
                         >Concept / Key Visual</span>
                     </h2>
                     <div class="card-content placeholder-notice" id="result-concept">
                         <p class="placeholder-notice"
                            data-placeholder-key="conceptPlaceholder"
                            data-lang-en="Your generated concept will appear here..." data-lang-es="Tu concepto generado aparecerá aquí..." data-lang-vi="Ý tưởng được tạo của bạn sẽ xuất hiện ở đây..." data-lang-ja="生成されたコンセプトがここに表示されます..." data-lang-zhcn="您生成的概念将显示在此处..."
                         >Your generated concept will appear here...</p>
                     </div>
                     <!-- Action buttons -->
                     <div class="action-buttons">
                         <button id="explore-more-button" class="btn btn-secondary" disabled
                             data-lang-en="Explore More Details" data-lang-es="Explorar Más Detalles" data-lang-vi="Khám phá thêm chi tiết" data-lang-ja="詳細をさらに探索" data-lang-zhcn="探索更多细节"
                         >Explore More Details</button>
                         <button id="regenerate-button" class="btn btn-secondary" disabled
                             data-lang-en="Re-Generate Concept" data-lang-es="Re-Generar Concepto" data-lang-vi="Tạo lại ý tưởng" data-lang-ja="コンセプトを再生成" data-lang-zhcn="重新生成概念"
                         >Re-Generate Concept</button>
                     </div>
                 </div>

                 <!-- Detailed Results Grid (Populated after 'Explore More', single column) -->
                 <div class="results-grid" id="detailed-results-grid" style="display: none;">
                     <div id="result-requirements-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Requirements for MV" data-lang-es="Requisitos para el MV" data-lang-vi="Yêu cầu đối với MV" data-lang-ja="MVの要件" data-lang-zhcn="MV 要求"
                             >Requirements for MV</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-requirements">
                            <ul class="placeholder-notice">
                                <li class="placeholder-notice"
                                    data-placeholder-key="requirementsPlaceholder"
                                    data-lang-en="Requirements list will appear here..." data-lang-es="La lista de requisitos aparecerá aquí..." data-lang-vi="Danh sách yêu cầu sẽ xuất hiện ở đây..." data-lang-ja="要件リストがここに表示されます..." data-lang-zhcn="要求列表将显示在此处..."
                                >Requirements list will appear here...</li>
                            </ul>
                         </div>
                     </div>

                     <!-- Budget Card -->
                     <div id="result-budget-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Estimated Budget" data-lang-es="Presupuesto Estimado" data-lang-vi="Ngân sách ước tính" data-lang-ja="推定予算" data-lang-zhcn="预估预算"
                             >Estimated Budget</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-budget">
                             <div class="budget-columns-container placeholder-notice">
                                 <p data-placeholder-key="budgetPlaceholder" class="placeholder-notice"
                                    data-lang-en="Budget details will appear here..." data-lang-es="Los detalles del presupuesto aparecerán aquí..." data-lang-vi="Chi tiết ngân sách sẽ xuất hiện ở đây..." data-lang-ja="予算の詳細がここに表示されます..." data-lang-zhcn="预算细节将显示在此处..."
                                 >Budget details will appear here...</p>
                             </div>
                             <small style="display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;"
                                data-lang-en="Note: Budgets are conceptual estimates and vary widely based on specifics like location, crew size, equipment, talent, etc." data-lang-es="Nota: Los presupuestos son estimaciones conceptuales y varían ampliamente según detalles como ubicación, equipo, equipamiento, talento, etc." data-lang-vi="Lưu ý: Ngân sách là ước tính khái niệm và thay đổi rất nhiều dựa trên các chi tiết cụ thể như địa điểm, quy mô đoàn làm phim, thiết bị, tài năng, v.v." data-lang-ja="注：予算は概念的な見積もりであり、場所、スタッフの規模、機材、タレントなどの詳細によって大きく変動します。" data-lang-zhcn="注意：预算是概念性估算，并根据地点、团队规模、设备、人才等具体情况而有很大差异。"
                                data-placeholder-key="budgetNotePlaceholder"
                             >Note: Budgets are conceptual estimates and vary widely based on specifics like location, crew size, equipment, talent, etc.</small>
                         </div>
                     </div>

                     <!-- Visuals Card -->
                     <div id="result-visuals-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Visual Demo (Key Images)" data-lang-es="Demo Visual (Imágenes Clave)" data-lang-vi="Minh họa Hình ảnh (Ảnh chính)" data-lang-ja="ビジュアルデモ（キーイメージ）" data-lang-zhcn="视觉演示（关键图像）"
                             >Visual Demo (Key Images)</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-visuals">
                            <div class="image-placeholder-container placeholder-notice">
                                <p data-placeholder-key="visualsPlaceholder" class="placeholder-notice"
                                   data-lang-en="Key visual descriptions will appear here..." data-lang-es="Las descripciones visuales clave aparecerán aquí..." data-lang-vi="Mô tả hình ảnh chính sẽ xuất hiện ở đây..." data-lang-ja="主要なビジュアルの説明がここに表示されます..." data-lang-zhcn="关键视觉描述将显示在此处..."
                                >Key visual descriptions will appear here...</p>
                            </div>
                             <small style="display: block; margin-top: 1rem; font-size: 0.85em;"
                                data-lang-en="Illustrative images based on descriptions." data-lang-es="Imágenes ilustrativas basadas en descripciones." data-lang-vi="Hình ảnh minh họa dựa trên mô tả." data-lang-ja="説明に基づいた説明的な画像。" data-lang-zhcn="基于描述的说明性图片。"
                                data-placeholder-key="visualsNotePlaceholder"
                             >Illustrative images based on descriptions.</small>
                         </div>
                     </div>

                     <!-- Moodboard Card -->
                     <div id="result-moodboard-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Moodboard Influences" data-lang-es="Influencias del Moodboard" data-lang-vi="Ảnh hưởng Moodboard" data-lang-ja="ムードボードの影響" data-lang-zhcn="情绪板影响"
                             >Moodboard Influences</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-moodboard">
                             <p data-placeholder-key="moodboardDescPlaceholder" id="moodboard-description" class="placeholder-notice"
                                data-lang-en="Moodboard description will appear here..." data-lang-es="La descripción del moodboard aparecerá aquí..." data-lang-vi="Mô tả moodboard sẽ xuất hiện ở đây..." data-lang-ja="ムードボードの説明がここに表示されます..." data-lang-zhcn="情绪板描述将显示在此处..."
                             >Moodboard description will appear here...</p>
                             <div class="image-placeholder-container placeholder-notice" id="moodboard-images">
                                <p data-placeholder-key="moodboardImgsPlaceholder" class="placeholder-notice"
                                   data-lang-en="Moodboard influence images will appear here..." data-lang-es="Las imágenes de influencia del moodboard aparecerán aquí..." data-lang-vi="Hình ảnh ảnh hưởng moodboard sẽ xuất hiện ở đây..." data-lang-ja="ムードボードの影響画像がここに表示されます..." data-lang-zhcn="情绪板影响图片将显示在此处..."
                                >Moodboard influence images will appear here...</p>
                             </div>
                              <small style="display: block; margin-top: 1rem; font-size: 0.85em;"
                                data-lang-en="Visual styles and elements for inspiration." data-lang-es="Estilos visuales y elementos para inspiración." data-lang-vi="Phong cách và yếu tố hình ảnh để lấy cảm hứng." data-lang-ja="インスピレーションのための視覚的なスタイルと要素。" data-lang-zhcn="用于灵感的视觉风格和元素。"
                                data-placeholder-key="moodboardNotePlaceholder"
                              >Visual styles and elements for inspiration.</small>
                         </div>
                     </div>

                     <!-- Font Suggestion Card -->
                     <div id="result-fonts-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Typography / Font Suggestion" data-lang-es="Sugerencia de Tipografía / Fuente" data-lang-vi="Gợi ý Kiểu chữ / Phông chữ" data-lang-ja="タイポグラフィ / フォントの提案" data-lang-zhcn="排版 / 字体建议"
                             >Typography / Font Suggestion</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-fonts">
                            <p class="placeholder-notice"
                                data-placeholder-key="fontsPlaceholder"
                                data-lang-en="Font suggestions will appear here..." data-lang-es="Las sugerencias de fuentes aparecerán aquí..." data-lang-vi="Gợi ý phông chữ sẽ xuất hiện ở đây..." data-lang-ja="フォントの提案がここに表示されます..." data-lang-zhcn="字体建议将显示在此处..."
                            >Font suggestions will appear here...</p>
                         </div>
                     </div>

                     <!-- Color Palette Card -->
                     <div id="result-palette-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Color Palette" data-lang-es="Paleta de Colores" data-lang-vi="Bảng màu" data-lang-ja="カラーパレット" data-lang-zhcn="调色板"
                             >Color Palette</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-palette">
                             <div class="color-palette-display placeholder-notice">
                                <p data-placeholder-key="palettePlaceholder" class="placeholder-notice"
                                   data-lang-en="Color palette will appear here..." data-lang-es="La paleta de colores aparecerá aquí..." data-lang-vi="Bảng màu sẽ xuất hiện ở đây..." data-lang-ja="カラーパレットがここに表示されます..." data-lang-zhcn="调色板将显示在此处..."
                                >Color palette will appear here...</p>
                             </div>
                         </div>
                     </div>
                 </div><!-- End #detailed-results-grid -->
            </div> <!-- End #results-output-area -->

            <!-- Back button for the feature page -->
             <button class="btn btn-secondary btn-back" data-target="home" style="display: block; width: fit-content; margin: 3rem auto 0 auto;"
                data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页"
             >Back to Home</button>

        </section>
    </main>

    <!-- NEW: How to Use Button -->
    <button id="how-to-use-button" class="btn"
        data-lang-en="How to Use"
        data-lang-es="Cómo Usar"
        data-lang-vi="Cách dùng"
        data-lang-ja="使い方"
        data-lang-zhcn="如何使用"
    >How to Use</button>

    <!-- NEW: Guide Modal -->
    <div id="guide-modal">
        <div id="guide-modal-content">
            <button id="close-guide-modal" aria-label="Close Guide">&times;</button>
            <h3 data-lang-en="How to Use MV Generator" data-lang-es="Cómo Usar el Generador MV" data-lang-vi="Cách Sử dụng Trình tạo MV" data-lang-ja="MVジェネレーターの使い方" data-lang-zhcn="如何使用 MV 生成器">How to Use MV Generator</h3>

            <h4 data-lang-en="1. Input Your Song Details" data-lang-es="1. Ingresa los Detalles de tu Canción" data-lang-vi="1. Nhập chi tiết bài hát" data-lang-ja="1. 曲の詳細を入力" data-lang-zhcn="1. 输入您的歌曲详情">1. Input Your Song Details</h4>
            <p data-lang-en="Navigate to the 'Generate' page using the top menu." data-lang-es="Navega a la página 'Generar' usando el menú superior." data-lang-vi="Đi đến trang 'Tạo' bằng menu trên cùng." data-lang-ja="上部のメニューを使用して「生成」ページに移動します。" data-lang-zhcn="使用顶部菜单导航到“生成”页面。">Navigate to the 'Generate' page using the top menu.</p>
            <ul>
                <li data-lang-en="<strong>Music Lyrics:</strong> Paste your full song lyrics here. This is the most crucial input for the AI." data-lang-es="<strong>Letra de la Música:</strong> Pega la letra completa de tu canción aquí. Esta es la entrada más crucial para la IA." data-lang-vi="<strong>Lời bài hát:</strong> Dán toàn bộ lời bài hát của bạn vào đây. Đây là đầu vào quan trọng nhất cho AI." data-lang-ja="<strong>歌詞：</strong>ここに完全な歌詞を貼り付けてください。これはAIにとって最も重要な入力です。" data-lang-zhcn="<strong>歌词：</strong>在此处粘贴完整的歌词。这是 AI 最关键的输入。"><strong>Music Lyrics:</strong> Paste your full song lyrics here. This is the most crucial input for the AI.</li>
                <li data-lang-en="<strong>Generate Random Lyric Button:</strong> Don't have lyrics? Click this button! It will create random, structured lyrics (Intro, Verse, Chorus etc.) in the text box for you to experiment with." data-lang-es="<strong>Botón Generar Letra Aleatoria:</strong> ¿No tienes letra? ¡Haz clic en este botón! Creará letras aleatorias y estructuradas (Intro, Verso, Coro, etc.) en el cuadro de texto para que experimentes." data-lang-vi="<strong>Nút Tạo lời ngẫu nhiên:</strong> Bạn chưa có lời bài hát? Nhấn nút này! Nó sẽ tạo lời bài hát ngẫu nhiên, có cấu trúc (Intro, Verse, Chorus, v.v.) trong hộp văn bản để bạn thử nghiệm." data-lang-ja="<strong>ランダムな歌詞を生成ボタン：</strong>歌詞がありませんか？このボタンをクリックしてください！テキストボックスにランダムで構造化された歌詞（イントロ、ヴァース、コーラスなど）を作成し、試すことができます。" data-lang-zhcn="<strong>生成随机歌词按钮：</strong>还没有歌词？单击此按钮！它将在文本框中为您创建随机的、结构化的歌词（前奏、主歌、副歌等），供您试验。"><strong>Generate Random Lyric Button:</strong> Don't have lyrics? Click this button! It will create random, structured lyrics (Intro, Verse, Chorus etc.) in the text box for you to experiment with.</li>
                <li data-lang-en="<strong>Keywords / Theme:</strong> Add words describing the song's mood, style, or visual ideas (e.g., 'lonely night drive', 'energetic city life', 'dreamy forest')." data-lang-es="<strong>Palabras Clave / Tema:</strong> Agrega palabras que describan el estado de ánimo, estilo o ideas visuales de la canción (ej., 'viaje nocturno solitario', 'vida urbana energética', 'bosque de ensueño')." data-lang-vi="<strong>Từ khóa / Chủ đề:</strong> Thêm các từ mô tả tâm trạng, phong cách hoặc ý tưởng hình ảnh của bài hát (ví dụ: 'lái xe đêm cô đơn', 'cuộc sống thành phố năng động', 'khu rừng thơ mộng')." data-lang-ja="<strong>キーワード / テーマ：</strong>曲のムード、スタイル、または視覚的なアイデアを説明する単語を追加します（例：「孤独な夜のドライブ」、「エネルギッシュな都市生活」、「夢のような森」）。" data-lang-zhcn="<strong>关键词/主题：</strong>添加描述歌曲情绪、风格或视觉想法的词语（例如，“孤独的夜间驾驶”、“充满活力的城市生活”、“梦幻森林”）。"><strong>Keywords / Theme:</strong> Add words describing the song's mood, style, or visual ideas (e.g., 'lonely night drive', 'energetic city life', 'dreamy forest').</li>
                <li data-lang-en="<strong>Music Genre:</strong> Select the genre that best fits your song." data-lang-es="<strong>Género Musical:</strong> Selecciona el género que mejor se adapte a tu canción." data-lang-vi="<strong>Thể loại âm nhạc:</strong> Chọn thể loại phù hợp nhất với bài hát của bạn." data-lang-ja="<strong>音楽ジャンル：</strong>あなたの曲に最も合うジャンルを選択してください。" data-lang-zhcn="<strong>音乐流派：</strong>选择最适合您歌曲的流派。"><strong>Music Genre:</strong> Select the genre that best fits your song.</li>
                <li data-lang-en="<strong>Track Input (Optional):</strong> You can upload an audio file or record your singing. The AI can analyze the audio for better suggestions (transcription requires browser support)." data-lang-es="<strong>Entrada de Pista (Opcional):</strong> Puedes subir un archivo de audio o grabar tu canto. La IA puede analizar el audio para obtener mejores sugerencias (la transcripción requiere soporte del navegador)." data-lang-vi="<strong>Nhập bản nhạc (Tùy chọn):</strong> Bạn có thể tải lên tệp âm thanh hoặc ghi âm giọng hát của mình. AI có thể phân tích âm thanh để có đề xuất tốt hơn (ghi âm yêu cầu trình duyệt hỗ trợ)." data-lang-ja="<strong>トラック入力（任意）：</strong>オーディオファイルをアップロードするか、歌声を録音できます。AIはオーディオを分析してより良い提案を行うことができます（トランスクリプションにはブラウザのサポートが必要です）。" data-lang-zhcn="<strong>音轨输入（可选）：</strong>您可以上传音频文件或录制您的演唱。AI 可以分析音频以提供更好的建议（转录需要浏览器支持）。"><strong>Track Input (Optional):</strong> You can upload an audio file or record your singing. The AI can analyze the audio for better suggestions (transcription requires browser support).</li>
            </ul>

            <h4 data-lang-en="2. Generate the Concept" data-lang-es="2. Genera el Concepto" data-lang-vi="2. Tạo ý tưởng" data-lang-ja="2. コンセプトを生成" data-lang-zhcn="2. 生成概念">2. Generate the Concept</h4>
            <p data-lang-en="Click the 'Generate Concept' button. The AI will analyze your inputs and create an initial Music Video Concept / Key Visual idea." data-lang-es="Haz clic en el botón 'Generar Concepto'. La IA analizará tus entradas y creará una idea inicial de Concepto de Video Musical / Visual Clave." data-lang-vi="Nhấp vào nút 'Tạo ý tưởng'. AI sẽ phân tích đầu vào của bạn và tạo ra ý tưởng Ban đầu về Ý tưởng Video Âm nhạc / Hình ảnh Chủ đạo." data-lang-ja="「コンセプトを生成」ボタンをクリックします。AIがあなたの入力を分析し、最初のミュージックビデオコンセプト/キービジュアルのアイデアを作成します。" data-lang-zhcn="单击“生成概念”按钮。AI 将分析您的输入并创建初始的音乐视频概念/关键视觉想法。">Click the 'Generate Concept' button. The AI will analyze your inputs and create an initial Music Video Concept / Key Visual idea.</p>

            <h4 data-lang-en="3. Explore or Regenerate" data-lang-es="3. Explora o Regenera" data-lang-vi="3. Khám phá hoặc Tạo lại" data-lang-ja="3. 詳細を探索または再生成" data-lang-zhcn="3. 探索或重新生成">3. Explore or Regenerate</h4>
            <ul>
                <li data-lang-en="<strong>Explore More Details:</strong> Happy with the concept? Click this to get detailed Requirements, Budget Estimates, Visual Demos, Moodboard ideas, Font suggestions, and a Color Palette." data-lang-es="<strong>Explorar Más Detalles:</strong> ¿Contento con el concepto? Haz clic aquí para obtener Requisitos detallados, Estimaciones de Presupuesto, Demos Visuales, ideas de Moodboard, sugerencias de Fuentes y una Paleta de Colores." data-lang-vi="<strong>Khám phá thêm chi tiết:</strong> Hài lòng với ý tưởng? Nhấp vào đây để nhận Yêu cầu chi tiết, Ước tính Ngân sách, Minh họa Hình ảnh, ý tưởng Moodboard, gợi ý Phông chữ và Bảng màu." data-lang-ja="<strong>詳細をさらに探索：</strong>コンセプトに満足しましたか？これをクリックして、詳細な要件、予算の見積もり、ビジュアルデモ、ムードボードのアイデア、フォントの提案、カラーパレットを入手してください。" data-lang-zhcn="<strong>探索更多细节：</strong>对概念满意吗？单击此按钮可获取详细的要求、预算估算、视觉演示、情绪板想法、字体建议和调色板。"><strong>Explore More Details:</strong> Happy with the concept? Click this to get detailed Requirements, Budget Estimates, Visual Demos, Moodboard ideas, Font suggestions, and a Color Palette.</li>
                <li data-lang-en="<strong>Re-Generate Concept:</strong> Not quite right? Click this to ask the AI for a completely new concept based on the same inputs." data-lang-es="<strong>Re-Generar Concepto:</strong> ¿No es exactamente lo que buscas? Haz clic aquí para pedirle a la IA un concepto completamente nuevo basado en las mismas entradas." data-lang-vi="<strong>Tạo lại ý tưởng:</strong> Chưa đúng ý? Nhấp vào đây để yêu cầu AI tạo một ý tưởng hoàn toàn mới dựa trên cùng một đầu vào." data-lang-ja="<strong>コンセプトを再生成：</strong>あまり良くありませんか？これをクリックして、同じ入力に基づいて完全に新しいコンセプトをAIに依頼します。" data-lang-zhcn="<strong>重新生成概念：</strong>不太对？单击此按钮可要求 AI 基于相同的输入生成全新的概念。"><strong>Re-Generate Concept:</strong> Not quite right? Click this to ask the AI for a completely new concept based on the same inputs.</li>
            </ul>

             <h4 data-lang-en="4. Other Features" data-lang-es="4. Otras Características" data-lang-vi="4. Các tính năng khác" data-lang-ja="4. その他の機能" data-lang-zhcn="4. 其他功能">4. Other Features</h4>
            <ul>
                <li data-lang-en="<strong>Language Selector:</strong> Change the website language using the dropdown in the top navigation bar." data-lang-es="<strong>Selector de Idioma:</strong> Cambia el idioma del sitio web usando el menú desplegable en la barra de navegación superior." data-lang-vi="<strong>Bộ chọn Ngôn ngữ:</strong> Thay đổi ngôn ngữ trang web bằng menu thả xuống ở thanh điều hướng trên cùng." data-lang-ja="<strong>言語セレクター：</strong>上部のナビゲーションバーにあるドロップダウンを使用して、ウェブサイトの言語を変更します。" data-lang-zhcn="<strong>语言选择器：</strong>使用顶部导航栏中的下拉菜单更改网站语言。"><strong>Language Selector:</strong> Change the website language using the dropdown in the top navigation bar.</li>
                 <li data-lang-en="<strong>About Page:</strong> Learn more about the purpose of this tool." data-lang-es="<strong>Página Acerca de:</strong> Aprende más sobre el propósito de esta herramienta." data-lang-vi="<strong>Trang Giới thiệu:</strong> Tìm hiểu thêm về mục đích của công cụ này." data-lang-ja="<strong>概要ページ：</strong>このツールの目的について詳しく学びます。" data-lang-zhcn="<strong>关于页面：</strong>了解有关此工具用途的更多信息。"><strong>About Page:</strong> Learn more about the purpose of this tool.</li>
            </ul>

            <p style="margin-top: 2rem; text-align: center; font-style: italic;"
               data-lang-en="Enjoy creating!" data-lang-es="¡Disfruta creando!" data-lang-vi="Thỏa sức sáng tạo!" data-lang-ja="作成をお楽しみください！" data-lang-zhcn="享受创作！"
            >Enjoy creating!</p>
        </div>
    </div>

    <footer class="main-footer">
        <div class="container">
            <p>&copy; 2025 MVPot. All rights reserved.</p>
            <!-- <p><a href="#">Privacy Policy</a> | <a href="#">Terms of Service</a></p> -->
        </div>
    </footer>


    <!-- ========= START JAVASCRIPT ========= -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element References ---
        const navLinks = document.querySelectorAll('.nav-link');
        const pages = document.querySelectorAll('.page');
        const exploreButton = document.getElementById('explore-button');
        const backButtons = document.querySelectorAll('.btn-back');
        const generateConceptButton = document.getElementById('generate-concept-button');
        const generateLyricsButton = document.getElementById('generate-lyrics-button'); // <-- NEW
        const resultsOutputArea = document.getElementById('results-output-area');
        const conceptCard = document.getElementById('result-concept-card');
        const detailedResultsGrid = document.getElementById('detailed-results-grid');
        const exploreMoreButton = document.getElementById('explore-more-button');
        const regenerateButton = document.getElementById('regenerate-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const errorMessageDiv = document.getElementById('error-message');
        const recordAudioButton = document.getElementById('record-audio-button');
        const recordStatus = document.getElementById('record-status');
        const recordingAnimation = document.getElementById('recording-animation');
        const recordStatusText = document.getElementById('record-status-text');
        const lyricsInput = document.getElementById('lyrics-input');
        const keywordsInput = document.getElementById('keywords-input');
        const genreSelect = document.getElementById('genre-select');
        const trackUploadInput = document.getElementById('track-upload');
        const transcriptGroup = document.getElementById('transcript-group');
        const transcriptOutput = document.getElementById('transcript-output');
        const languageSelect = document.getElementById('language-select');
        const howToUseButton = document.getElementById('how-to-use-button'); // <-- NEW
        const guideModal = document.getElementById('guide-modal'); // <-- NEW
        const guideModalContent = document.getElementById('guide-modal-content'); // <-- NEW
        const closeGuideModal = document.getElementById('close-guide-modal'); // <-- NEW
        // Update querySelectorAll to include new translatable elements
        const allTranslatableElements = document.querySelectorAll('[data-lang-en], [data-lang-en-placeholder]');

        // --- State Variables ---
        let currentInputs = null; // Store form inputs for regeneration/exploration
        let currentLang = 'en'; // Default language
        let activePage = 'home'; // Track current page

        // --- Audio Recording Variables ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordedAudioBlob = null;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let finalTranscript = '';
        let isSpeechRecognitionSupported = !!SpeechRecognition;

        // --- Mapping for Section Processing & Placeholders ---
        const sections = { // Maps Header Title to Content Div ID
            'Concept / Key Visual': 'result-concept',
            'Requirements for MV': 'result-requirements',
            'Estimated Budget': 'result-budget',
            'Visual Demo (Key Image Descriptions)': 'result-visuals', // Keep original for potential AI variations
            'Visual Demo (Key Images)': 'result-visuals', // Preferred name used in prompt
            'Moodboard Influences': 'result-moodboard',
            'Typography/Font Suggestion': 'result-fonts',
            'Color Palette': 'result-palette'
        };
        const cardElements = { // Maps Header Title to Card Element
            'Concept / Key Visual': conceptCard,
            'Requirements for MV': document.getElementById('result-requirements-card'),
            'Estimated Budget': document.getElementById('result-budget-card'),
            'Visual Demo (Key Image Descriptions)': document.getElementById('result-visuals-card'),
            'Visual Demo (Key Images)': document.getElementById('result-visuals-card'),
            'Moodboard Influences': document.getElementById('result-moodboard-card'),
            'Typography/Font Suggestion': document.getElementById('result-fonts-card'),
            'Color Palette': document.getElementById('result-palette-card')
         };

        // --- Page Navigation ---
        function showPage(pageId) {
            activePage = pageId;
            pages.forEach(page => {
                page.classList.toggle('active', page.id === `${pageId}-page`);
            });
            navLinks.forEach(link => {
                 const linkPage = link.getAttribute('data-page');
                 if (link.classList.contains('logo') || (link.parentElement && link.parentElement.tagName === 'LI')) {
                     link.classList.toggle('active', linkPage === pageId);
                 }
            });
            window.scrollTo(0, 0);
             if (pageId !== 'feature') {
                 resultsOutputArea.style.display = 'none';
                 detailedResultsGrid.style.display = 'none';
                 conceptCard.style.display = 'none';
                 errorMessageDiv.style.display = 'none';
                 clearResultsContent();
             }
        }

        // --- Loading Overlay Control ---
        function showLoading(messageKey = "generatingCreativeSparks", fallbackMessage = "Generating creative sparks...") {
             if (!loadingOverlay) return;
             const textElement = loadingOverlay.querySelector('p');
             if (textElement) {
                 const translatedMessage = getTranslatedText(textElement, messageKey, false, fallbackMessage);
                 textElement.textContent = translatedMessage;
                 textElement.dataset.lastKey = messageKey; // Store key for re-translation
             }
             loadingOverlay.classList.add('show');
             // Disable buttons
             if(generateConceptButton) generateConceptButton.disabled = true;
             if(generateLyricsButton) generateLyricsButton.disabled = true; // <-- NEW
             if(exploreMoreButton) exploreMoreButton.disabled = true;
             if(regenerateButton) regenerateButton.disabled = true;
             if(recordAudioButton) recordAudioButton.disabled = true;
        }
        function hideLoading() {
            if (!loadingOverlay) return;
            loadingOverlay.classList.remove('show');
             // Re-enable buttons (consider states)
             if(generateConceptButton) generateConceptButton.disabled = false;
             if(generateLyricsButton) generateLyricsButton.disabled = false; // <-- NEW
             if(exploreMoreButton) exploreMoreButton.disabled = !currentInputs; // Only enable if concept exists
             if(regenerateButton) regenerateButton.disabled = !currentInputs; // Only enable if concept exists
             if(recordAudioButton) {
                  recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported) || isRecording;
             }
        }

        // --- Microphone Recording & Speech Recognition Logic ---
        // (Keep the existing audio logic as is)
         if (recordAudioButton) {
            recordAudioButton.addEventListener('click', handleRecordButtonClick);
            if (!navigator.mediaDevices?.getUserMedia) {
                updateRecordStatus('Audio recording not supported.', 'error', true, 'statusAudioNotSupported');
                recordAudioButton.disabled = true;
            } else if (!isSpeechRecognitionSupported) {
                updateRecordStatus('Speech recognition not supported.', 'error', true, 'statusSpeechRecNotSupported');
                recordAudioButton.disabled = true;
            }
        }

        async function handleRecordButtonClick() {
             if (!navigator.mediaDevices?.getUserMedia) { updateRecordStatus('Recording not supported by browser.', 'error', true, 'statusAudioNotSupported'); return; }
             if (!isSpeechRecognitionSupported) { updateRecordStatus('Speech recognition not supported.', 'error', true, 'statusSpeechRecNotSupported'); return; }

            if (!isRecording) { // Start Recording
                try {
                    recordedAudioBlob = null; trackUploadInput.value = ''; transcriptOutput.value = '';
                    finalTranscript = ''; transcriptGroup.style.display = 'none'; clearRecordStatus();
                    updateRecordStatus('Requesting mic access...', '', false, 'statusRequestingMic');
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    updateRecordStatus('', 'recording', false); // UI updated below

                    // MediaRecorder
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
                    mediaRecorder.onstop = () => {
                        recordedAudioBlob = (audioChunks.length > 0) ? new Blob(audioChunks, { type: 'audio/webm;codecs=opus' }) : null;
                        audioChunks = []; stream.getTracks().forEach(track => track.stop());
                        updateRecordingUI(false);
                        if (!recognition || !recognition.recognizing) { updateFinalRecordStatus(); }
                    };
                     mediaRecorder.onerror = (event) => {
                        console.error("MediaRecorder error:", event.error);
                        const errorMsg = getTranslatedText(null, 'statusRecordingError', false, `Recording error: ${event.error.name}`).replace('${errorName}', event.error.name);
                        updateRecordStatus(errorMsg, 'error', true);
                        if (recognition?.abort) { try { recognition.abort(); } catch(e){} }
                        stream.getTracks().forEach(track => track.stop()); updateRecordingUI(false);
                     };

                    // Speech Recognition
                    recognition = new SpeechRecognition();
                    recognition.continuous = true; recognition.interimResults = true;
                    const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' };
                    recognition.lang = bcp47Map[currentLang] || (currentLang.includes('-') ? currentLang : `${currentLang}-${currentLang.toUpperCase()}`);
                    console.log("SpeechRecognition language set to:", recognition.lang);

                    recognition.onresult = (event) => {
                        let interimTranscript = ''; finalTranscript = '';
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) { finalTranscript += event.results[i][0].transcript + ' '; }
                            else { interimTranscript += event.results[i][0].transcript; }
                        }
                        const currentFullTranscript = (finalTranscript + interimTranscript).trim();
                        transcriptOutput.value = currentFullTranscript;
                        if (currentFullTranscript) { transcriptGroup.style.display = 'block'; }
                         updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing');
                    };
                    recognition.onerror = (event) => {
                        console.error("Speech Recognition Error:", event.error, event.message);
                        let errorMsgKey = 'transcriptionErrorGeneric', errorParam = event.error;
                         if (event.error === 'no-speech') { errorMsgKey = 'transcriptionErrorNoSpeech'; errorParam = '';}
                         else if (event.error === 'audio-capture') { errorMsgKey = 'transcriptionErrorMicProblem'; errorParam = ''; }
                         else if (event.error === 'not-allowed') { errorMsgKey = 'transcriptionErrorPermission'; errorParam = '';}
                         else if (event.error === 'network') { errorMsgKey = 'transcriptionErrorNetwork'; errorParam = '';}
                         const translatedError = getTranslatedText(null, errorMsgKey, false, `Transcription error: ${errorParam}`);
                         if (!recordStatus?.classList.contains('error')) { updateRecordStatus(translatedError, 'error', true, errorMsgKey); }
                         if (mediaRecorder?.state === "recording" && event.error !== 'no-speech') { try { mediaRecorder.stop(); } catch(e){} }
                    };
                    recognition.onstart = () => { console.log("Speech recognition started."); updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing'); };
                    recognition.onend = () => {
                        console.log("Speech recognition ended."); finalTranscript = finalTranscript.trim();
                        transcriptOutput.value = finalTranscript;
                         if (!finalTranscript && transcriptGroup.style.display === 'block') { transcriptGroup.style.display = 'none'; }
                         if (!isRecording) { updateFinalRecordStatus(); }
                    };

                    // Start
                    audioChunks = []; mediaRecorder.start(); recognition.start(); updateRecordingUI(true);

                } catch (err) {
                    console.error("Error accessing microphone:", err);
                     let errorMsgKey = 'micErrorGeneric';
                     if (err.name === 'NotAllowedError') { errorMsgKey = 'micErrorPermission'; }
                     else if (err.name === 'NotFoundError') { errorMsgKey = 'micErrorNotFound'; }
                     else if (err.name === 'NotReadableError') { errorMsgKey = 'micErrorHardware'; }
                     updateRecordStatus(getTranslatedText(null, errorMsgKey, false, 'Microphone access error.'), 'error', true, errorMsgKey);
                    updateRecordingUI(false);
                }
            } else { // Stop Recording
                 if (mediaRecorder?.state === "recording") {
                    updateRecordStatus(getTranslatedText(null, 'statusStopping', false, 'Stopping...'), '', false, 'statusStopping');
                    try { mediaRecorder.stop(); } catch(e){}
                }
                if (recognition?.stop) {
                     try { recognition.stop(); }
                     catch (e) { if (!isRecording) { updateFinalRecordStatus(); } }
                } else if (!isRecording) { updateFinalRecordStatus(); }
            }
        }

         function updateFinalRecordStatus() {
             setTimeout(() => {
                  if (recordStatus?.classList.contains('error')) return; // Don't overwrite error
                  let finalStatusMsgKey = 'stoppedStatus', finalStatusClass = '', isPersistent = false;
                  if (recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'recordTranscriptComplete'; finalStatusClass = 'complete'; isPersistent = true; }
                  else if (recordedAudioBlob && !finalTranscript) { finalStatusMsgKey = 'recordCompleteNoTranscript'; finalStatusClass = 'complete'; isPersistent = true; }
                  else if (!recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'transcriptCompleteNoRecord'; finalStatusClass = 'complete'; isPersistent = true; }
                  updateRecordStatus(getTranslatedText(null, finalStatusMsgKey, false, 'Stopped.'), finalStatusClass, isPersistent, finalStatusMsgKey);
             }, 100);
         }

        function updateRecordingUI(recording) {
            if (!recordAudioButton) return; isRecording = recording;
            const recordKey = 'record', stopKey = 'stop';
            const buttonText = recording ? getTranslatedText(recordAudioButton, stopKey, false, 'Stop Recording') : getTranslatedText(recordAudioButton, recordKey, false, 'Record Audio');
            recordAudioButton.textContent = buttonText; recordAudioButton.disabled = false;
            if (recording) {
                recordAudioButton.classList.remove('btn-warning'); recordAudioButton.classList.add('btn-danger');
                if(recordingAnimation) recordingAnimation.style.display = 'inline-block';
                 updateRecordStatus(getTranslatedText(null, 'statusRecording', false, 'Recording...'), 'recording', false, 'statusRecording');
            } else {
                recordAudioButton.classList.remove('btn-danger'); recordAudioButton.classList.add('btn-warning');
                if(recordingAnimation) recordingAnimation.style.display = 'none';
                recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported);
            }
         }

        function updateRecordStatus(message, statusClass = '', persistent = false, translationKey = '') {
            if (!recordStatus || !recordStatusText || !recordingAnimation) return;
             if (updateRecordStatus.timeoutId) { clearTimeout(updateRecordStatus.timeoutId); updateRecordStatus.timeoutId = null; }
             const displayMessage = translationKey ? getTranslatedText(null, translationKey, false, message) : message;
            recordStatusText.textContent = displayMessage;
            recordStatus.className = 'record-status-base'; // Reset
            recordStatus.dataset.statusKey = translationKey; recordStatus.dataset.statusFallback = message; // Store for re-translation
            if (statusClass) recordStatus.classList.add(statusClass);
            recordingAnimation.style.display = (statusClass === 'recording' || statusClass === 'transcribing') ? 'inline-block' : 'none';
            if (!persistent && statusClass !== 'error' && displayMessage) {
                updateRecordStatus.timeoutId = setTimeout(() => {
                     if (recordStatusText.textContent === displayMessage && recordStatus.dataset.statusKey === translationKey) { clearRecordStatus(); }
                }, 4000);
            }
         }
         updateRecordStatus.timeoutId = null;

         function clearRecordStatus() {
            if (recordStatusText) recordStatusText.textContent = '';
            if (recordStatus) { recordStatus.className = 'record-status-base'; delete recordStatus.dataset.statusKey; delete recordStatus.dataset.statusFallback; }
            if (recordingAnimation) recordingAnimation.style.display = 'none';
            if (updateRecordStatus.timeoutId) { clearTimeout(updateRecordStatus.timeoutId); updateRecordStatus.timeoutId = null; }
         }

        if(trackUploadInput) {
             trackUploadInput.addEventListener('change', () => {
                 if (trackUploadInput.files.length > 0) {
                     if (isRecording) {
                         if (mediaRecorder?.state === "recording") try { mediaRecorder.stop(); } catch(e){}
                         if (recognition?.abort) try { recognition.abort(); } catch(e){}
                         updateRecordingUI(false);
                     }
                     recordedAudioBlob = null; transcriptOutput.value = ''; finalTranscript = '';
                     transcriptGroup.style.display = 'none';
                     updateRecordStatus(getTranslatedText(null, 'statusFileSelected', false, 'File selected.'), 'complete', true, 'statusFileSelected');
                     console.log("File selected, cleared recording state.");
                 }
             });
        }


        // --- NEW: Random Lyric Generation ---
        function generateRandomLyrics() {
            const structures = ['Intro', 'Verse', 'Chorus', 'Verse', 'Chorus', 'Bridge', 'Chorus', 'Outro'];
            const lines = {
                Intro: [
                    "Yeah...", "Listen...", "In the quiet of the dawn...", "Another day begins...", "(Instrumental intro vibe)"
                ],
                Verse: [
                    "Walking down these empty streets again,", "Lost in thought, the city sleeps,", "Remember echoes of a distant past,",
                    "Sunlight paints the window pane,", "Another coffee, numb the pain,", "Trying to find where I belong,",
                    "The rhythm of the falling rain,", "Whispers carried on the breeze,", "A photograph begins to fade,",
                    "Watching shadows start to grow,"
                ],
                Chorus: [
                    "Oh, this feeling takes me higher,", "Burning bright, a hidden fire,", "Can we turn back time somehow?", "Just let go, right here and now.",
                    "We're searching for a guiding light,", "Through the darkness of the night,", "Holding on to what we know,", "Where do we go, where do we go?",
                    "This melody, it sets me free,", "Just you and I, wild and carefree,", "A moment caught, eternally,", "Is this dream reality?"
                ],
                Bridge: [
                    "Maybe we were meant to stray,", "Find a different path, a different way,", "Worlds apart, yet still connected,",
                    "Underneath the silver moon's soft glow,", "There's a truth I need to know,", "Before the final curtain falls,"
                ],
                Outro: [
                    "Fading out... into the night...", "Just an echo...", "Yeah, gone...", "(Fade out)", "Until next time..."
                ]
            };

            let fullLyrics = "";
            let sentenceCount = 0;
            const minSentences = 10;

             // Helper to get a random item from an array
             const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];

             // Build the song structure ensuring minimum length
             let currentStructure = [];
             while (sentenceCount < minSentences) {
                 // Add standard structure first
                 if (structures.length > 0) {
                     const part = structures.shift(); // Take next part from standard structure
                     currentStructure.push(part);
                     const numLines = (part === 'Chorus' || part === 'Verse') ? getRandom([2, 3]) : 1;
                     for (let i = 0; i < numLines; i++) {
                         if (lines[part]) { sentenceCount++; } // Increment count for each line added
                     }
                 } else {
                     // If standard structure is done but still need sentences, add random verses/choruses
                     const randomPart = getRandom(['Verse', 'Chorus']);
                     currentStructure.push(randomPart);
                      const numLines = (randomPart === 'Chorus' || randomPart === 'Verse') ? getRandom([2, 3]) : 1;
                      for (let i = 0; i < numLines; i++) {
                         if (lines[randomPart]) { sentenceCount++; }
                     }
                 }
             }
              // Ensure Outro is last if it exists
             if (currentStructure.includes('Outro') && currentStructure[currentStructure.length - 1] !== 'Outro') {
                currentStructure = currentStructure.filter(p => p !== 'Outro');
                currentStructure.push('Outro');
             }


            // Generate the lyrics text
            currentStructure.forEach((part, index) => {
                if (lines[part]) {
                    fullLyrics += `[${part}${index > 0 && part === currentStructure[index - 1] ? ' 2' : ''}]\n`; // Add section label (e.g., [Verse], [Chorus 2])
                    const numLines = (part === 'Chorus' || part === 'Verse') ? getRandom([2, 3]) : 1; // Generate 1-3 lines per section
                    let usedLines = new Set(); // Avoid immediate repetition within a section
                    for (let i = 0; i < numLines; i++) {
                        let line;
                        do {
                            line = getRandom(lines[part]);
                        } while (usedLines.has(line) && lines[part].length > 1); // Re-roll if line was just used (and there are alternatives)
                        usedLines.add(line);
                        fullLyrics += line + "\n";
                    }
                    fullLyrics += "\n"; // Add blank line between sections
                }
            });

            lyricsInput.value = fullLyrics.trim();
            console.log("Generated random lyrics.");
        }

        // --- Gemini API Call Helper ---
        async function callGeminiAPI(promptText, loadingMessageKey = "generatingCreativeSparks", loadingFallback = "Generating...") {
            // ##########################################################################
            // ### CRITICAL SECURITY WARNING: API KEY HARDCODED IN FRONTEND          ###
            // ### This key is exposed to anyone viewing the page source code.        ###
            // ### This is **NOT** safe for production environments.                  ###
            // ### For any real application, you MUST use a backend server (`server.js`)###
            // ### to proxy API calls and keep your key secure. USE FOR STUDY ONLY!   ###
            // ##########################################################################
            const GEMINI_API_KEY = "AIzaSyB5c-hp-QeKBpBTz8qwANe4j5Kc4dZ_bWM"; // <-- VERY INSECURE - MOVE TO BACKEND PROXY FOR REAL USE
            // ##########################################################################

            if (!GEMINI_API_KEY || GEMINI_API_KEY.startsWith("YOUR_") || GEMINI_API_KEY.length < 30) {
                 displayError(getTranslatedText(null, 'errorApiKeyInvalid', false, "API Key is missing or invalid. Configure it securely (backend recommended)."), 'errorApiKeyInvalid');
                 return null;
            }
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
            showLoading(loadingMessageKey, loadingFallback);

            const requestBody = {
                contents: [{ parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.75, maxOutputTokens: 4096 }, // Increased token limit slightly
                safetySettings: [
                   { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                ]
            };

            try {
                console.log("Sending API request to Gemini...");
                // NOTE: This direct browser call might *also* fail due to CORS. A backend proxy is the robust solution.
                const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                const responseData = await response.json();

                if (!response.ok) {
                     const errorDetail = responseData?.error?.message || `HTTP Error: ${response.status}`;
                     const httpErrorMsg = getTranslatedText(null, 'errorApiHttp', false, `API request failed: ${errorDetail}`).replace('${errorDetail}', errorDetail);
                     if (response.status === 0) { throw new Error(getTranslatedText(null, 'errorCorsOrNetwork', false, 'Network or CORS error contacting Gemini API. Check console & consider backend proxy.')); }
                     throw new Error(httpErrorMsg);
                }
                 const candidate = responseData?.candidates?.[0];
                 if (!candidate || responseData?.promptFeedback?.blockReason || candidate.finishReason === "SAFETY") {
                     const reason = candidate?.finishReason || responseData?.promptFeedback?.blockReason || "Unknown Safety Block";
                     const blockMessage = getTranslatedText(null, 'errorApiBlocked', false, `Content blocked due to safety filters (Reason: ${reason}). Please revise your input.`).replace('${reason}', reason);
                     throw new Error(blockMessage);
                 }
                 if (responseData?.error) {
                     const apiErrorMsg = getTranslatedText(null, 'errorApiGeneral', false, `API returned an error: ${responseData.error.message}`).replace('${errorMessage}', responseData.error.message);
                     throw new Error(apiErrorMsg);
                 }

                 const finishReason = candidate.finishReason;
                 if (finishReason && !["STOP", "MAX_TOKENS"].includes(finishReason)) { console.warn(`Gemini generation finished abnormally. Reason: ${finishReason}`); }
                 if (finishReason === "MAX_TOKENS") { console.warn("Gemini generation stopped due to maximum token limit."); }

                 if (candidate?.content?.parts?.[0]?.text) {
                     return candidate.content.parts[0].text.trim();
                 } else {
                     throw new Error(getTranslatedText(null, 'errorApiEmptyResponse', false, "Received an unexpected or empty text response from the AI."));
                 }

            } catch (error) {
                console.error("Error during Gemini fetch or processing:", error);
                 let errorKey = 'errorUnknown'; const msg = String(error.message).toLowerCase();
                 if (msg.includes("api key") || msg.includes("invalid")) errorKey = 'errorApiKeyInvalid';
                 else if (msg.includes("http error")) errorKey = 'errorApiHttp';
                 else if (msg.includes("blocked") || msg.includes("safety filter")) errorKey = 'errorApiBlocked';
                 else if (msg.includes("api returned an error")) errorKey = 'errorApiGeneral';
                 else if (msg.includes("no response candidate")) errorKey = 'errorApiNoCandidate';
                 else if (msg.includes("empty text response")) errorKey = 'errorApiEmptyResponse';
                 else if (msg.includes('failed to fetch') || msg.includes('networkerror') || msg.includes('cors')) errorKey = 'errorCorsOrNetwork';
                 displayError(error.message, errorKey);
                 return null;
            } finally {
                hideLoading();
            }
        }

        // --- Generate Initial Concept ---
        async function handleGenerateConcept() {
            const lyrics = lyricsInput.value.trim();
            const keywords = keywordsInput.value.trim();
            const selectedGenre = genreSelect.value;
            const singingTranscript = transcriptOutput.value.trim();

             let validationError = false, errorMsg = '', errorKey = '', focusEl = null;
             if (!lyrics) { errorMsg = getTranslatedText(lyricsInput, 'placeholder', true) || "Provide or generate lyrics."; errorKey = 'validationLyricsMissing'; focusEl = lyricsInput; validationError = true; }
             else if (!keywords) { errorMsg = getTranslatedText(keywordsInput, 'placeholder', true) || "Provide keywords."; errorKey = 'validationKeywordsMissing'; focusEl = keywordsInput; validationError = true; }
             else if (!selectedGenre) { errorMsg = getTranslatedText(genreSelect.options[0]) || "Select genre."; errorKey = 'validationGenreMissing'; focusEl = genreSelect; validationError = true; }
             if(validationError) { displayError(errorMsg, errorKey); focusEl?.focus(); return; }

            currentInputs = { lyrics, keywords, selectedGenre, singingTranscript };
            clearResultsAndErrors();

             const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Analyze the following song details:
**Lyrics:**\n\`\`\`\n${lyrics}\n\`\`\`${singingTranscript ? `\n**Singing Transcript (Optional Context):**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}\n**Music Genre:** ${selectedGenre}
Generate **ONLY** the "Concept / Key Visual" section for a music video based on these details. Structure your response *exactly* like this, starting directly with the header and providing content below it in well-written English:
## Concept / Key Visual
(Provide a concise, compelling core concept description here. Mention 1-2 key visual motifs or scenes.)`;

            const loadingMsgKey = "generatingConcept";
            const loadingFallback = "Generating Concept...";
            // !!! This call uses the INSECURE direct method. Replace with backend call in production. !!!
            const generatedText = await callGeminiAPI(prompt, loadingMsgKey, loadingFallback);

            if (generatedText) {
                resultsOutputArea.style.display = 'block';
                conceptCard.style.display = 'flex';
                detailedResultsGrid.style.display = 'none';
                const conceptContentDiv = document.getElementById('result-concept');
                 if (conceptContentDiv) { conceptContentDiv.innerHTML = ''; conceptContentDiv.classList.remove('placeholder-notice'); }
                parseAndDisplayResults(generatedText); // Populates concept card
                conceptCard.style.transitionDelay = '0s'; conceptCard.classList.add('visible');
                 if(exploreMoreButton) exploreMoreButton.disabled = false;
                 if(regenerateButton) regenerateButton.disabled = false;
                 setTimeout(() => { resultsOutputArea.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);
            }
        }

        // --- Explore More Details ---
        async function handleExploreMore() {
            if (!currentInputs) { displayError(getTranslatedText(null, 'errorExploreNoConcept', false, "Generate concept first."), 'errorExploreNoConcept'); return; }
            if(exploreMoreButton) exploreMoreButton.disabled = true;
            if(regenerateButton) regenerateButton.disabled = true;

            // --- Prompt for Detailed Results (Font and Color updates included) ---
            const { lyrics, keywords, selectedGenre, singingTranscript } = currentInputs;
            const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Based on the original song details:
**Lyrics:**\n\`\`\`\n${lyrics}\n\`\`\`${singingTranscript ? `\n**Singing Transcript (Optional Context):**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}\n**Music Genre:** ${selectedGenre}
Provide the following detailed sections for the music video. Structure *exactly* like this in English:

## Requirements for MV
(* or - list item: Detail about location, casting, props, wardrobe, cinematography, VFX, editing style, etc. Be specific and relevant.)

## Estimated Budget
(**Low Budget:** ~$Range (Optional). Description of approach.
- Example Item - $Cost (Optional, list a few key cost drivers if applicable)

**Mid Budget:** ~$Range (Optional). Description of approach, potentially scaling up elements from Low.
- Example Item - $Cost

**High Budget:** ~$Range (Optional). Description of approach, allowing for higher production value.
- Example Item - $Cost
)

## Visual Demo (Key Images)
(1. Vivid description of a key scene or visual moment suitable for image generation.
2. Another vivid description for image generation.
3. A third vivid description for image generation.)

## Moodboard Influences
(A short sentence describing the overall mood and visual style.
* Specific visual element or reference suitable for image generation (e.g., Film noir lighting, rainy cityscape).
* Another specific element for image generation (e.g., Wes Anderson symmetrical composition, pastel diner).
* Style reference for image generation (e.g., Surrealist painting style, dreamlike forest).
* Color influence (e.g., Muted pastels).
* Textural element (e.g., Grainy film stock).
)

## Typography/Font Suggestion
(Suggest ONE suitable font combination (1 or 2 fonts).
**Font Combination:** [Font Name 1] & [Font Name 2 (Optional)]
*Reason:* [Explain why this combination (or single font) fits the song's lyrics, theme, genre, and mood. Be specific.]
*Sample Title (Using Font 1):* "[Create a short, relevant sample sentence using the first font]"
*[Optional] Sample Body (Using Font 2):* "[Create a short, relevant sample sentence using the second font, if applicable]"
Provide actual, common font names (e.g., 'Montserrat', 'Playfair Display', 'Roboto Mono'). Ensure samples showcase the font's feel.)

## Color Palette
(List 3-5 colors. Indicate the DOMINANT color first. For each color, provide its name, hex code, and a brief application suggestion for the MV. Use the exact format below, one color per line.)
Dominant Color Name (#XXXXXX) - Application: [Use this for main backgrounds or character outfits to set the core mood.]
Secondary Color Name (#YYYYYY) - Application: [Apply to secondary elements like set dressing or subtle gradients.]
Accent Color Name (#ZZZZZZ) - Application: [Use sparingly to highlight key props, text overlays, or create visual contrast.]
(Add more secondary/accent colors if appropriate, following the same format)

Adhere strictly to the format: Use the exact headers (##), use bullet points (* or -) for Requirements and Moodboard lists, use numbering (1., 2., 3.) for Visual Demo, use the bold format **Level Budget:** for budget tiers. For Fonts, use the exact format with **Font Combination:**, *Reason:*, *Sample Title:*, *Sample Body:*. For Colors, use the exact format 'Color Name (#XXXXXX) - Application: [description]', starting with 'Dominant'. Provide detailed, relevant content for each section. Use plausible USD ($) ranges for budget. Ensure Visual Demo and Moodboard list items are descriptive image prompts.`;

            const loadingMsgKey = "fetchingDetails";
            const loadingFallback = "Fetching More Details...";
             // !!! This call uses the INSECURE direct method. Replace with backend call in production. !!!
            const generatedText = await callGeminiAPI(prompt, loadingMsgKey, loadingFallback);

            if (generatedText) {
                 clearDetailedResultsContentOnly(); // Clear placeholders
                 parseAndDisplayResults(generatedText); // Populate detail cards
                 detailedResultsGrid.style.display = 'grid'; // Show the grid

                 // Animate cards in
                 const detailCards = detailedResultsGrid.querySelectorAll('.result-card');
                 detailCards.forEach((card, index) => {
                     const contentDiv = card.querySelector('.card-content');
                     const hasRealContent = contentDiv && !contentDiv.classList.contains('placeholder-notice') && contentDiv.innerHTML.trim() !== '' && !contentDiv.querySelector('.placeholder-notice');
                     if (card.style.display === 'flex' && hasRealContent) {
                         card.style.transitionDelay = `${index * 0.1}s`;
                         card.classList.add('visible');
                     } else if (card.style.display === 'flex') {
                         card.style.opacity = 1;
                         card.style.transform = 'translateY(0)';
                         card.classList.remove('visible');
                     }
                 });
                 // Scroll to new cards
                  setTimeout(() => {
                    const firstDetailCard = detailedResultsGrid.querySelector('.result-card[style*="display: flex"]');
                    (firstDetailCard || detailedResultsGrid).scrollIntoView({ behavior: 'smooth', block: 'start' });
                  }, 150);
                 if (regenerateButton) regenerateButton.disabled = false;
            } else {
                 if (exploreMoreButton) exploreMoreButton.disabled = false;
                 if (regenerateButton) regenerateButton.disabled = currentInputs ? false : true;
            }
        }

        // --- Re-Generate Concept ---
        function handleRegenerateConcept() {
            clearResultsAndErrors();
            handleGenerateConcept(); // Restart the process
        }

        // --- Parsing and Displaying Results ---
        // (Keep the existing parsing logic as is)
        function parseAndDisplayResults(text) {
            console.log("--- Parsing AI Response ---");
            const lines = text.split('\n');
            let currentSectionKey = null;
            let contentBuffer = '';
            let foundAnySection = false;
            const processedSections = new Set();
            let unrecognizedHeaders = []; // Keep track of headers we didn't recognize

            // Hide all detail cards initially (except concept if it's already shown)
            Object.values(cardElements).forEach(card => { if (card !== conceptCard) card.style.display = 'none'; });

            lines.forEach((line, lineIndex) => {
                const trimmedLine = line.trim();
                let matchedHeader = false;
                let matchedKey = null;

                if (trimmedLine.startsWith('##')) {
                    for (const title in sections) {
                        // FIX: Escape regex metacharacters *except* the forward slash /, then handle optional spaces around /
                        const escapedTitle = title.trim()
                                              .replace(/[-\^$*+?.()|[\]{}]/g, '\\$&') // Escape regex chars EXCEPT /
                                              .replace('/', '\\s*\\/\\s*'); // Allow optional spaces around literal /

                        const headerRegex = new RegExp(`^##\\s*\\*?\\*?${escapedTitle}\\*?\\*?\\s*$`, 'i');

                        if (headerRegex.test(trimmedLine)) {
                            matchedKey = title;
                            matchedHeader = true;
                            console.log(`>>> MATCHED Header: ${matchedKey} using Regex: ${headerRegex}`); // Log successful match
                            break;
                        }
                    }
                    if (!matchedHeader) {
                        console.warn(`Unrecognized header found on line ${lineIndex}: "${trimmedLine}"`);
                        unrecognizedHeaders.push(trimmedLine);
                    }
                }

                if (matchedHeader && matchedKey) {
                    if (currentSectionKey && contentBuffer.trim()) {
                        const targetElementId = sections[currentSectionKey];
                        const targetCard = cardElements[currentSectionKey];
                        if (targetElementId && targetCard) {
                            console.log(`Processing content for previous section: ${currentSectionKey}`);
                            try {
                                processSectionContent(targetElementId, currentSectionKey, contentBuffer.trim());
                                processedSections.add(currentSectionKey);
                                foundAnySection = true;
                            } catch (processError) {
                                handleProcessingError(targetElementId, targetCard, currentSectionKey, processError);
                                processedSections.add(currentSectionKey);
                            }
                        }
                    }
                    currentSectionKey = matchedKey; // Start new section
                    contentBuffer = ''; // Reset buffer
                } else if (currentSectionKey) {
                    // Only append if it's not an unrecognized header line
                    if (!unrecognizedHeaders.includes(trimmedLine)) {
                         contentBuffer += line + '\n';
                    }
                } else if (trimmedLine && !matchedHeader) {
                     console.warn(`Content found before first recognized header on line ${lineIndex}: "${trimmedLine}"`);
                }
            });

            // Process the very last section's buffer
            if (currentSectionKey && contentBuffer.trim()) {
                const targetElementId = sections[currentSectionKey];
                const targetCard = cardElements[currentSectionKey];
                if (targetElementId && targetCard) {
                     console.log(`Processing final content for: ${currentSectionKey}`);
                    try {
                        processSectionContent(targetElementId, currentSectionKey, contentBuffer.trim());
                        processedSections.add(currentSectionKey);
                        foundAnySection = true;
                    } catch (processError) {
                        handleProcessingError(targetElementId, targetCard, currentSectionKey, processError);
                        processedSections.add(currentSectionKey);
                    }
                }
            }

            // --- Post-Parsing Checks ---
            console.log("--- Finished Parsing Attempt ---");
            console.log("Found any section:", foundAnySection);
            console.log("Processed sections:", Array.from(processedSections));
            if (unrecognizedHeaders.length > 0) {
                console.warn("Unrecognized headers encountered:", unrecognizedHeaders);
            }

            const detailsRequested = detailedResultsGrid.style.display === 'grid' ||
                                   (exploreMoreButton && exploreMoreButton.disabled && !regenerateButton?.disabled);

            if (detailsRequested) {
                Object.keys(sections).forEach(sectionTitle => {
                    if (sectionTitle === 'Concept / Key Visual') return;
                    if (sectionTitle === 'Visual Demo (Key Image Descriptions)' && (processedSections.has('Visual Demo (Key Images)') || processedSections.has('Visual Demo (Key Image Descriptions)'))) return;
                    if (sectionTitle === 'Visual Demo (Key Images)' && (processedSections.has('Visual Demo (Key Images)') || processedSections.has('Visual Demo (Key Image Descriptions)'))) return;
                    if (!processedSections.has(sectionTitle)) {
                        const targetElementId = sections[sectionTitle]; const targetCard = cardElements[sectionTitle]; const contentDiv = document.getElementById(targetElementId);
                        if (targetCard && contentDiv) {
                            console.warn(`Section "${sectionTitle}" was NOT found or processed. Displaying placeholder.`);
                            setPlaceholderForMissingSection(contentDiv, sectionTitle);
                            targetCard.style.display = 'flex';
                        }
                    }
                });
            }

            if (!foundAnySection && text.trim()) {
                 const onlyConceptRequested = exploreMoreButton && !exploreMoreButton.disabled;
                 const conceptWasProcessed = processedSections.has('Concept / Key Visual');
                 if (!(onlyConceptRequested && conceptWasProcessed)) {
                    console.error("Parsing failed: No sections were successfully found and processed from the AI response.");
                    displayError(getTranslatedText(null, 'errorParsingFailed', false, "Could not parse expected sections. AI response format might be incorrect. Check console logs for details."), 'errorParsingFailed');
                    console.warn("--- Raw AI Response Text (Parsing Failed) ---:\n", text);
                 } else {
                    console.log("Concept processed successfully. Other sections not requested or not found.");
                 }
            } else if (foundAnySection) {
                 console.log("Parsing complete. At least one section processed.");
                 errorMessageDiv.style.display = 'none';
            } else {
                 console.log("No sections found and response text was empty.");
                 resultsOutputArea.style.display = 'none';
            }
        }


        // Helper for handling errors during section content processing
        function handleProcessingError(targetElementId, targetCard, sectionKey, error) {
             console.error(`Error processing content for section "${sectionKey}":`, error);
              const contentDiv = document.getElementById(targetElementId);
             if (contentDiv) {
                  contentDiv.innerHTML = `<p class="placeholder-notice error">${getTranslatedText(null, 'errorDisplayingSection', false, 'Error displaying this section.')}</p>`;
                  contentDiv.classList.add('placeholder-notice');
                  if (targetCard) targetCard.style.display = 'flex'; // Show the card even with error
             }
        }

        // --- Process Individual Section Content ---
        // (Keep the existing section processing logic as is)
        function processSectionContent(elementId, sectionTitle, content) {
            const contentDiv = document.getElementById(elementId);
            if (!contentDiv) { console.error(`Content div not found: ${elementId}`); return; }
             contentDiv.innerHTML = ''; contentDiv.classList.remove('placeholder-notice');
             const parentCard = contentDiv.closest('.result-card');
             if (!parentCard) { console.error(`Parent card not found for ${elementId}`); return; }
             let sectionHasContent = false;

            try {
                // Handle Visual Demo (Key Images)
                if (sectionTitle === 'Visual Demo (Key Image Descriptions)' || sectionTitle === 'Visual Demo (Key Images)') {
                     const container = document.createElement('div'); container.className = 'image-placeholder-container'; contentDiv.appendChild(container);
                     const descs = content.split(/^\s*[1-9][0-9]*[\.\)\-]\s+/gm).filter(Boolean).map(d => d.trim().replace(/\n$/, ''));
                     if (descs.length > 0) {
                        descs.slice(0, 3).forEach((d, i) => { if(d) { createImagePlaceholder(container, d, `v-${i}`); sectionHasContent = true; } });
                    }
                     if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noVisualsFound', false, 'No visuals found.')}</p>`; container.classList.add('placeholder-notice'); }
                     const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                     note.dataset.langEn = "Illustrative images based on descriptions."; note.dataset.placeholderKey="visualsNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);

                // Handle Moodboard Influences
                } else if (sectionTitle === 'Moodboard Influences') {
                     const descEl = document.createElement('p'); descEl.id = 'moodboard-description'; contentDiv.appendChild(descEl);
                     const imgContainer = document.createElement('div'); imgContainer.className = 'image-placeholder-container'; imgContainer.id = 'moodboard-images'; contentDiv.appendChild(imgContainer);
                     const lines = content.trim().split('\n'); let mainDesc = '', items = []; let readingDesc = true;
                     for (const line of lines) { const trimmed = line.trim(); if (trimmed.match(/^[\*\-]\s+/)) { readingDesc = false; items.push(trimmed.replace(/^[\*\-]\s+/, '').trim()); } else if (readingDesc && trimmed) { mainDesc += line + '\n'; } else if (!readingDesc && trimmed && items.length > 0) { items[items.length - 1] += '\n' + trimmed; } }
                     mainDesc = mainDesc.trim(); items = items.filter(Boolean);
                     if (mainDesc) { descEl.innerHTML = mainDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); descEl.style.display = 'block'; descEl.classList.remove('placeholder-notice'); sectionHasContent = true; }
                     else { descEl.innerHTML = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Desc...'); descEl.style.display = 'block'; descEl.classList.add('placeholder-notice'); descEl.dataset.placeholderKey="moodboardDescPlaceholder"; }
                     if (items.length > 0) { imgContainer.innerHTML = ''; imgContainer.classList.remove('placeholder-notice'); items.slice(0, 5).forEach((d, i) => { if(d) { createImagePlaceholder(imgContainer, d, `m-${i}`); sectionHasContent = true; } }); }
                     else { imgContainer.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'noMoodboardItemsFound', false, 'No items...')}</p>`; imgContainer.classList.add('placeholder-notice'); }

                     if (sectionHasContent) {
                         const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                         note.dataset.langEn = "Visual styles for inspiration."; note.dataset.placeholderKey="moodboardNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);
                     } else {
                        if (!mainDesc && items.length === 0) {
                            contentDiv.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardDescPlaceholder">${getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Description missing.')}</p><div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'Images missing.')}</p></div>`; contentDiv.classList.add('placeholder-notice');
                        } else {
                             const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                             note.dataset.langEn = "Visual styles for inspiration."; note.dataset.placeholderKey="moodboardNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);
                        }
                     }

                // Handle Estimated Budget
                } else if (sectionTitle === 'Estimated Budget') {
                     let container = contentDiv.querySelector('.budget-columns-container');
                     if (!container) { container = document.createElement('div'); container.className = 'budget-columns-container'; contentDiv.appendChild(container); }
                     else { container.innerHTML = ''; } container.classList.remove('placeholder-notice');

                     const budgetRegex = /\*\*(Low\s*Budget|Mid\s*Budget|High\s*Budget)\*\*\s*:?\s*([\s\S]*?)(?=\n?\s*\*\*(?:Low|Mid|High)\s*Budget\*\*|$)/gi;
                     const budgetLevels = {}; let match; let parsingSuccess = false;

                     while ((match = budgetRegex.exec(content)) !== null) {
                         parsingSuccess = true; const levelTitle = match[1].replace(/\s+/g, ' ').trim(); const levelKey = levelTitle.split(' ')[0];
                         let rawContent = match[2].trim(); let range = ''; let description = '';
                         const rangePatterns = [/[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*[-–—]\s*[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*USD|EUR|GBP)?/i, /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*\+(?:\s*USD|EUR|GBP)?/i, /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*USD|EUR|GBP)?/i ];
                         for (const pattern of rangePatterns) { const rangeMatch = rawContent.match(new RegExp(`^\\s*\\(?(${pattern.source})\\)?\\s*`, 'i')); if (rangeMatch) { range = rangeMatch[1].trim(); description = rawContent.substring(rangeMatch[0].length).trim(); break; } }
                         if (!range) { description = rawContent; } budgetLevels[levelKey] = { title: levelTitle, range: range, description: description };
                     }

                     const order = ["Low", "Mid", "High"]; let anyColumnHasContent = false;
                     order.forEach(levelKey => {
                         const colDiv = document.createElement('div'); colDiv.className = 'budget-column';
                         const titleH3 = document.createElement('h3'); const descP = document.createElement('p');
                         if (budgetLevels[levelKey]) {
                             const data = budgetLevels[levelKey]; titleH3.textContent = data.title + (data.range ? ` (${data.range})` : '');
                             let processedDesc = data.description; const itemCostRegex = /^\s*[-*]\s*(.+?)\s*[-–—:]\s*([\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*[-–—]\s*[\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b)?(?:\s*USD|\s*EUR|\s*GBP)?)\s*$/gm;
                             let itemBoxesHTML = ''; processedDesc = processedDesc.replace(itemCostRegex, (matchStr, item, cost) => { itemBoxesHTML += `<div class="budget-item-box">${item.trim()}: <strong>${cost.trim()}</strong></div>`; return ''; }).trim();
                             processedDesc = processedDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); descP.innerHTML = processedDesc + itemBoxesHTML;
                             if(descP.innerHTML.trim() === ''){ descP.innerHTML = `(${getTranslatedText(null, 'budgetDetailsMissing', false, 'Details missing')})`; descP.classList.add('placeholder-notice'); }
                             else { anyColumnHasContent = true; }
                         } else {
                             titleH3.textContent = getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`); descP.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`;
                             descP.classList.add('placeholder-notice'); colDiv.classList.add('placeholder-notice');
                         }
                         colDiv.appendChild(titleH3); colDiv.appendChild(descP); container.appendChild(colDiv);
                     });

                      if (!parsingSuccess && content.trim()) { container.innerHTML = `<pre>${content}</pre>`; container.classList.add('raw-budget-output'); container.classList.add('placeholder-notice'); console.warn("Budget parsing failed, displaying raw content."); }
                      else if (!anyColumnHasContent && !parsingSuccess) { container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noBudgetContentFound', false, 'No budget details provided.')}</p>`; container.classList.add('placeholder-notice'); }
                      else { sectionHasContent = true; }

                      let note = contentDiv.querySelector('small');
                      if (!note) { note = document.createElement('small'); note.dataset.langEn = "Note: Budgets are conceptual estimates..."; note.dataset.placeholderKey="budgetNotePlaceholder"; contentDiv.appendChild(note); }
                      note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn);

                // Handle Requirements for MV
                } else if (sectionTitle === 'Requirements for MV') {
                    const listEl = document.createElement('ul'); contentDiv.appendChild(listEl);
                    const items = content.trim().split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(item => item.trim().replace(/\n$/, ''));
                    if (items.length > 0) { items.forEach(item => { const li = document.createElement('li'); li.innerHTML = item.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); listEl.appendChild(li); }); sectionHasContent = true; }
                    else { listEl.innerHTML = `<li class="placeholder-notice" data-placeholder-key="requirementsPlaceholder">${getTranslatedText(null, 'noRequirementsFound', false, 'No requirements listed.')}.</li>`; listEl.classList.add('placeholder-notice'); }

                // Handle Typography/Font Suggestion
                } else if (sectionTitle === 'Typography/Font Suggestion') {
                    const suggestionDiv = document.createElement('div'); suggestionDiv.className = 'font-suggestion';
                    const combinationMatch = content.match(/\*\*Font Combination:\*\*\s*(.*?)(?:\s*&\s*(.*?))?\s*$/im);
                    const reasonMatch = content.match(/\*Reason:\*\s*([\s\S]*?)(?=\n\s*\*Sample|\n\s*$)/i);
                    const sampleTitleMatch = content.match(/\*Sample Title(?: \(Using Font 1\))?:\*\s*"(.*?)"/i);
                    const sampleBodyMatch = content.match(/\*Sample Body(?: \(Using Font 2\))?:\*\s*"(.*?)"/i);

                    if (combinationMatch && reasonMatch && sampleTitleMatch) {
                        sectionHasContent = true;
                        const font1 = combinationMatch[1]?.trim(); const font2 = combinationMatch[2]?.trim();
                        const reason = reasonMatch[1]?.trim(); const sampleTitle = sampleTitleMatch[1]?.trim(); const sampleBody = sampleBodyMatch?.[1]?.trim();
                        const comboH3 = document.createElement('h3'); comboH3.textContent = font1 + (font2 ? ` & ${font2}` : ''); suggestionDiv.appendChild(comboH3);
                        const reasonP = document.createElement('p'); reasonP.className = 'font-reason'; reasonP.innerHTML = reason.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); suggestionDiv.appendChild(reasonP);
                        const sampleTitleDiv = document.createElement('div'); sampleTitleDiv.className = 'font-sample'; sampleTitleDiv.style.fontFamily = `'${font1}', ${fontFamilyFallback(font1)}`; sampleTitleDiv.innerHTML = `<strong>${getTranslatedText(null, 'fontSampleTitleLabel', false, 'Title:')}</strong> "${sampleTitle}"`; suggestionDiv.appendChild(sampleTitleDiv);
                        if (font2 && sampleBody) { const sampleBodyDiv = document.createElement('div'); sampleBodyDiv.className = 'font-sample'; sampleBodyDiv.style.fontFamily = `'${font2}', ${fontFamilyFallback(font2)}`; sampleBodyDiv.innerHTML = `<strong>${getTranslatedText(null, 'fontSampleBodyLabel', false, 'Body:')}</strong> "${sampleBody}"`; suggestionDiv.appendChild(sampleBodyDiv); }
                        contentDiv.appendChild(suggestionDiv);
                    } else { console.warn("Font parsing failed:", { combinationMatch, reasonMatch, sampleTitleMatch }); }
                    if (!sectionHasContent) { contentDiv.innerHTML = `<p class="placeholder-notice" data-placeholder-key="fontsPlaceholder">${getTranslatedText(null, 'noFontsFound', false, 'Could not parse font suggestions.')}</p>`; contentDiv.classList.add('placeholder-notice'); }

                // Handle Color Palette
                } else if (sectionTitle === 'Color Palette') {
                     const container = document.createElement('div'); container.className = 'color-palette-display'; contentDiv.appendChild(container);
                     sectionHasContent = createColorSwatches(container, content.trim()); // Use updated function
                     if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice" data-placeholder-key="palettePlaceholder">${getTranslatedText(null, 'noColorsFound', false, 'Could not parse colors.')}</p>`; container.classList.add('placeholder-notice'); }

                // Handle Default (e.g., Concept)
                } else {
                     const pEl = document.createElement('p'); pEl.style.whiteSpace = 'pre-wrap';
                     const processedContent = content.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
                     pEl.innerHTML = processedContent; contentDiv.appendChild(pEl);
                     if (processedContent) sectionHasContent = true;
                }

                // Final check if section content is empty after processing
                 if (!sectionHasContent && contentDiv.innerHTML.trim() === '') {
                    console.warn(`Section "${sectionTitle}" processed but resulted in empty content.`);
                    contentDiv.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Content not available.')}</p>`;
                    contentDiv.classList.add('placeholder-notice');
                 }
                 parentCard.style.display = 'flex'; // Show card after processing

            } catch (error) {
                handleProcessingError(elementId, parentCard, sectionTitle, error);
            }
        }


        // --- Helper for Font Fallback CSS ---
        function fontFamilyFallback(fontName = '') {
            const lower = fontName.toLowerCase();
            if (lower.includes('serif') || lower.includes('playfair') || lower.includes('lora') || lower.includes('merriweather') || lower.includes('georgia') || lower.includes('times')) return 'serif';
            if (lower.includes('mono') || lower.includes('courier') || lower.includes('consolas') || lower.includes('inconsolata')) return 'monospace';
            if (lower.includes('script') || lower.includes('handwriting') || lower.includes('cursive') || lower.includes('dancing') || lower.includes('pacifico')) return 'cursive';
            if (lower.includes('display') || lower.includes('oswald') || lower.includes('impact') || lower.includes('anton')) return 'sans-serif'; // Often sans-serif works as fallback
            // Default fallback
            return 'sans-serif';
        }


         // --- Helper to set placeholders in cards for sections MISSING from AI response ---
         function setPlaceholderForMissingSection(contentDiv, sectionTitle) {
             if (!contentDiv) return;
             contentDiv.innerHTML = ''; contentDiv.classList.add('placeholder-notice');
             let placeholderKey = 'placeholderGeneric', fallbackText = 'Content missing.', placeholderHTML = '';

             switch (sectionTitle) {
                 case 'Requirements for MV':
                     placeholderKey = 'requirementsPlaceholder'; fallbackText = 'Requirements list...';
                     placeholderHTML = `<ul class="placeholder-notice"><li class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</li></ul>`;
                     break;
                 case 'Estimated Budget':
                     placeholderKey = 'budgetPlaceholder'; fallbackText = 'Budget details...';
                     const noteText = getTranslatedText(null, 'budgetNotePlaceholder', false, 'Note: Budgets are conceptual estimates...');
                     placeholderHTML = `<div class="budget-columns-container">`; ["Low", "Mid", "High"].forEach(levelKey => { placeholderHTML += `<div class="budget-column placeholder-notice"><h3>${getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`)}</h3><p class="placeholder-notice" data-placeholder-key="budgetDetailsMissing">(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})</p></div>`; }); placeholderHTML += `</div><small data-placeholder-key="budgetNotePlaceholder" style="display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;">${noteText}</small>`;
                     break;
                 case 'Visual Demo (Key Image Descriptions)': case 'Visual Demo (Key Images)':
                     placeholderKey = 'visualsPlaceholder'; fallbackText = 'Visual descriptions...'; const visualsNote = getTranslatedText(null, 'visualsNotePlaceholder', false,'Illustrative images...');
                     placeholderHTML = `<div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div><small data-placeholder-key="visualsNotePlaceholder">${visualsNote}</small>`;
                     break;
                 case 'Moodboard Influences':
                     const moodDesc = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Moodboard description...'); const moodImgs = getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'Moodboard images...'); const moodNote = getTranslatedText(null, 'moodboardNotePlaceholder', false,'Visual styles...');
                     placeholderHTML = `<p data-placeholder-key="moodboardDescPlaceholder" id="moodboard-description" class="placeholder-notice">${moodDesc}</p><div class="image-placeholder-container placeholder-notice" id="moodboard-images"><p data-placeholder-key="moodboardImgsPlaceholder">${moodImgs}</p></div><small data-placeholder-key="moodboardNotePlaceholder">${moodNote}</small>`;
                     break;
                 case 'Typography/Font Suggestion': // Added Font Placeholder
                     placeholderKey = 'fontsPlaceholder'; fallbackText = 'Font suggestions...';
                     placeholderHTML = `<p data-placeholder-key="${placeholderKey}" class="placeholder-notice">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
                     break;
                 case 'Color Palette':
                     placeholderKey = 'palettePlaceholder'; fallbackText = 'Color palette...';
                     placeholderHTML = `<div class="color-palette-display placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div>`;
                     break;
                 case 'Concept / Key Visual':
                      placeholderKey = 'conceptPlaceholder'; fallbackText = 'Concept will appear here...';
                      placeholderHTML = `<p data-placeholder-key="${placeholderKey}" class="placeholder-notice">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
                      break;
                 default:
                      placeholderHTML = `<p class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
             }
             contentDiv.innerHTML = placeholderHTML;
         }


        // --- Image Generation Function (Using Backend Proxy - Keep as is) ---
        async function createImagePlaceholder(container, description, seedSuffix) {
             const figure = document.createElement('figure'); figure.className = 'image-placeholder';
             const img = document.createElement('img'); img.alt = `Loading image for: ${description.substring(0,50)}...`; img.src = ''; img.loading = 'lazy';
             let phHeight = (container?.id === 'moodboard-images') ? 130 : 160;
             img.style.cssText = `height: ${phHeight}px; width: 100%; object-fit: cover; background-color: #444; border-bottom: 1px solid var(--border-color);`;
             const figcaption = document.createElement('figcaption');
             figcaption.innerHTML = description.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
             figure.appendChild(img); figure.appendChild(figcaption); container.appendChild(figure);

             const prompt = description.replace(/<[^>]*>/g, '').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
             if (!prompt) { setFallbackImage(img, figcaption, description, seedSuffix, 'empty-prompt', phHeight); return; }

             const BACKEND_API_URL = '/api/generate-image'; // Relative URL to your server endpoint

             try {
                 await new Promise(resolve => setTimeout(resolve, 50)); // Small delay

                 const response = await fetch(BACKEND_API_URL, {
                     method: 'POST', headers: { 'Content-Type': 'application/json' },
                     body: JSON.stringify({ description: prompt })
                 });
                 const responseData = await response.json();

                 if (!response.ok) {
                     const errorDetail = responseData?.error || `Backend Error: ${response.status}`;
                     console.error("Backend proxy error:", errorDetail);
                     displayError(`${getTranslatedText(null, 'errorBackendProxy', false, 'Image Gen Error:')} ${errorDetail}`, 'errorBackendProxy');
                     setFallbackImage(img, figcaption, description, seedSuffix, `backend-err-${response.status}`, phHeight);
                     return;
                 }

                 if (responseData.imageUrl && typeof responseData.imageUrl === 'string' && responseData.imageUrl.startsWith('http')) {
                     const imageUrl = responseData.imageUrl;
                     img.onload = () => { img.style.backgroundColor = 'transparent'; }
                     img.onerror = () => { console.error("Failed to load image from Backend/Replicate URL:", imageUrl); setFallbackImage(img, figcaption, description, seedSuffix, 'backend-img-load-err', phHeight); }
                     img.src = imageUrl; img.alt = prompt;
                 } else {
                     console.warn("Backend proxy did not return a valid image URL.", responseData);
                     setFallbackImage(img, figcaption, description, seedSuffix, 'backend-invalid-url', phHeight);
                 }

             } catch (error) {
                 console.error("Error fetching from Backend Proxy API:", error);
                 let reason = 'backend-fetch-error'; let userMessage = getTranslatedText(null, 'errorBackendFetch', false, 'Network error contacting our server for image generation.');
                 if (error instanceof TypeError) { reason = 'backend-network'; }
                 displayError(userMessage, reason);
                 setFallbackImage(img, figcaption, description, seedSuffix, reason, phHeight);
             }
        }


        function setFallbackImage(imgEl, figcaptionEl, desc, seed, reason, height) {
             console.warn(`Setting fallback image. Reason: ${reason}`);
             const seedEnc = encodeURIComponent(desc.substring(0, 15) + seed + '-' + reason);
             const picSumH = Math.max(150, Math.round(height * 1.5)); const picSumW = Math.round(picSumH * 1.6);
             imgEl.onload = () => { imgEl.style.backgroundColor = 'transparent'; }
             imgEl.onerror = () => { imgEl.style.backgroundColor = '#555'; imgEl.alt = `Fallback failed (Reason: ${reason})` }
             imgEl.src = `https://picsum.photos/seed/${seedEnc}/${picSumW}/${picSumH}.webp`; imgEl.alt = `Placeholder: ${desc.substring(0, 50)}... (Reason: ${reason})`;

             const existingSource = figcaptionEl.querySelector('.generation-source'); if(existingSource) existingSource.remove();
             const existingFallback = figcaptionEl.querySelector('.fallback-notice'); if(existingFallback) existingFallback.remove();

             const notice = document.createElement('span'); notice.className = 'fallback-notice';
             notice.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${reason})`;
             figcaptionEl.appendChild(notice);
        }

        // --- Color Swatch Creation ---
        // (Keep the existing color swatch logic as is)
         function createColorSwatches(container, text) {
            if (!container) return false;
            container.innerHTML = ''; // Clear previous swatches
            container.classList.remove('placeholder-notice');
            let foundColors = false; let swatchIndex = 0;
            const lines = text.trim().split('\n');

            lines.forEach(line => {
                const colorRegex = /^(Dominant\s+)?([\w\s\-\/()]+?)\s*\(?\s*(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})\s*\)?\s*-\s*Application:\s*(.*)$/i;
                const match = line.trim().match(colorRegex);

                if (match) {
                    const isDominant = !!match[1]; let name = match[2].trim(); let hex = match[3].trim().toUpperCase(); const application = match[4].trim();
                    if (!name || name.length < 2) return;
                    if (hex.length === 4) hex = '#' + hex[1].repeat(2) + hex[2].repeat(2) + hex[3].repeat(2);
                    if (!/^#[0-9A-F]{6}$/.test(hex)) { console.warn(`Invalid hex: ${match[3]}`); return; }

                    foundColors = true;
                    const swatch = document.createElement('div'); swatch.className = 'color-swatch'; if (isDominant) swatch.classList.add('dominant-swatch');
                    const colorBlock = document.createElement('div'); colorBlock.className = 'color-block';
                    try { colorBlock.style.backgroundColor = hex; colorBlock.style.color = isColorDarkGuess(hex) ? 'var(--text-primary)' : 'var(--bg-dark)'; } catch (e) { console.warn(`Invalid color ${hex}`); return; }
                    const hexSpan = document.createElement('span'); hexSpan.className = 'hex-code'; hexSpan.textContent = hex; colorBlock.appendChild(hexSpan);
                    const infoDiv = document.createElement('div'); infoDiv.className = 'color-info';
                    const nameSpan = document.createElement('span'); nameSpan.className = 'color-name'; nameSpan.textContent = name; infoDiv.appendChild(nameSpan);
                    const appP = document.createElement('p'); appP.className = 'color-application'; appP.innerHTML = application.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); infoDiv.appendChild(appP);
                    swatch.appendChild(colorBlock); swatch.appendChild(infoDiv); container.appendChild(swatch);
                    requestAnimationFrame(() => { setTimeout(() => { swatch.classList.add('visible'); }, 50 + swatchIndex * 70); });
                    swatchIndex++;
                } else if (line.trim()) { // Only warn if the line wasn't empty
                    console.warn("Could not parse color line:", line);
                }
            });
            return foundColors;
        }


        // --- Color Lightness Guess ---
        function isColorDarkGuess(hexColor) {
            try {
                if (!hexColor?.startsWith('#')) return false; let hex = hexColor.substring(1);
                if (hex.length === 3) hex = hex[0].repeat(2) + hex[1].repeat(2) + hex[2].repeat(2);
                if (hex.length !== 6) return false;
                const r = parseInt(hex.substring(0, 2), 16), g = parseInt(hex.substring(2, 4), 16), b = parseInt(hex.substring(4, 6), 16);
                return (0.299 * r + 0.587 * g + 0.114 * b) / 255 < 0.5;
            } catch (e) { return false; }
        }

        // --- Utility Functions ---
        function clearResultsContent() {
             const contentAreas = resultsOutputArea.querySelectorAll('.card-content');
             if (!contentAreas.length) return;
             contentAreas.forEach(area => {
                 const sectionId = area.id;
                 const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId);
                 if (sectionTitle) { setPlaceholderForMissingSection(area, sectionTitle); }
                 else { area.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Cleared.')}</p>`; area.classList.add('placeholder-notice'); }
             });
             resultsOutputArea.querySelectorAll('.result-card.visible, .color-swatch.visible').forEach(el => el.classList.remove('visible'));
         }
         function clearDetailedResultsContentOnly() {
             if (!detailedResultsGrid) return;
             detailedResultsGrid.querySelectorAll('.result-card').forEach(card => {
                 const contentArea = card.querySelector('.card-content'); if (!contentArea) return;
                 const sectionId = contentArea.id;
                 const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId);
                  if (sectionTitle) { setPlaceholderForMissingSection(contentArea, sectionTitle); }
                  else { contentArea.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Cleared.')}</p>`; contentArea.classList.add('placeholder-notice'); }
                  card.style.display = 'none'; card.classList.remove('visible');
             });
         }
        function clearResultsAndErrors() {
             resultsOutputArea.style.display = 'none'; conceptCard.style.display = 'none';
             conceptCard.classList.remove('visible'); detailedResultsGrid.style.display = 'none';
             errorMessageDiv.style.display = 'none'; errorMessageDiv.textContent = '';
             errorMessageDiv.removeAttribute('data-error-key');
             clearResultsContent();
             if(exploreMoreButton) exploreMoreButton.disabled = true;
             if(regenerateButton) regenerateButton.disabled = true;
             console.log("Cleared results area and errors.");
        }
        function displayError(message, errorKey = 'errorUnknown') {
             message = String(message || getTranslatedText(null, errorKey, false, 'Unknown error.'));
             errorMessageDiv.textContent = message; errorMessageDiv.dataset.errorKey = errorKey;
             errorMessageDiv.style.display = 'block'; hideLoading();
             console.error("Displayed user error:", message, `(Key: ${errorKey})`);
             // Avoid scrolling for less critical errors like fallbacks or parsing issues
             if (!errorKey.includes('fallback') && !errorKey.includes('parse') && !errorKey.includes('repl-') && !errorKey.includes('backend-')) {
                 errorMessageDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
             }
        }

        // --- Language Switching ---
        function formatDatasetKey(langCode, suffix = '') {
             let keyBase = (langCode === 'zh-CN') ? 'zhcn' : langCode.toLowerCase().split('-')[0];
             const capitalizedBase = keyBase.charAt(0).toUpperCase() + keyBase.slice(1);
             let key = 'lang' + capitalizedBase;
             if (suffix) { let camelSuffix = suffix.replace(/[-_](.)/g, (_, c) => c.toUpperCase()); camelSuffix = camelSuffix.charAt(0).toUpperCase() + camelSuffix.slice(1); key += camelSuffix; }
             return key.charAt(0).toLowerCase() + key.slice(1);
         }
         function getTranslatedText(element, suffixOrKey = '', isPlaceholderAttr = false, fallbackText = '') {
            const translations = { // Predefined translations (Add more as needed)
                // Font section
                fontSampleTitleLabel: { en: "Title:", es: "Título:", vi: "Tiêu đề:", ja: "タイトル：", zhcn: "标题：" },
                fontSampleBodyLabel: { en: "Body:", es: "Cuerpo:", vi: "Nội dung:", ja: "本文：", zhcn: "正文：" },
                fontsPlaceholder: { en: "Font suggestions will appear here...", es: "Las sugerencias de fuentes aparecerán aquí...", vi: "Gợi ý phông chữ sẽ xuất hiện ở đây...", ja: "フォントの提案がここに表示されます...", zhcn: "字体建议将显示在此处..." },
                noFontsFound: { en: "Could not parse font suggestions.", es: "No se pudieron analizar las sugerencias de fuentes.", vi: "Không thể phân tích gợi ý phông chữ.", ja: "フォントの提案を解析できませんでした。", zhcn: "无法解析字体建议。" },
                // Parsing Error
                errorParsingFailed: { en: "Could not parse expected sections. AI response format might be incorrect. Check console logs for details.", es: "No se pudieron analizar las secciones esperadas. El formato de respuesta de IA podría ser incorrecto. Revisa los registros de la consola para más detalles.", vi: "Không thể phân tích các phần dự kiến. Định dạng phản hồi AI có thể không chính xác. Kiểm tra nhật ký bảng điều khiển để biết chi tiết.", ja: "期待されるセクションを解析できませんでした。AI応答形式が正しくない可能性があります。詳細についてはコンソールログを確認してください。", zhcn: "无法解析预期的部分。AI 响应格式可能不正确。请检查控制台日志了解详情。" },
                // Image Generation
                generatedViaBackend: { en: "Gen. via Server", es: "Gen. vía Servidor", vi: "Tạo bởi Máy chủ", ja: "サーバー経由で生成", zhcn: "通过服务器生成" },
                placeholderReason: { en: "Placeholder", es: "Marcador", vi: "Giữ chỗ", ja: "プレースホルダ", zhcn: "占位符" },
                errorBackendProxy: { en: "Image Gen Error:", es: "Error Gen Imagen:", vi: "Lỗi Tạo ảnh:", ja: "画像生成エラー：", zhcn: "图像生成错误：" },
                errorBackendFetch: { en: "Network error contacting our server for image generation.", es: "Error de red contactando nuestro servidor para generar imagen.", vi: "Lỗi mạng khi liên hệ máy chủ để tạo ảnh.", ja: "画像生成のためサーバーに接続中にネットワークエラー。", zhcn: "联系我们的图像生成服务器时网络错误。" },
                errorCorsOrNetwork: { en: "Network/CORS error calling API. Check console/proxy.", es: "Error Red/CORS llamando API. Revisa consola/proxy.", vi: "Lỗi Mạng/CORS khi gọi API. Kiểm tra console/proxy.", ja: "API呼び出し中のネットワーク/CORSエラー。コンソール/プロキシ確認。", zhcn: "调用 API 时网络/CORS错误。检查控制台/代理。" },
                // Validation
                validationLyricsMissing: { en: "Please provide or generate lyrics.", es: "Por favor, proporciona o genera la letra.", vi: "Vui lòng cung cấp hoặc tạo lời bài hát.", ja: "歌詞を提供または生成してください。", zhcn: "请提供或生成歌词。" },
                validationKeywordsMissing: { en: "Please provide keywords or a theme.", es: "Por favor, proporciona palabras clave o un tema.", vi: "Vui lòng cung cấp từ khóa hoặc chủ đề.", ja: "キーワードまたはテーマを提供してください。", zhcn: "请提供关键词或主题。" },
                validationGenreMissing: { en: "Please select a music genre.", es: "Por favor, selecciona un género musical.", vi: "Vui lòng chọn thể loại nhạc.", ja: "音楽ジャンルを選択してください。", zhcn: "请选择音乐流派。" },
                // Other errors and statuses... (add existing ones here or keep using data attributes)
                 errorApiKeyInvalid: { en: "API Key is missing or invalid. Configure it securely (backend recommended).", es: "La clave API falta o es inválida. Configúrala de forma segura (se recomienda backend).", vi: "Khóa API bị thiếu hoặc không hợp lệ. Cấu hình an toàn (khuyến nghị backend).", ja: "APIキーが見つからないか無効です。安全に設定してください（バックエンド推奨）。", zhcn: "API 密钥丢失或无效。请安全地配置它（推荐使用后端）。" },
                 errorApiHttp: { en: "API request failed: ${errorDetail}", es: "Falló la solicitud API: ${errorDetail}", vi: "Yêu cầu API thất bại: ${errorDetail}", ja: "APIリクエスト失敗：${errorDetail}", zhcn: "API 请求失败：${errorDetail}" },
                 errorApiBlocked: { en: "Content blocked by safety filters (Reason: ${reason}). Revise input.", es: "Contenido bloqueado por filtros de seguridad (Razón: ${reason}). Revisa entrada.", vi: "Nội dung bị chặn bởi bộ lọc an toàn (Lý do: ${reason}). Sửa lại đầu vào.", ja: "安全フィルターによりコンテンツがブロックされました（理由：${reason}）。入力を修正してください。", zhcn: "内容被安全过滤器阻止（原因：${reason}）。请修改输入。" },
                 errorApiGeneral: { en: "API error: ${errorMessage}", es: "Error API: ${errorMessage}", vi: "Lỗi API: ${errorMessage}", ja: "APIエラー：${errorMessage}", zhcn: "API 错误：${errorMessage}" },
                 errorApiNoCandidate: { en: "No response candidate from API.", es: "Sin candidato de respuesta de la API.", vi: "Không có phản hồi từ API.", ja: "APIからの応答候補なし。", zhcn: "API 没有响应候选项。" },
                 errorApiEmptyResponse: { en: "Unexpected or empty text response from AI.", es: "Respuesta de texto inesperada o vacía de la IA.", vi: "Phản hồi văn bản không mong đợi hoặc trống từ AI.", ja: "AIからの予期しない、または空のテキスト応答。", zhcn: "来自 AI 的意外或空文本响应。" },
                 statusRequestingMic: { en: "Requesting mic access...", es: "Solicitando acceso al micro...", vi: "Đang yêu cầu quyền truy cập mic...", ja: "マイクへのアクセスを要求中...", zhcn: "正在请求麦克风访问权限..." },
                 statusRecording: { en: "Recording...", es: "Grabando...", vi: "Đang ghi âm...", ja: "録音中...", zhcn: "录音中..." },
                 statusTranscribing: { en: "Transcribing...", es: "Transcribiendo...", vi: "Đang chuyển ghi...", ja: "文字起こし中...", zhcn: "转录中..." },
                 statusStopping: { en: "Stopping...", es: "Deteniendo...", vi: "Đang dừng...", ja: "停止中...", zhcn: "停止中..." },
                 stoppedStatus: { en: "Stopped.", es: "Detenido.", vi: "Đã dừng.", ja: "停止しました。", zhcn: "已停止。" },
                 recordTranscriptComplete: { en: "Recording & transcript complete.", es: "Grabación y transcripción completas.", vi: "Ghi âm & bản ghi hoàn tất.", ja: "録音と文字起こし完了。", zhcn: "录音和转录完成。" },
                 recordCompleteNoTranscript: { en: "Recording complete (no transcript).", es: "Grabación completa (sin transcripción).", vi: "Ghi âm hoàn tất (không có bản ghi).", ja: "録音完了（文字起こしなし）。", zhcn: "录音完成（无转录稿）。" },
                 transcriptCompleteNoRecord: { en: "Transcript complete (no recording).", es: "Transcripción completa (sin grabación).", vi: "Bản ghi hoàn tất (không ghi âm).", ja: "文字起こし完了（録音なし）。", zhcn: "转录完成（无录音）。" },
                 statusFileSelected: { en: "File selected.", es: "Archivo seleccionado.", vi: "Đã chọn tệp.", ja: "ファイル選択済み。", zhcn: "文件已选择。" },
                 statusAudioNotSupported: { en: "Audio recording not supported.", es: "Grabación de audio no soportada.", vi: "Không hỗ trợ ghi âm.", ja: "音声録音はサポートされていません。", zhcn: "不支持录音。" },
                 statusSpeechRecNotSupported: { en: "Speech recognition not supported.", es: "Reconocimiento de voz no soportado.", vi: "Không hỗ trợ nhận dạng giọng nói.", ja: "音声認識はサポートされていません。", zhcn: "不支持语音识别。" },
                 micErrorGeneric: { en: "Microphone access error.", es: "Error de acceso al micrófono.", vi: "Lỗi truy cập micrô.", ja: "マイクアクセスエラー。", zhcn: "麦克风访问错误。" },
                 micErrorPermission: { en: "Microphone permission denied.", es: "Permiso de micrófono denegado.", vi: "Quyền truy cập micrô bị từ chối.", ja: "マイクの許可が拒否されました。", zhcn: "麦克风权限被拒绝。" },
                 micErrorNotFound: { en: "No microphone found.", es: "No se encontró micrófono.", vi: "Không tìm thấy micrô.", ja: "マイクが見つかりません。", zhcn: "未找到麦克风。" },
                 micErrorHardware: { en: "Microphone hardware error.", es: "Error de hardware del micrófono.", vi: "Lỗi phần cứng micrô.", ja: "マイクのハードウェアエラー。", zhcn: "麦克风硬件错误。" },
                 statusRecordingError: { en: "Recording error: ${errorName}", es: "Error de grabación: ${errorName}", vi: "Lỗi ghi âm: ${errorName}", ja: "録音エラー：${errorName}", zhcn: "录音错误：${errorName}" },
                 transcriptionErrorGeneric: { en: "Transcription error: ${errorParam}", es: "Error de transcripción: ${errorParam}", vi: "Lỗi chuyển ghi: ${errorParam}", ja: "文字起こしエラー：${errorParam}", zhcn: "转录错误：${errorParam}" },
                 transcriptionErrorNoSpeech: { en: "No speech detected for transcription.", es: "No se detectó habla para transcribir.", vi: "Không phát hiện giọng nói để chuyển ghi.", ja: "文字起こしのために音声が検出されませんでした。", zhcn: "未检测到用于转录的语音。" },
                 transcriptionErrorMicProblem: { en: "Transcription failed (mic issue?).", es: "Falló la transcripción (¿problema de micro?).", vi: "Chuyển ghi thất bại (lỗi mic?).", ja: "文字起こし失敗（マイクの問題？）。", zhcn: "转录失败（麦克风问题？）。" },
                 transcriptionErrorPermission: { en: "Transcription needs mic permission.", es: "La transcripción necesita permiso de micro.", vi: "Chuyển ghi cần quyền truy cập mic.", ja: "文字起こしにはマイクの許可が必要です。", zhcn: "转录需要麦克风权限。" },
                 transcriptionErrorNetwork: { en: "Transcription network error.", es: "Error de red en transcripción.", vi: "Lỗi mạng khi chuyển ghi.", ja: "文字起こしネットワークエラー。", zhcn: "转录网络错误。" },
                 // ... other keys ...
            };

            // Prioritize translation object if key exists
            if (translations[suffixOrKey]) {
                return translations[suffixOrKey][currentLang] || translations[suffixOrKey]['en'] || fallbackText;
            }

            // Fallback to dataset attributes if translation object doesn't have the key
            let specificKey = '';
            if(suffixOrKey && element && element.dataset[`${formatDatasetKey(currentLang)}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`]){ specificKey = `${formatDatasetKey(currentLang)}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`; }
            else if(suffixOrKey && element && element.dataset[`${formatDatasetKey('en')}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`]) { specificKey = `${formatDatasetKey('en')}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`; }
            else if (suffixOrKey) { specificKey = element?.dataset[formatDatasetKey(currentLang, suffixOrKey)] ? formatDatasetKey(currentLang, suffixOrKey) : formatDatasetKey('en', suffixOrKey); }

            let generalKey = formatDatasetKey(currentLang); let englishKey = formatDatasetKey('en');
            let translation = element?.dataset[specificKey] || element?.dataset[generalKey] || element?.dataset[englishKey] || fallbackText;

            // Last resort: use existing text content or placeholder attribute
            if ((translation === fallbackText || translation === undefined || translation === '') && element) {
                if (isPlaceholderAttr && element.hasAttribute('placeholder')) { translation = element.getAttribute('placeholder'); }
                else if (!isPlaceholderAttr && ['BUTTON', 'P', 'SMALL', 'LABEL', 'H1', 'H2', 'H3', 'LI', 'A', 'OPTION', 'TITLE', 'SPAN'].includes(element.tagName) && !element.children.length) { translation = element.textContent; }
            }
            return String(translation ?? fallbackText).trim();
         }

        function updateLanguage(langCode) {
            currentLang = langCode; console.log(`Switching language to: ${langCode}`);
            document.documentElement.lang = langCode;
            // Query all elements again in case modal content was added dynamically (though it's static here)
            const currentTranslatableElements = document.querySelectorAll('[data-lang-en], [data-lang-en-placeholder]');

            currentTranslatableElements.forEach(el => {
                const isPlaceholderTarget = (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') && el.hasAttribute('data-lang-en-placeholder');
                let primarySuffix = isPlaceholderTarget ? 'placeholder' : '';
                const fallbackKey = formatDatasetKey('en', primarySuffix);
                const fallbackValue = el.dataset[fallbackKey] || (isPlaceholderTarget ? el.getAttribute('placeholder') : el.textContent) || '';
                let translation = getTranslatedText(el, primarySuffix, isPlaceholderTarget, fallbackValue);

                if (isPlaceholderTarget) { el.placeholder = translation; }
                else if (el.tagName === 'TITLE') { document.title = translation; }
                else {
                     const simpleTags = ['BUTTON', 'P', 'SMALL', 'LABEL', 'H1', 'H2', 'H3', 'H4', 'LI', 'A', 'OPTION', 'SPAN']; // Added H4
                     if (simpleTags.includes(el.tagName)) {
                         // Basic check: Only replace if it's likely just text or other simple translatable spans
                         let canReplace = Array.from(el.childNodes).every(node =>
                             node.nodeType === Node.TEXT_NODE ||
                             (node.nodeType === Node.ELEMENT_NODE && ['SPAN', 'STRONG', 'EM', 'B', 'I'].includes(node.tagName)) || // Allow simple formatting
                             (node.nodeType === Node.COMMENT_NODE)
                         );

                         // Don't overwrite specific dynamic elements or complex card content this way
                         if(canReplace && !el.closest('.card-content') && el.id !== 'record-status-text' && el.id !== 'error-message') {
                            // Preserve simple inner HTML like <strong> if present
                             if (el.children.length === 1 && ['STRONG', 'EM', 'B', 'I'].includes(el.children[0].tagName)) {
                                 const tag = el.children[0].tagName.toLowerCase();
                                 el.innerHTML = `<${tag}>${translation}</${tag}>`; // Wrap translation in existing tag
                             } else if (el.children.length === 0){
                                el.textContent = translation; // Simple text replacement
                             } else {
                                 // More complex case, try to replace text nodes around known tags
                                 // Or just rely on data-lang-* attributes being specific enough for complex elements
                                 // For now, only replace if it's purely text or simple wrapper
                                if (Array.from(el.childNodes).every(node => node.nodeType === Node.TEXT_NODE)) {
                                    el.textContent = translation;
                                }
                             }
                         }
                     }
                }
            });

             // Update dynamic elements specifically
             if(recordAudioButton) updateRecordingUI(isRecording);
             if(recordStatus?.dataset?.statusKey) { let statusKey = recordStatus.dataset.statusKey, fallback = recordStatus.dataset.statusFallback || ''; let statusClass = Array.from(recordStatus.classList).find(c => ['complete', 'error', 'recording', 'transcribing'].includes(c)) || ''; let isPersistent = statusClass === 'complete' || statusClass === 'error'; updateRecordStatus(getTranslatedText(null, statusKey, false, fallback), statusClass, isPersistent, statusKey); }
             else if (!isRecording) { clearRecordStatus(); }
             if (loadingOverlay.classList.contains('show')) { const loadingP = loadingOverlay.querySelector('p'); if(loadingP && loadingP.dataset.lastKey) { loadingP.textContent = getTranslatedText(loadingP, loadingP.dataset.lastKey, false, 'Loading...'); } }
             if (errorMessageDiv.style.display === 'block' && errorMessageDiv.dataset.errorKey) { errorMessageDiv.textContent = getTranslatedText(null, errorMessageDiv.dataset.errorKey, false, errorMessageDiv.textContent); const backendErrorMatch = errorMessageDiv.textContent.match(/:\s*(.*)$/); if(errorMessageDiv.dataset.errorKey === 'errorBackendProxy' && backendErrorMatch && backendErrorMatch[1]) { errorMessageDiv.textContent += `: ${backendErrorMatch[1]}`; } }
             if (isSpeechRecognitionSupported) { const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' }; const newRecLang = bcp47Map[langCode] || (langCode.includes('-') ? langCode : `${langCode}-${langCode.toUpperCase()}`); if (recognition && recognition.lang !== newRecLang) { if (isRecording) { console.log("Stopping recording to change speech language..."); handleRecordButtonClick(); } if(recognition) recognition.lang = newRecLang; console.log("Updated speech recognition language:", newRecLang); } }

             // Re-apply placeholders and notes in results using current language
             if (resultsOutputArea.style.display === 'block') {
                 resultsOutputArea.querySelectorAll('.card-content.placeholder-notice').forEach(area => { const sectionId = area.id; const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId); if(sectionTitle) setPlaceholderForMissingSection(area, sectionTitle); });
                 resultsOutputArea.querySelectorAll('[data-placeholder-key]').forEach(ph => { const isTruePlaceholder = ph.classList.contains('placeholder-notice') || ph.closest('.placeholder-notice'); if (isTruePlaceholder) { ph.textContent = getTranslatedText(null, ph.dataset.placeholderKey, false, ph.textContent); } if(ph.tagName === 'SMALL' && ph.dataset.placeholderKey && ph.dataset.placeholderKey.endsWith('NotePlaceholder')) { ph.textContent = getTranslatedText(null, ph.dataset.placeholderKey, false, ph.textContent); } });
                 const budgetCard = document.getElementById('result-budget-card'); if (budgetCard && budgetCard.style.display === 'flex') { budgetCard.querySelectorAll('.budget-column.placeholder-notice h3').forEach(h3 => { const levelMatch = h3.textContent.match(/^(Low|Mid|High)/i); if (levelMatch) { const levelKey = levelMatch[1]; h3.textContent = getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`); } }); budgetCard.querySelectorAll('.budget-column.placeholder-notice p[data-placeholder-key="budgetDetailsMissing"]').forEach(p => { p.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`; }); }
                 resultsOutputArea.querySelectorAll('.image-placeholder figcaption .generation-source').forEach(span => { span.textContent = getTranslatedText(null, 'generatedViaBackend', false, 'Gen. via Server'); });
                 resultsOutputArea.querySelectorAll('.image-placeholder figcaption .fallback-notice').forEach(span => { const reasonMatch = span.textContent.match(/\(([^:]+):\s*(.*)\)/); if (reasonMatch) { const reasonText = reasonMatch[2] || 'unknown'; span.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${reasonText})`; } });
                 resultsOutputArea.querySelectorAll('#result-fonts .font-sample strong').forEach(strong => { if (strong.nextSibling?.textContent.includes('"')) { const labelKey = strong.textContent.toLowerCase().startsWith('title') ? 'fontSampleTitleLabel' : 'fontSampleBodyLabel'; strong.textContent = getTranslatedText(null, labelKey, false, strong.textContent); } });
             }
             console.log("Language update complete:", langCode);
        }
        function saveLanguagePreference(langCode) { try { localStorage.setItem('mvGeneratorLang', langCode); } catch (e) { console.warn("Could not save language preference:", e)} }
        function loadLanguagePreference() {
            try { const saved = localStorage.getItem('mvGeneratorLang'); if (saved && Array.from(languageSelect.options).some(o => o.value === saved)) { languageSelect.value = saved; return saved; } } catch (e) {}
            return languageSelect ? languageSelect.value : 'en';
        }

         // --- NEW: Guide Modal Logic ---
         function showGuideModal() {
             if (guideModal) {
                updateLanguage(currentLang); // Ensure modal content is translated before showing
                guideModal.classList.add('show');
             }
         }
         function hideGuideModal() {
             if (guideModal) {
                guideModal.classList.remove('show');
             }
         }


        // --- Event Listeners Setup ---
        navLinks.forEach(link => { link.addEventListener('click', (e) => { const page = link.getAttribute('data-page'); if (page) { e.preventDefault(); showPage(page); } }); });
        if (exploreButton) { exploreButton.addEventListener('click', () => showPage('feature')); }
        backButtons.forEach(button => { button.addEventListener('click', (e) => { e.preventDefault(); showPage('home'); }); });
        if (generateConceptButton) { generateConceptButton.addEventListener('click', handleGenerateConcept); }
        if (generateLyricsButton) { generateLyricsButton.addEventListener('click', generateRandomLyrics); } // <-- NEW
        if (exploreMoreButton) { exploreMoreButton.addEventListener('click', handleExploreMore); }
        if (regenerateButton) { regenerateButton.addEventListener('click', handleRegenerateConcept); }
        if (languageSelect) { languageSelect.addEventListener('change', (e) => { updateLanguage(e.target.value); saveLanguagePreference(e.target.value); }); }
        // NEW: Guide Modal Listeners
        if (howToUseButton) { howToUseButton.addEventListener('click', showGuideModal); }
        if (closeGuideModal) { closeGuideModal.addEventListener('click', hideGuideModal); }
        if (guideModal) { guideModal.addEventListener('click', (e) => { if (e.target === guideModal) { hideGuideModal(); } }); } // Close on overlay click

        // --- Initial Setup ---
        const initialLang = loadLanguagePreference(); updateLanguage(initialLang);
        showPage('home'); clearResultsAndErrors();
        console.log("MV Generator Initialized. Lang:", currentLang, "Speech Support:", isSpeechRecognitionSupported);
        if(recordAudioButton && recordAudioButton.disabled && (!navigator.mediaDevices?.getUserMedia || !isSpeechRecognitionSupported)) { const errorKey = !navigator.mediaDevices?.getUserMedia ? 'statusAudioNotSupported' : 'statusSpeechRecNotSupported'; const errorMsg = getTranslatedText(null, errorKey, false, 'Audio/Speech input not supported.'); updateRecordStatus(errorMsg, 'error', true, errorKey); }

    }); // End DOMContentLoaded
    </script>
    <!-- ========= END JAVASCRIPT ========= -->

</body>
</html>
