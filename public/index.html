<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be updated by JS -->
    <title
        data-lang-en="MV Concept Generator"
        data-lang-es="Generador de Conceptos MV"
        data-lang-vi="Trình tạo ý tưởng MV"
        data-lang-ja="MVコンセプトジェネレーター"
        data-lang-zhcn="MV概念生成器"
    >MV Concept Generator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- NEW DESIGN SYSTEM --- */

        /* CSS Variables for Theme */
        :root {
            --bg-dark: #1a1a1d; /* Very dark grey, almost black */
            --bg-card: #2c2c30; /* Slightly lighter card background */
            --bg-card-hover: #35353a;
            --text-primary: #f0f0f5; /* Off-white */
            --text-secondary: #a9a9b3; /* Lighter grey */
            --accent-primary: #6a8ee7; /* Soft blue */
            --accent-secondary: #e476e4; /* Soft magenta/purple */
            --accent-gradient: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            --border-color: #404045;
            --success-color: #57cc99;
            --warning-color: #ffb703;
            --error-color: #e63946;
            --font-family: 'Poppins', sans-serif;
            --nav-height: 70px;
            --border-radius-sm: 6px;
            --border-radius-md: 10px;
            --box-shadow-soft: 0 4px 15px rgba(0, 0, 0, 0.2);
            --box-shadow-glow: 0 0 15px rgba(106, 142, 231, 0.3); /* Glow for accent elements */
        }

        /* Basic Reset & Defaults */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family);
            line-height: 1.7;
            color: var(--text-primary);
            background-color: var(--bg-dark);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease;
        }
        main {
            flex-grow: 1;
            padding-top: calc(var(--nav-height) + 2rem);
            padding-bottom: 4rem;
            width: 100%;
        }

        /* --- LOADING OVERLAY --- */
        #loading-overlay {
            position: fixed; inset: 0;
            background-color: rgba(26, 26, 29, 0.85);
            backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center;
            z-index: 9999; flex-direction: column;
            opacity: 0; transition: opacity 0.4s ease-in-out;
        }
        #loading-overlay.show { display: flex; opacity: 1; }
        #loading-overlay p {
            font-weight: 500; color: var(--text-primary);
            margin-bottom: 20px; font-size: 1.2em;
            text-align: center; max-width: 80%;
        }
        .loading-spinner {
            width: 55px; height: 55px; border-radius: 50%;
            display: inline-block; position: relative; border: 4px solid;
            border-color: var(--accent-primary) var(--accent-primary) transparent transparent;
            animation: spin 1.2s linear infinite;
        }
        .loading-spinner::before, .loading-spinner::after {
            content: ''; position: absolute; left: 0; right: 0; bottom: 0; top: 0;
            border-radius: 50%; border: 4px solid transparent;
        }
        .loading-spinner::before { border-top-color: var(--accent-secondary); animation: spin 1.5s linear infinite; }
        .loading-spinner::after { border-left-color: rgba(240, 240, 245, 0.5); animation: spin 0.7s linear infinite; animation-direction: reverse; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Navigation --- */
        .main-nav {
            background-color: rgba(44, 44, 48, 0.8); backdrop-filter: blur(10px);
            color: var(--text-primary); position: fixed; top: 0; left: 0; width: 100%;
            z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex;
            justify-content: space-between; align-items: center; padding: 0 2rem; height: var(--nav-height);
        }
        .logo {
            font-weight: 600; font-size: 1.4rem; color: var(--text-primary); text-decoration: none;
            user-select: none; display: flex; align-items: center; gap: 0.5rem;
        }
        .logo img { max-height: 40px; width: auto; object-fit: contain; vertical-align: middle; }
        .main-nav ul { list-style: none; display: flex; align-items: center; gap: 1.5rem; }
        .main-nav ul li a {
            color: var(--text-secondary); text-decoration: none; padding: 0.5rem 0.8rem;
            font-size: 1rem; font-weight: 500; border-radius: var(--border-radius-sm);
            transition: color 0.3s ease, background-color 0.3s ease; position: relative; overflow: hidden; cursor: pointer;
        }
        .main-nav ul li a::after {
            content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px;
            background: var(--accent-gradient); transform: scaleX(0); transform-origin: right;
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .main-nav ul li a:hover, .main-nav ul li a.active { color: var(--text-primary); background-color: rgba(255, 255, 255, 0.05); }
        .main-nav ul li a.active::after { transform: scaleX(1); transform-origin: left; }

        /* --- Settings Box (Language) --- */
        #settings-box { display: flex; align-items: center; gap: 0.6rem; }
        #settings-box label { font-size: 0.9rem; color: var(--text-secondary); }
        #settings-box select {
            padding: 0.4rem 0.6rem; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color);
            background-color: var(--bg-card); color: var(--text-primary); font-size: 0.9rem; cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #settings-box select:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 2px rgba(106, 142, 231, 0.3); }

        /* --- General Content & Pages --- */
        .container { max-width: 1100px; margin: 0 auto; padding: 0 1.5rem; }
        .page { display: none; animation: sectionFadeIn 0.8s ease-out forwards; min-height: calc(100vh - var(--nav-height) - 6rem); }
        .page.active { display: block; }
        @keyframes sectionFadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Home Page --- */
        #home-page { text-align: center; padding-top: 3rem; }
        .hero-section {
            padding: 4rem 1rem; border-radius: var(--border-radius-md); background: rgba(44, 44, 48, 0.5);
            margin-bottom: 3rem; position: relative; overflow: hidden;
        }
        .hero-section::before {
            content: ''; position: absolute; inset: 0; z-index: 0; opacity: 0.7;
            background: radial-gradient(circle at top left, rgba(106, 142, 231, 0.1), transparent 60%),
                        radial-gradient(circle at bottom right, rgba(228, 118, 228, 0.1), transparent 60%);
            animation: pulseGlow 10s infinite alternate ease-in-out;
        }
        @keyframes pulseGlow { from { opacity: 0.5; transform: scale(1); } to { opacity: 1; transform: scale(1.05); } }
        .hero-content { position: relative; z-index: 1; }
        .hero-section h1 {
            font-size: clamp(2rem, 5vw, 3.2rem); font-weight: 700; margin-bottom: 1.5rem; color: var(--text-primary);
            line-height: 1.3; animation: textFadeUp 1s 0.2s ease-out forwards; opacity: 0;
        }
        @keyframes textFadeUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .hero-section .tagline {
            font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 2.5rem; max-width: 650px; margin-left: auto; margin-right: auto;
            animation: textFadeUp 1s 0.4s ease-out forwards; opacity: 0;
        }
        .hero-section .btn { animation: buttonScaleIn 0.8s 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; opacity: 0; transform: scale(0.8); }
        @keyframes buttonScaleIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        /* --- About Page --- */
        #about-page .content-container {
            max-width: 850px; margin: 2rem auto; padding: 2.5rem; background-color: var(--bg-card);
            border-radius: var(--border-radius-md); box-shadow: var(--box-shadow-soft);
        }
        #about-page h2 {
            font-size: 2rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--accent-primary);
            text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 0.8rem;
        }
        #about-page p { font-size: 1.05rem; color: var(--text-secondary); text-align: justify; line-height: 1.8; }
        #about-page .btn-back { display: block; width: fit-content; margin: 2rem auto 0 auto; }

        /* --- Feature Page (Input & Results) --- */
        .input-section, .results-section { margin-bottom: 3rem; }
        .form-container {
            background-color: var(--bg-card); padding: 2.5rem; border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow-soft); max-width: 900px; margin: 0 auto;
        }
        .form-container h1 {
            font-size: 2.2rem; font-weight: 600; text-align: center; margin-bottom: 2rem;
            background: var(--accent-gradient); -webkit-background-clip: text; background-clip: text; color: transparent;
        }
        .form-group { margin-bottom: 1.8rem; }
        .form-group label { display: block; margin-bottom: 0.7rem; font-weight: 500; color: var(--text-secondary); font-size: 1rem; }
        .form-group input[type="text"], .form-group textarea, .form-group select {
            width: 100%; padding: 0.9rem 1rem; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm);
            font-size: 1rem; background-color: var(--bg-dark); color: var(--text-primary);
            transition: border-color 0.3s ease, box-shadow 0.3s ease; font-family: inherit;
        }
        .form-group input[type="text"]:focus, .form-group textarea:focus, .form-group select:focus {
             outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(106, 142, 231, 0.2);
        }
        .form-group textarea { resize: vertical; min-height: 140px; }
         /* Style for generate random lyric button */
         #generate-random-lyric-button {
            margin-top: 0.8rem;
            margin-left: auto; /* Push to the right */
            display: block; /* Make it block to allow margin auto */
            width: fit-content; /* Size to content */
            padding: 0.5rem 1rem; /* Smaller padding */
            font-size: 0.9rem; /* Slightly smaller font */
            font-weight: 500; /* Normal weight */
        }
        .form-group select {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23a9a9b3" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat; background-position: right 1rem center; background-size: 20px; padding-right: 3rem; cursor: pointer;
        }
        .form-group select option[disabled] { color: #777; }
        .audio-input-group { display: flex; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .form-group input[type="file"] {
             padding: 0; cursor: pointer; flex-grow: 1; min-width: 200px; margin-bottom: 0;
             background-color: transparent; border: none; box-shadow: none; color: var(--text-secondary);
        }
        input[type="file"]::file-selector-button {
             padding: 0.7rem 1.2rem; margin-right: 1rem; border: none; border-radius: var(--border-radius-sm);
             background: linear-gradient(135deg, #444, #555); color: var(--text-primary);
             cursor: pointer; transition: background 0.3s ease, transform 0.1s ease; font-weight: 500;
        }
        input[type="file"]::file-selector-button:hover { background: linear-gradient(135deg, #555, #666); transform: translateY(-1px); }
        #record-status { margin-left: 1rem; font-style: italic; font-weight: 500; display: inline-flex; align-items: center; min-height: 24px; transition: color 0.3s ease; }
        #record-status.recording { color: var(--error-color); }
        #record-status.transcribing { color: var(--accent-primary); }
        #record-status.complete { color: var(--success-color); }
        #record-status.error { color: var(--error-color); }
        .recording-dots { display: inline-block; vertical-align: middle; margin-right: 6px; }
        .recording-dots span {
            display: inline-block; width: 9px; height: 9px; margin-left: 4px; border-radius: 50%; background-color: var(--error-color);
            animation: recordingPulse 1.4s infinite ease-in-out;
        }
        .recording-dots span:nth-child(1) { animation-delay: 0s; }
        .recording-dots span:nth-child(2) { animation-delay: 0.2s; }
        .recording-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes recordingPulse { 0%, 100% { transform: scale(0.5); opacity: 0.5; } 50% { transform: scale(1); opacity: 1; } }
        #transcript-group { display: none; margin-top: 1.5rem; }
        #transcript-output { background-color: #333; font-style: italic; color: var(--text-secondary); min-height: 90px; cursor: default; border-color: #444; }
        .form-group small { display: block; margin-top: 0.8rem; color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; }
        #generate-concept-button { display: block; width: 100%; max-width: 380px; margin: 2.5rem auto 0 auto; padding: 1rem 1.5rem; font-size: 1.1rem; }

        /* --- Results Section & Cards --- */
        .results-section { display: none; margin-top: 3rem; }
        .results-grid { display: grid; grid-template-columns: 1fr; gap: 1.8rem; } /* Single column layout */
        .result-card {
            background-color: var(--bg-card); border-radius: var(--border-radius-md); padding: 1.8rem;
            box-shadow: var(--box-shadow-soft); border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            opacity: 0; transform: translateY(30px); display: flex; flex-direction: column;
        }
        .result-card.visible { opacity: 1; transform: translateY(0); transition: opacity 0.6s ease-out, transform 0.6s ease-out; /* delay set by JS */ }
        .result-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3); border-color: var(--accent-primary); }
        .result-card h2 {
            font-size: 1.5rem; font-weight: 600; color: var(--accent-primary); margin-bottom: 1.2rem;
            padding-bottom: 0.6rem; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0;
        }
         .result-card h2 > span[data-lang-en] { /* Target only the translatable span inside h2 */
            /* Styles specific to the text span if needed, like preventing wrapping */
            flex-grow: 1;
        }
        .card-content { font-size: 0.95rem; color: var(--text-secondary); line-height: 1.7; flex-grow: 1; overflow: hidden; }
        .card-content p { margin-bottom: 1rem; }
        .card-content p:last-child { margin-bottom: 0; }
        .card-content strong { color: var(--text-primary); font-weight: 600; }
        #result-concept > .card-content { white-space: pre-wrap; } /* Concept text wrapping */

        /* Requirements List */
        #result-requirements ul { margin: 0.5rem 0 0 0; padding-left: 0; list-style: none; }
        #result-requirements li { margin-bottom: 0.8rem; padding-left: 1.8rem; position: relative; }
        #result-requirements li::before {
            content: '✓'; color: var(--accent-primary); font-size: 1.1em; font-weight: 600;
            position: absolute; left: 0; top: 1px; transition: transform 0.3s ease;
        }
        #result-requirements li:hover::before { transform: scale(1.2) rotate(-10deg); }

        /* MODIFIED: Budget Section Styles */
        .budget-columns-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Ensure 3 columns */
            gap: 1.2rem;
            margin-top: 1rem;
        }
        .budget-column {
            border: 1px solid var(--border-color);
            padding: 1.2rem;
            border-radius: var(--border-radius-sm);
            background-color: rgba(26, 26, 29, 0.7);
            display: flex; flex-direction: column; /* Stack elements vertically */
            transition: background-color 0.3s ease;
            min-height: 180px; /* Ensure columns have some base height */
        }
        .budget-column:hover { background-color: rgba(40, 40, 43, 0.8); }
        .budget-column h3 {
            margin-top: 0; margin-bottom: 1rem; padding-bottom: 0.5rem;
            border-bottom: 1px solid #555; color: var(--text-primary);
            font-size: 1.1rem; font-weight: 600; flex-shrink: 0; /* Prevent shrinking */
            text-align: center;
        }
        .budget-column p { /* Holds the main description and item boxes */
            font-size: 0.95rem; /* Matches .card-content */
            line-height: 1.7;    /* Matches .card-content */
            color: var(--text-secondary);
            white-space: normal; /* Allow wrapping */
            margin-bottom: 0;
            flex-grow: 1; /* Allow description to take space */
        }
        /* Style for individual cost items within the description */
        .budget-column .budget-item-box {
             border: 1px solid #555;
             background-color: var(--bg-dark);
             padding: 0.6rem 0.8rem;
             margin-top: 0.8rem; /* Space above item */
             margin-bottom: 0.6rem; /* Space below item */
             border-radius: 4px;
             font-size: 0.85em; /* Relative to parent p */
             box-shadow: 0 1px 2px rgba(0,0,0,0.1);
             display: flex; /* Put item name and cost side-by-side */
             justify-content: space-between;
             align-items: center;
        }
        .budget-column .budget-item-box strong { /* Style the cost part */
            color: var(--text-primary);
            margin-left: 0.5rem; /* Space between item and cost */
            white-space: nowrap; /* Prevent cost from wrapping */
            font-weight: 600;
        }
        /* Placeholder styling specifically for budget columns */
        .budget-column.placeholder-notice {
            border-style: dashed;
            opacity: 0.7;
        }
        .budget-column.placeholder-notice h3 {
            color: var(--text-secondary);
            border-bottom-color: rgba(85, 85, 85, 0.5);
        }
        .budget-column.placeholder-notice p.placeholder-notice { /* Style placeholder text inside budget P */
            text-align: center;
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 1rem;
            font-size: 0.95rem; /* Ensure placeholder text also matches */
            line-height: 1.7;
        }
        /* Main container placeholder */
        .budget-columns-container.placeholder-notice {
            display: block; /* Override grid for single placeholder text */
            text-align: center;
            padding: 1rem;
        }
        .budget-columns-container.placeholder-notice .budget-column {
            display: none; /* Hide columns when main container has placeholder */
        }
        /* --- Style for raw text display on parsing error (MODIFIED) --- */
        .card-content .raw-budget-output pre { /* Target pre inside raw-budget-output class */
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 1.2em; /* Increased font size */
            text-align: left;
            background-color: rgba(0,0,0,0.3); /* Slightly darker background */
            border: 1px dashed var(--border-color); /* Dashed border */
            color: var(--text-secondary);
            padding: 1rem;
            border-radius: var(--border-radius-sm);
            margin-top: 0.5rem;
            max-height: 250px; /* Increased max-height */
            overflow-y: auto;
        }


        /* Image Placeholder (Inside Card) */
        .image-placeholder-container { display: grid; gap: 1.2rem; margin-top: 1rem; }
        #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
        #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
        .image-placeholder {
            border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); background-color: var(--bg-dark);
            overflow: hidden; text-align: center; color: var(--text-secondary); box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease; position: relative;
        }
        .image-placeholder:hover { transform: scale(1.03); box-shadow: 0 5px 12px rgba(0,0,0,0.3); z-index: 5; }
        .image-placeholder img {
            display: block; width: 100%; object-fit: cover; background-color: #444; border-bottom: 1px solid var(--border-color);
            opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        .image-placeholder img[src]:not([src=""]) { opacity: 1; }
        #result-visuals .image-placeholder img { height: 160px; }
        #result-moodboard .image-placeholder img { height: 130px; }
        .image-placeholder figcaption {
            font-size: 0.85em; padding: 0.8rem; background-color: var(--bg-card);
            min-height: 55px; line-height: 1.4; color: var(--text-secondary);
        }
        .image-placeholder figcaption strong { color: var(--text-primary); }
        /* Style for Backend/Fallback source note */
        .image-placeholder figcaption .generation-source,
        .image-placeholder figcaption .fallback-notice {
            font-size: 0.8em; display: block; margin-top: 5px;
        }
        .image-placeholder figcaption .generation-source { color: var(--accent-primary); font-style: italic; } /* Backend note */
        .image-placeholder figcaption .fallback-notice { color: #888; font-style: italic; } /* Fallback notice */


        /* Color Palette Display (Inside Card) */
        .color-palette-display { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 1rem; }
        .color-swatch {
            min-width: 100px; height: 90px; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.85em;
            font-weight: 500; text-align: center; overflow: hidden; padding: 0.5rem; box-shadow: 0 1px 4px rgba(0,0,0,0.15);
            transition: transform 0.25s ease, box-shadow 0.25s ease; flex-grow: 1; opacity: 0; transform: scale(0.8);
        }
        .color-swatch.visible { opacity: 1; transform: scale(1); transition: opacity 0.4s ease-out, transform 0.4s ease-out; /* delay handled by JS */ }
        .color-swatch:hover { transform: scale(1.08) rotate(2deg); box-shadow: 0 4px 10px rgba(0,0,0,0.25); z-index: 5; }
        .color-swatch span { display: block; word-break: break-word; max-width: 100%; }
        .color-swatch .hex-code { margin-top: 0.5rem; font-size: 0.9em; font-family: monospace; user-select: all; opacity: 0.8; }

        /* Action Buttons */
        .action-buttons {
            margin-top: 2rem; padding-top: 2rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; flex-shrink: 0;
        }

        /* --- General Button Styling --- */
        .btn {
            display: inline-block; padding: 0.8rem 1.8rem; border: none; border-radius: var(--border-radius-sm);
            cursor: pointer; font-size: 1rem; font-weight: 600; text-align: center; text-decoration: none;
            color: var(--text-primary); background: var(--accent-gradient);
            transition: transform 0.2s ease, box-shadow 0.3s ease, background-size 0.4s ease, opacity 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); position: relative; overflow: hidden; z-index: 1;
        }
        .btn::before { /* Subtle shine effect on hover */
             content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
             background: linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
             transition: left 0.5s ease; z-index: -1;
        }
        .btn:hover:not(:disabled) { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 15px rgba(106, 142, 231, 0.3); }
        .btn:hover:not(:disabled)::before { left: 100%; }
        .btn:active:not(:disabled) { transform: translateY(0) scale(0.98); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; background: #555; box-shadow: none; }
        .btn-secondary { background: linear-gradient(135deg, #5a5a60, #404045); }
        .btn-secondary:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(80, 80, 80, 0.3); }
        .btn-warning { background: linear-gradient(135deg, var(--warning-color), #d4a00e); color: #222; }
        .btn-warning:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(255, 183, 3, 0.4); color: #000; }
        .btn-danger { background: linear-gradient(135deg, var(--error-color), #b82c3a); }
        .btn-danger:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(230, 57, 70, 0.4); }
        #home-page .btn-back { display: none; } /* Hide back button on home */

        /* --- Error Message --- */
        .error-message {
            background-color: rgba(230, 57, 70, 0.15); color: var(--error-color); border: 1px solid rgba(230, 57, 70, 0.5);
            padding: 1.2rem 1.5rem; border-radius: var(--border-radius-sm); margin: 1.5rem auto; text-align: center;
            font-weight: 500; display: none; max-width: 800px; white-space: pre-wrap;
        }
        /* Specific styling for error paragraphs inside card content */
        .card-content p.error {
            color: var(--error-color);
            font-weight: 500;
        }


        /* --- Footer --- */
        .main-footer {
            background-color: #111; color: var(--text-secondary); padding: 1.5rem 0;
            text-align: center; font-size: 0.9rem; margin-top: auto;
        }
        .main-footer p { margin: 0; }
        .main-footer a { color: var(--accent-primary); text-decoration: none; transition: color 0.3s ease; }
        .main-footer a:hover { color: var(--accent-secondary); }

        /* --- Utility Placeholders --- */
        .placeholder-notice {
            font-style: italic; color: var(--text-secondary); opacity: 0.8;
            text-align: center; padding: 1rem; font-size: 0.9em;
        }
        #result-requirements ul .placeholder-notice { padding: 0; text-align: left; list-style: none; margin-left: 1.8rem; }
        #result-requirements ul .placeholder-notice::before { display: none; }
        /* Ensure image/color placeholders inside cards look right */
        .image-placeholder-container.placeholder-notice,
        .color-palette-display.placeholder-notice {
            display: block; /* Override grid/flex for placeholder text */
            text-align: center; padding: 1rem;
        }
         /* Ensure budget note is always visible, even with placeholders */
         #result-budget > small { display: block; text-align: center; margin-top: 1rem; font-size: 0.85em; opacity: 0.8; }


        /* --- NEW: How to Use Button & Modal --- */
        #how-to-use-button {
            position: fixed;
            bottom: 25px;
            right: 25px;
            z-index: 1001;
            padding: 0.7rem 1.2rem; /* Slightly smaller */
            font-size: 0.9rem;
            border-radius: 50px; /* More rounded */
            background: var(--accent-gradient);
            box-shadow: var(--box-shadow-glow);
        }

        #guide-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(26, 26, 29, 0.85); /* Consistent overlay */
            backdrop-filter: blur(5px);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 1002; /* Above floating button */
            padding: 2rem;
            animation: modalFadeIn 0.4s ease-out forwards;
        }
        #guide-modal.show { display: flex; }

        @keyframes modalFadeIn { from { opacity: 0; } to { opacity: 1; } }

        .guide-content {
            background-color: var(--bg-card);
            padding: 2.5rem;
            border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow-soft);
            max-width: 800px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            color: var(--text-secondary);
            animation: modalScaleUp 0.4s 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            transform: scale(0.9); opacity: 0;
        }
        @keyframes modalScaleUp { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .guide-content h2 {
            color: var(--accent-primary);
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.8rem;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
        }
        .guide-content h3 {
            color: var(--text-primary);
            font-size: 1.3rem;
            margin-top: 2rem;
            margin-bottom: 0.8rem;
        }
        .guide-content p, .guide-content li {
            font-size: 1rem;
            line-height: 1.7;
            margin-bottom: 0.8rem;
        }
        .guide-content strong {
            color: var(--text-primary);
            font-weight: 600;
        }
        .guide-content ul {
             list-style: disc;
             padding-left: 2rem;
             margin-top: 0.5rem;
        }
         .guide-content ul ul { /* Nested lists */
            margin-top: 0.3rem;
            margin-bottom: 0.5rem;
         }
        .guide-content code {
             background-color: var(--bg-dark);
             padding: 0.2em 0.5em;
             border-radius: 4px;
             font-family: monospace;
             font-size: 0.9em;
             color: var(--accent-secondary);
        }
        #guide-close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 2rem;
            line-height: 1;
            cursor: pointer;
            transition: color 0.3s ease, transform 0.2s ease;
            padding: 5px;
        }
        #guide-close-button:hover {
            color: var(--text-primary);
            transform: scale(1.1);
        }


        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
            .container { max-width: 90%; }
            .main-nav ul { gap: 1rem; }
            .main-nav ul li a { font-size: 0.95rem; padding: 0.4rem 0.6rem; }
            #settings-box label { display: none; }
            .form-container { padding: 2rem; }
            .guide-content { padding: 2rem; }
        }

        @media (max-width: 768px) {
            html { font-size: 15px; }
            :root { --nav-height: 60px; }
            main { padding-top: calc(var(--nav-height) + 1.5rem); }
            .main-nav { padding: 0 1.5rem; flex-wrap: wrap; height: auto; min-height: var(--nav-height); align-content: center; }
            .logo { font-size: 1.2rem; }
            .main-nav ul { order: 3; width: 100%; justify-content: center; padding: 0.5rem 0; border-top: 1px solid var(--border-color); margin-top: 0.5rem; gap: 0.8rem; }
            #settings-box { order: 2; margin-left: auto; padding-bottom: 0.5rem; }
            .hero-section { padding: 3rem 0.5rem; }
            .hero-section h1 { font-size: clamp(1.8rem, 6vw, 2.5rem); }
            .hero-section .tagline { font-size: 1rem; }
            /* Stack budget columns on smaller screens */
            .budget-columns-container { grid-template-columns: 1fr; gap: 1rem; }
            .budget-column { min-height: auto; } /* Let height adjust */
            .result-card { padding: 1.5rem; }
            .result-card h2 { font-size: 1.4rem; }
            #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            #about-page .content-container { padding: 1.5rem; }
            #how-to-use-button { bottom: 15px; right: 15px; padding: 0.6rem 1rem; font-size: 0.8rem; }
            #guide-modal { padding: 1rem; }
            .guide-content { padding: 1.5rem; max-height: 90vh; }
            .guide-content h2 { font-size: 1.6rem; }
            .guide-content h3 { font-size: 1.2rem; }
            .guide-content p, .guide-content li { font-size: 0.95rem; }
        }

        @media (max-width: 480px) {
            html { font-size: 14px; }
            .main-nav { padding: 0 1rem; }
            .main-nav ul { gap: 0.5rem; flex-wrap: wrap; justify-content: space-around; }
            .main-nav ul li a { padding: 0.4rem; font-size: 0.9rem; }
            #settings-box { width: 100%; order: 3; justify-content: center; margin-left: 0; margin-top: 0.5rem; padding-bottom: 0.5rem; }
            .container { padding: 0 1rem; }
            .form-container { padding: 1.5rem; }
            .form-container h1 { font-size: 1.8rem; margin-bottom: 1.5rem; }
            .form-group { margin-bottom: 1.5rem; }
            #generate-random-lyric-button { font-size: 0.8rem; padding: 0.4rem 0.8rem; }
            .audio-input-group { flex-direction: column; align-items: stretch; gap: 0.8rem; }
            input[type="file"]::file-selector-button { width: 100%; text-align: center; margin-right: 0; }
            .audio-input-group .btn { width: 100%; margin: 0;}
            #record-status { margin-left: 0; justify-content: center; width: 100%; margin-top: 0.3rem; }
            #generate-concept-button { max-width: 100%; padding: 0.9rem 1.2rem; font-size: 1rem; }
            .btn { padding: 0.7rem 1.5rem; font-size: 0.95rem; }
            .action-buttons { gap: 1rem; }
            #result-visuals .image-placeholder-container,
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            #result-visuals .image-placeholder img { height: 130px; }
            #result-moodboard .image-placeholder img { height: 110px; }
            .color-palette-display { gap: 0.8rem; }
            .color-swatch { min-width: 80px; height: 70px; font-size: 0.8rem; }
             #guide-content { padding: 1.2rem; }
            #guide-close-button { top: 10px; right: 10px; font-size: 1.8rem; }
        }

    </style>
</head>
<body>

    <!-- Loading Overlay Div -->
    <div id="loading-overlay">
        <div class="loading-spinner"></div>
        <p
            data-lang-en="Generating creative sparks..."
            data-lang-es="Generando chispas creativas..."
            data-lang-vi="Đang tạo ra những tia sáng sáng tạo..."
            data-lang-ja="創造的な火花を生成中..."
            data-lang-zhcn="正在生成创意火花..."
            data-last-key="generatingCreativeSparks"
        >Generating creative sparks...</p>
    </div>

    <!-- Navigation -->
    <nav class="main-nav">
        <a href="#" data-page="home" class="logo nav-link">
             <!-- Assume logofinal(white).png exists or replace -->
             <img src="logofinal(white).png" alt="MV Generator Logo" style="max-height: 40px; width: auto; vertical-align: middle; border-radius: 3px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
             <span style="display: none;"
                data-lang-en="Logo"
                data-lang-es="Logo"
                data-lang-vi="Logo"
                data-lang-ja="ロゴ"
                data-lang-zhcn="标志"
                data-logo-text="true" <!-- Identifier for translation -->
             >Logo</span> <!-- Fallback Text -->
        </a>
        <ul>
            <li><a data-page="home" class="nav-link active"
                   data-lang-en="Home" data-lang-es="Inicio" data-lang-vi="Trang chủ" data-lang-ja="ホーム" data-lang-zhcn="首页"
                >Home</a></li>
            <li><a data-page="about" class="nav-link"
                   data-lang-en="About" data-lang-es="Acerca de" data-lang-vi="Giới thiệu" data-lang-ja="概要" data-lang-zhcn="关于"
                >About</a></li>
            <li><a data-page="feature" class="nav-link"
                   data-lang-en="Generate" data-lang-es="Generar" data-lang-vi="Tạo" data-lang-ja="生成" data-lang-zhcn="生成"
                >Generate</a></li>
        </ul>
        <!-- Settings Box for Language -->
        <div id="settings-box">
            <label for="language-select"
                data-lang-en="Language:" data-lang-es="Idioma:" data-lang-vi="Ngôn ngữ:" data-lang-ja="言語：" data-lang-zhcn="语言："
            >Language:</label>
            <select id="language-select">
                <option value="en">English</option>
                <option value="es">Español</option>
                <option value="vi">Tiếng Việt</option>
                <option value="ja">日本語</option>
                <option value="zh-CN">中文</option> <!-- Changed value to zh-CN -->
            </select>
        </div>
    </nav>

    <main>
        <!-- Home Page Section -->
        <section id="home-page" class="page active container">
            <div class="hero-section">
                <div class="hero-content">
                    <h1
                        data-lang-en="Unlock Visual Concepts for Your Music" data-lang-es="Desbloquea Conceptos Visuales para Tu Música" data-lang-vi="Mở khóa ý tưởng hình ảnh cho âm nhạc của bạn" data-lang-ja="あなたの音楽のためのビジュアルコンセプトを解き放つ" data-lang-zhcn="为您的音乐解锁视觉概念"
                    >Unlock Visual Concepts for Your Music</h1>
                    <p class="tagline"
                       data-lang-en="Transform your lyrics and ideas into stunning music video concepts with the power of AI." data-lang-es="Transforma tus letras e ideas en impresionantes conceptos de videos musicales con el poder de la IA." data-lang-vi="Biến lời bài hát và ý tưởng của bạn thành những ý tưởng video âm nhạc tuyệt đẹp với sức mạnh của AI." data-lang-ja="AIの力で、あなたの歌詞やアイデアを見事なミュージックビデオコンセプトに変えましょう。" data-lang-zhcn="借助人工智能的力量，将您的歌词和想法转化为令人惊叹的音乐视频概念。"
                    >Transform your lyrics and ideas into stunning music video concepts with the power of AI.</p>
                    <button id="explore-button" class="btn btn-primary"
                            data-lang-en="Start Generating" data-lang-es="Comenzar a Generar" data-lang-vi="Bắt đầu tạo" data-lang-ja="生成を開始" data-lang-zhcn="开始生成"
                        >Start Generating</button>
                </div>
            </div>
        </section>

        <!-- About Page Section -->
        <section id="about-page" class="page container">
            <div class="content-container">
                <h2
                    data-lang-en="About MV Generator" data-lang-es="Acerca del Generador MV" data-lang-vi="Về Trình tạo MV" data-lang-ja="MVジェネレーターについて" data-lang-zhcn="关于 MV 生成器"
                >About MV Generator</h2>
                <p
                   data-lang-en="Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, and genre, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, and color palettes. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!"
                   data-lang-es="¡Bienvenido al Generador de MV! Nos apasiona ayudar a los artistas a traducir sus creaciones musicales en historias visuales convincentes. Crear el concepto perfecto para un video musical puede ser desafiante, requiriendo una mezcla de visión artística y planificación práctica. Nuestra herramienta impulsada por IA está diseñada para cerrar esa brecha. Al analizar tus letras, palabras clave y género, el Generador de MV genera sugerencias personalizadas para conceptos de videos musicales, requisitos, estimaciones de presupuesto, inspiraciones visuales y paletas de colores. Nuestro objetivo es agilizar el proceso creativo, proporcionando una plataforma de lanzamiento para tus ideas y empoderándote para dar vida visual a tu música, ya seas un artista independiente o parte de una producción más grande. ¡Hagamos algo increíble juntos!"
                   data-lang-vi="Chào mừng bạn đến với Trình tạo MV! Chúng tôi đam mê giúp các nghệ sĩ chuyển đổi những sáng tạo âm nhạc của họ thành những câu chuyện hình ảnh hấp dẫn. Việc tạo ra ý tưởng video âm nhạc hoàn hảo có thể đầy thử thách, đòi hỏi sự kết hợp giữa tầm nhìn nghệ thuật và kế hoạch thực tế. Công cụ hỗ trợ AI của chúng tôi được thiết kế để thu hẹp khoảng cách đó. Bằng cách phân tích lời bài hát, từ khóa và thể loại của bạn, Trình tạo MV tạo ra các đề xuất phù hợp cho các khái niệm video âm nhạc, yêu cầu, ước tính ngân sách, nguồn cảm hứng trực quan và bảng màu. Chúng tôi mong muốn hợp lý hóa quy trình sáng tạo, cung cấp bệ phóng cho ý tưởng của bạn và trao quyền cho bạn để đưa âm nhạc của mình vào cuộc sống một cách trực quan, cho dù bạn là một nghệ sĩ độc lập hay là một phần của một nhà sản xuất lớn hơn. Hãy cùng nhau tạo ra điều gì đó tuyệt vời!"
                   data-lang-ja="MVジェネレーターへようこそ！私たちは、アーティストが音楽作品を魅力的なビジュアルストーリーに変換するお手伝いをすることに情熱を注いでいます。完璧なミュージックビデオのコンセプトを作り上げることは、芸術的なビジョンと実践的な計画の融合を必要とする、困難な作業となる場合があります。当社のAI搭載ツールは、そのギャップを埋めるために設計されています。あなたの歌詞、キーワード、ジャンルを分析することにより、MVジェネレーターはミュージックビデオのコンセプト、要件、予算の見積もり、視覚的なインスピレーション、カラーパレットに関するカスタマイズされた提案を生成します。私たちは、インディーズアーティストであろうと大規模なプロダクションの一部であろうと、あなたのアイデアの出発点を提供し、あなたの音楽を視覚的に実現する力を与えることで、創造的なプロセスを合理化することを目指しています。一緒に素晴らしいものを作りましょう！"
                   data-lang-zhcn="欢迎来到 MV 生成器！我们热衷于帮助艺术家将他们的音乐创作转化为引人入胜的视觉故事。制作完美的音乐视频概念可能具有挑战性，需要艺术视野和实际规划的结合。我们的人工智能工具旨在弥合这一差距。通过分析您的歌词、关键词和流派，MV 生成器会生成量身定制的音乐视频概念、要求、预算估算、视觉灵感和调色板建议。我们的目标是简化创作过程，为您的想法提供一个启动平台，并使您能够将音乐以视觉方式呈现出来，无论您是独立艺术家还是大型制作团队的一员。让我们一起创造一些惊人的东西吧！"
                >
                    Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, and genre, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, and color palettes. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!
                </p>
                 <button class="btn btn-secondary btn-back" data-target="home"
                    data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页"
                >Back to Home</button>
            </div>
        </section>

        <!-- Feature Page Section (Input & Results) -->
        <section id="feature-page" class="page container">
            <!-- Input Form Area -->
            <div class="input-section">
                <div class="form-container">
                    <h1
                        data-lang-en="Generate Your MV Concept" data-lang-es="Genera Tu Concepto de MV" data-lang-vi="Tạo ý tưởng MV của bạn" data-lang-ja="MVコンセプトを生成" data-lang-zhcn="生成您的 MV 概念"
                    >Generate Your MV Concept</h1>

                    <form id="feature-form" onsubmit="return false;">
                        <div class="form-group">
                            <label for="lyrics-input"
                                data-lang-en="Music Lyrics:" data-lang-es="Letra de la Música:" data-lang-vi="Lời bài hát:" data-lang-ja="歌詞：" data-lang-zhcn="歌词："
                            >Music Lyrics:</label>
                            <textarea id="lyrics-input" rows="7" required
                                data-lang-en-placeholder="Paste your complete song lyrics here..." data-lang-es-placeholder="Pega la letra completa de tu canción aquí..." data-lang-vi-placeholder="Dán toàn bộ lời bài hát của bạn vào đây..." data-lang-ja-placeholder="ここに完全な歌詞を貼り付けてください..." data-lang-zhcn-placeholder="在此处粘贴完整的歌词..."
                                placeholder="Paste your complete song lyrics here..." ></textarea>
                             <!-- NEW Random Lyric Button -->
                             <button type="button" id="generate-random-lyric-button" class="btn btn-secondary"
                                data-lang-en="Generate Random Lyric" data-lang-es="Generar Letra Aleatoria" data-lang-vi="Tạo lời ngẫu nhiên" data-lang-ja="ランダムな歌詞を生成" data-lang-zhcn="生成随机歌词"
                            >Generate Random Lyric</button>
                        </div>
                        <div class="form-group">
                            <label for="keywords-input"
                                data-lang-en="Keywords / Theme:" data-lang-es="Palabras Clave / Tema:" data-lang-vi="Từ khóa / Chủ đề:" data-lang-ja="キーワード / テーマ：" data-lang-zhcn="关键词/主题："
                            >Keywords / Theme:</label>
                            <input type="text" id="keywords-input" required
                                data-lang-en-placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle" data-lang-es-placeholder="ej., nostálgico, ambiente de verano, decadencia urbana, superación" data-lang-vi-placeholder="vd: hoài cổ, không khí mùa hè, suy tàn đô thị, vượt qua khó khăn" data-lang-ja-placeholder="例：ノスタルジック、夏の雰囲気、都市の荒廃、苦難の克服" data-lang-zhcn-placeholder="例如，怀旧、夏日氛围、城市衰败、克服困难"
                                placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle" >
                        </div>
                        <div class="form-group">
                            <label for="genre-select"
                                data-lang-en="Music Genre:" data-lang-es="Género Musical:" data-lang-vi="Thể loại âm nhạc:" data-lang-ja="音楽ジャンル：" data-lang-zhcn="音乐流派："
                            >Music Genre:</label>
                            <select id="genre-select" required>
                                <option value="" disabled selected
                                    data-lang-en="-- Select a Genre --" data-lang-es="-- Selecciona un Género --" data-lang-vi="-- Chọn một thể loại --" data-lang-ja="-- ジャンルを選択 --" data-lang-zhcn="-- 选择流派 --"
                                >-- Select a Genre --</option>
                                <option value="RnB">RnB / Soul</option>
                                <option value="Folk">Folk / Acoustic</option>
                                <option value="Rock">Rock</option>
                                <option value="Pop">Pop</option>
                                <option value="Hiphop">Hip-hop / Rap</option>
                                <option value="Electronic">Electronic</option>
                                <option value="Classical">Classical</option>
                                <option value="Country">Country</option>
                                <option value="Jazz">Jazz / Blues</option>
                                <option value="Reggae">Reggae</option>
                                <option value="Metal">Metal</option>
                                <option value="Other">Other / Fusion</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="track-upload"
                                data-lang-en="Track Input (Optional):" data-lang-es="Entrada de Pista (Opcional):" data-lang-vi="Nhập bản nhạc (Tùy chọn):" data-lang-ja="トラック入力（任意）：" data-lang-zhcn="音轨输入（可选）："
                            >Track Input (Optional):</label>
                            <div class="audio-input-group">
                                <input type="file" id="track-upload" accept="audio/*">
                                <button type="button" id="record-audio-button" class="btn btn-warning"
                                    data-lang-en-record="Record Audio" data-lang-es-record="Grabar Audio" data-lang-vi-record="Ghi âm" data-lang-ja-record="音声を録音" data-lang-zhcn-record="录制音频"
                                    data-lang-en-stop="Stop Recording" data-lang-es-stop="Detener Grabación" data-lang-vi-stop="Dừng ghi âm" data-lang-ja-stop="録音停止" data-lang-zhcn-stop="停止录制"
                                >Record Audio</button>
                                <span id="record-status" class="record-status-base">
                                    <span id="recording-animation" class="recording-dots" style="display: none;"><span></span><span></span><span></span></span>
                                    <span id="record-status-text"></span>
                                </span>
                            </div>
                            <small
                                data-lang-en="Upload an audio file or record your singing. Analysis enhances suggestions (requires browser support)." data-lang-es="Sube un archivo de audio o graba tu canto. El análisis mejora las sugerencias (requiere soporte del navegador)." data-lang-vi="Tải lên tệp âm thanh hoặc ghi âm giọng hát của bạn. Phân tích giúp cải thiện đề xuất (yêu cầu trình duyệt hỗ trợ)." data-lang-ja="オーディオファイルをアップロードするか、歌声を録音します。分析により提案が強化されます（ブラウザのサポートが必要です）。" data-lang-zhcn="上传音频文件或录制您的演唱。分析可增强建议（需要浏览器支持）。"
                            >
                                Upload an audio file or record your singing. Analysis enhances suggestions (requires browser support).
                            </small>
                        </div>
                        <div class="form-group" id="transcript-group" style="display: none;">
                            <label for="transcript-output"
                                data-lang-en="Singing Transcript (from recording):" data-lang-es="Transcripción del Canto (de grabación):" data-lang-vi="Bản ghi lời hát (từ ghi âm):" data-lang-ja="歌唱トランスクリプト（録音より）：" data-lang-zhcn="演唱转录稿（来自录音）："
                            >Singing Transcript (from recording):</label>
                            <textarea id="transcript-output" rows="4" readonly
                                data-lang-en-placeholder="Transcript will appear here..." data-lang-es-placeholder="La transcripción aparecerá aquí..." data-lang-vi-placeholder="Bản ghi sẽ xuất hiện ở đây..." data-lang-ja-placeholder="トランスクリプトがここに表示されます..." data-lang-zhcn-placeholder="转录稿将显示在此处..."
                                placeholder="Transcript will appear here..."></textarea>
                            <small
                                data-lang-en="This text will be analyzed along with lyrics." data-lang-es="Este texto se analizará junto con la letra." data-lang-vi="Văn bản này sẽ được phân tích cùng với lời bài hát." data-lang-ja="このテキストは歌詞とともに分析されます。" data-lang-zhcn="此文本将与歌词一起分析。"
                            >This text will be analyzed along with lyrics.</small>
                        </div>

                        <button type="button" id="generate-concept-button" class="btn btn-primary"
                            data-lang-en="Generate Concept" data-lang-es="Generar Concepto" data-lang-vi="Tạo ý tưởng" data-lang-ja="コンセプトを生成" data-lang-zhcn="生成概念"
                        >Generate Concept</button>
                    </form>
                </div>
            </div>

            <!-- Error Message Area -->
            <div id="error-message" class="error-message"
                 data-lang-en="An error occurred. Please check your input or try again later." data-lang-es="Ocurrió un error. Por favor, revisa tu entrada o inténtalo de nuevo más tarde." data-lang-vi="Đã xảy ra lỗi. Vui lòng kiểm tra đầu vào của bạn hoặc thử lại sau." data-lang-ja="エラーが発生しました。入力を確認するか、後でもう一度お試しください。" data-lang-zhcn="发生错误。请检查您的输入或稍后再试。"
                 data-error-key="errorUnknown"
            >An error occurred. Please check your input or try again later.</div>

            <!-- Results Area (Cards) -->
            <div class="results-section" id="results-output-area">
                <!-- Concept Card -->
                 <div id="result-concept-card" class="result-card" style="grid-column: 1 / -1; display: none;">
                     <h2>
                         <span data-lang-en="Concept / Key Visual" data-lang-es="Concepto / Visual Clave" data-lang-vi="Ý tưởng / Hình ảnh chủ đạo" data-lang-ja="コンセプト / キービジュアル" data-lang-zhcn="概念 / 关键视觉"
                         >Concept / Key Visual</span>
                     </h2>
                     <div class="card-content placeholder-notice" id="result-concept">
                         <p class="placeholder-notice"
                            data-placeholder-key="conceptPlaceholder"
                            data-lang-en="Your generated concept will appear here..." data-lang-es="Tu concepto generado aparecerá aquí..." data-lang-vi="Ý tưởng được tạo của bạn sẽ xuất hiện ở đây..." data-lang-ja="生成されたコンセプトがここに表示されます..." data-lang-zhcn="您生成的概念将显示在此处..."
                         >Your generated concept will appear here...</p>
                     </div>
                     <!-- Action buttons -->
                     <div class="action-buttons">
                         <button id="explore-more-button" class="btn btn-secondary" disabled
                             data-lang-en="Explore More Details" data-lang-es="Explorar Más Detalles" data-lang-vi="Khám phá thêm chi tiết" data-lang-ja="詳細をさらに探索" data-lang-zhcn="探索更多细节"
                         >Explore More Details</button>
                         <button id="regenerate-button" class="btn btn-secondary" disabled
                             data-lang-en="Re-Generate Concept" data-lang-es="Re-Generar Concepto" data-lang-vi="Tạo lại ý tưởng" data-lang-ja="コンセプトを再生成" data-lang-zhcn="重新生成概念"
                         >Re-Generate Concept</button>
                     </div>
                 </div>

                 <!-- Detailed Results Grid (Populated after 'Explore More', single column) -->
                 <div class="results-grid" id="detailed-results-grid" style="display: none;">
                     <div id="result-requirements-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Requirements for MV" data-lang-es="Requisitos para el MV" data-lang-vi="Yêu cầu đối với MV" data-lang-ja="MVの要件" data-lang-zhcn="MV 要求"
                             >Requirements for MV</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-requirements">
                            <ul class="placeholder-notice">
                                <li class="placeholder-notice"
                                    data-placeholder-key="requirementsPlaceholder"
                                    data-lang-en="Requirements list will appear here..." data-lang-es="La lista de requisitos aparecerá aquí..." data-lang-vi="Danh sách yêu cầu sẽ xuất hiện ở đây..." data-lang-ja="要件リストがここに表示されます..." data-lang-zhcn="要求列表将显示在此处..."
                                >Requirements list will appear here...</li>
                            </ul>
                         </div>
                     </div>

                     <!-- == BUDGET CARD STRUCTURE == -->
                     <div id="result-budget-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Estimated Budget" data-lang-es="Presupuesto Estimado" data-lang-vi="Ngân sách ước tính" data-lang-ja="推定予算" data-lang-zhcn="预估预算"
                             >Estimated Budget</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-budget">
                             <!-- Container for the 3 budget columns -->
                             <div class="budget-columns-container placeholder-notice">
                                 <!-- Placeholder Text (will be replaced by JS if columns are generated) -->
                                 <p data-placeholder-key="budgetPlaceholder" class="placeholder-notice"
                                    data-lang-en="Budget details will appear here..." data-lang-es="Los detalles del presupuesto aparecerán aquí..." data-lang-vi="Chi tiết ngân sách sẽ xuất hiện ở đây..." data-lang-ja="予算の詳細がここに表示されます..." data-lang-zhcn="预算细节将显示在此处..."
                                 >Budget details will appear here...</p>
                                 <!-- Low, Mid, High Columns will be generated here by JS -->
                             </div>
                             <!-- Note about budget estimates -->
                             <small style="display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;"
                                data-lang-en="Note: Budgets are conceptual estimates and vary widely based on specifics like location, crew size, equipment, talent, etc." data-lang-es="Nota: Los presupuestos son estimaciones conceptuales y varían ampliamente según detalles como ubicación, equipo, equipamiento, talento, etc." data-lang-vi="Lưu ý: Ngân sách là ước tính khái niệm và thay đổi rất nhiều dựa trên các chi tiết cụ thể như địa điểm, quy mô đoàn làm phim, thiết bị, tài năng, v.v." data-lang-ja="注：予算は概念的な見積もりであり、場所、スタッフの規模、機材、タレントなどの詳細によって大きく変動します。" data-lang-zhcn="注意：预算是概念性估算，并根据地点、团队规模、设备、人才等具体情况而有很大差异。"
                                data-placeholder-key="budgetNotePlaceholder"
                             >Note: Budgets are conceptual estimates and vary widely based on specifics like location, crew size, equipment, talent, etc.</small>
                         </div>
                     </div>
                     <!-- == END BUDGET CARD STRUCTURE == -->

                     <div id="result-visuals-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Visual Demo (Key Images)" data-lang-es="Demo Visual (Imágenes Clave)" data-lang-vi="Minh họa Hình ảnh (Ảnh chính)" data-lang-ja="ビジュアルデモ（キーイメージ）" data-lang-zhcn="视觉演示（关键图像）"
                             >Visual Demo (Key Images)</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-visuals">
                            <div class="image-placeholder-container placeholder-notice">
                                <p data-placeholder-key="visualsPlaceholder" class="placeholder-notice"
                                   data-lang-en="Key visual descriptions will appear here..." data-lang-es="Las descripciones visuales clave aparecerán aquí..." data-lang-vi="Mô tả hình ảnh chính sẽ xuất hiện ở đây..." data-lang-ja="主要なビジュアルの説明がここに表示されます..." data-lang-zhcn="关键视觉描述将显示在此处..."
                                >Key visual descriptions will appear here...</p>
                            </div>
                             <small style="display: block; margin-top: 1rem; font-size: 0.85em;"
                                data-lang-en="Illustrative images based on descriptions." data-lang-es="Imágenes ilustrativas basadas en descripciones." data-lang-vi="Hình ảnh minh họa dựa trên mô tả." data-lang-ja="説明に基づいた説明的な画像。" data-lang-zhcn="基于描述的说明性图片。"
                                data-placeholder-key="visualsNotePlaceholder"
                             >Illustrative images based on descriptions.</small>
                         </div>
                     </div>

                     <div id="result-moodboard-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Moodboard Influences" data-lang-es="Influencias del Moodboard" data-lang-vi="Ảnh hưởng Moodboard" data-lang-ja="ムードボードの影響" data-lang-zhcn="情绪板影响"
                             >Moodboard Influences</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-moodboard">
                             <p data-placeholder-key="moodboardDescPlaceholder" id="moodboard-description" class="placeholder-notice"
                                data-lang-en="Moodboard description will appear here..." data-lang-es="La descripción del moodboard aparecerá aquí..." data-lang-vi="Mô tả moodboard sẽ xuất hiện ở đây..." data-lang-ja="ムードボードの説明がここに表示されます..." data-lang-zhcn="情绪板描述将显示在此处..."
                             >Moodboard description will appear here...</p>
                             <div class="image-placeholder-container placeholder-notice" id="moodboard-images">
                                <p data-placeholder-key="moodboardImgsPlaceholder" class="placeholder-notice"
                                   data-lang-en="Moodboard influence images will appear here..." data-lang-es="Las imágenes de influencia del moodboard aparecerán aquí..." data-lang-vi="Hình ảnh ảnh hưởng moodboard sẽ xuất hiện ở đây..." data-lang-ja="ムードボードの影響画像がここに表示されます..." data-lang-zhcn="情绪板影响图片将显示在此处..."
                                >Moodboard influence images will appear here...</p>
                             </div>
                              <small style="display: block; margin-top: 1rem; font-size: 0.85em;"
                                data-lang-en="Visual styles and elements for inspiration." data-lang-es="Estilos visuales y elementos para inspiración." data-lang-vi="Phong cách và yếu tố hình ảnh để lấy cảm hứng." data-lang-ja="インスピレーションのための視覚的なスタイルと要素。" data-lang-zhcn="用于灵感的视觉风格和元素。"
                                data-placeholder-key="moodboardNotePlaceholder"
                              >Visual styles and elements for inspiration.</small>
                         </div>
                     </div>

                     <div id="result-palette-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Color Palette" data-lang-es="Paleta de Colores" data-lang-vi="Bảng màu" data-lang-ja="カラーパレット" data-lang-zhcn="调色板"
                             >Color Palette</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-palette">
                             <div class="color-palette-display placeholder-notice">
                                <p data-placeholder-key="palettePlaceholder" class="placeholder-notice"
                                   data-lang-en="Color palette will appear here..." data-lang-es="La paleta de colores aparecerá aquí..." data-lang-vi="Bảng màu sẽ xuất hiện ở đây..." data-lang-ja="カラーパレットがここに表示されます..." data-lang-zhcn="调色板将显示在此处..."
                                >Color palette will appear here...</p>
                             </div>
                         </div>
                     </div>
                 </div><!-- End #detailed-results-grid -->
            </div> <!-- End #results-output-area -->

            <!-- Back button for the feature page -->
             <button class="btn btn-secondary btn-back" data-target="home" style="display: block; width: fit-content; margin: 3rem auto 0 auto;"
                data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页"
             >Back to Home</button>

        </section>
    </main>

    <footer class="main-footer">
        <div class="container">
            <p>&copy; 2025 MVPot. All rights reserved.</p>
            <!-- <p><a href="#">Privacy Policy</a> | <a href="#">Terms of Service</a></p> -->
        </div>
    </footer>

    <!-- NEW: How to Use Button -->
    <button id="how-to-use-button" class="btn"
        data-lang-en="How to use"
        data-lang-es="Cómo usar"
        data-lang-vi="Cách sử dụng"
        data-lang-ja="使い方"
        data-lang-zhcn="如何使用"
    >How to use</button>

    <!-- NEW: Guide Modal -->
    <div id="guide-modal">
        <div class="guide-content">
            <button id="guide-close-button">&times;</button>
            <h2 data-guide-title="true">How to Use MV Concept Generator</h2>

            <h3 data-guide-nav="true">Navigation</h3>
            <p data-guide-nav-desc="true">Use the links at the top (<code>Home</code>, <code>About</code>, <code>Generate</code>) to switch between the main sections of the website.</p>

            <h3 data-guide-lang="true">Language Selection</h3>
            <p data-guide-lang-desc="true">Use the dropdown menu in the top-right corner to change the website's display language.</p>

            <h3 data-guide-generate="true">Generate Page Features</h3>
            <ul>
                <li data-guide-lyrics="true"><strong>Music Lyrics:</strong> Paste your full song lyrics into this text box. This is the primary input for the AI analysis.</li>
                <li data-guide-random-lyrics="true"><strong>Generate Random Lyric:</strong> Click this button if you don't have lyrics ready or want inspiration. It will generate random song lyrics (with structure like Intro, Verse, Chorus) and put them into the lyrics box for you.</li>
                <li data-guide-keywords="true"><strong>Keywords / Theme:</strong> Enter words or short phrases describing the mood, style, or key ideas of your song (e.g., <code>upbeat</code>, <code>city at night</code>, <code>love story</code>, <code>finding hope</code>). This helps guide the AI.</li>
                <li data-guide-genre="true"><strong>Music Genre:</strong> Select the genre that best fits your music from the dropdown list.</li>
                <li data-guide-track="true"><strong>Track Input (Optional):</strong> You can either upload an audio file (<code>.mp3</code>, <code>.wav</code>, etc.) or click <code>Record Audio</code> to record your singing directly in the browser (requires microphone permission). The AI can analyze the audio/transcript for better suggestions, but this is optional.</li>
                <li data-guide-generate-btn="true"><strong>Generate Concept:</strong> Once you have entered your lyrics (or generated random ones), keywords, and genre, click this button. The AI will process your input and generate an initial Music Video Concept.</li>
            </ul>

            <h3 data-guide-results="true">Understanding the Results</h3>
            <p data-guide-results-desc="true">After clicking "Generate Concept", results will appear below:</p>
            <ul>
                <li data-guide-concept="true"><strong>Concept / Key Visual:</strong> The main idea for your music video.</li>
                <li data-guide-explore="true"><strong>Explore More Details:</strong> Click this button to have the AI generate the following detailed sections based on the initial concept:</li>
                <ul>
                    <li data-guide-reqs="true"><strong>Requirements:</strong> A list of potential needs (locations, props, actors, etc.).</li>
                    <li data-guide-budget="true"><strong>Estimated Budget:</strong> Rough budget ideas for Low, Mid, and High production levels.</li>
                    <li data-guide-visuals="true"><strong>Visual Demo:</strong> Descriptions of key scenes, often with generated images for inspiration.</li>
                    <li data-guide-moodboard="true"><strong>Moodboard Influences:</strong> Style references and visual elements, also often with generated images.</li>
                    <li data-guide-palette="true"><strong>Color Palette:</strong> Suggested colors that match the concept's mood.</li>
                </ul>
                 <li data-guide-regenerate="true"><strong>Re-Generate Concept:</strong> If you're not satisfied with the initial concept, click this to try again with the same inputs.</li>
            </ul>
             <p data-guide-ai-note="true"><strong>Note:</strong> All suggestions are generated by AI and serve as creative starting points. Budget estimations are very rough, and image generation provides conceptual illustrations.</p>
        </div>
    </div>


    <!-- ========= START JAVASCRIPT ========= -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element References ---
        const navLinks = document.querySelectorAll('.nav-link');
        const pages = document.querySelectorAll('.page');
        const exploreButton = document.getElementById('explore-button');
        const backButtons = document.querySelectorAll('.btn-back');
        const generateConceptButton = document.getElementById('generate-concept-button');
        const generateRandomLyricButton = document.getElementById('generate-random-lyric-button'); // New Button
        const resultsOutputArea = document.getElementById('results-output-area');
        const conceptCard = document.getElementById('result-concept-card');
        const detailedResultsGrid = document.getElementById('detailed-results-grid');
        const exploreMoreButton = document.getElementById('explore-more-button');
        const regenerateButton = document.getElementById('regenerate-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const errorMessageDiv = document.getElementById('error-message');
        const recordAudioButton = document.getElementById('record-audio-button');
        const recordStatus = document.getElementById('record-status');
        const recordingAnimation = document.getElementById('recording-animation');
        const recordStatusText = document.getElementById('record-status-text');
        const lyricsInput = document.getElementById('lyrics-input');
        const keywordsInput = document.getElementById('keywords-input');
        const genreSelect = document.getElementById('genre-select');
        const trackUploadInput = document.getElementById('track-upload');
        const transcriptGroup = document.getElementById('transcript-group');
        const transcriptOutput = document.getElementById('transcript-output');
        const languageSelect = document.getElementById('language-select');
        const allTranslatableElements = document.querySelectorAll('[data-lang-en], [data-lang-en-placeholder], [data-lang-en-record], [data-lang-en-stop], [data-guide-title]'); // Include guide elements selector if needed
        // New Guide Modal Elements
        const howToUseButton = document.getElementById('how-to-use-button');
        const guideModal = document.getElementById('guide-modal');
        const guideCloseButton = document.getElementById('guide-close-button');
        const guideContent = guideModal ? guideModal.querySelector('.guide-content') : null;

        // --- State Variables ---
        let currentInputs = null; // Store form inputs for regeneration/exploration
        let currentLang = 'en'; // Default language
        let activePage = 'home'; // Track current page

        // --- Audio Recording Variables ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordedAudioBlob = null;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let finalTranscript = '';
        let isSpeechRecognitionSupported = !!SpeechRecognition;

        // --- Mapping for Section Processing & Placeholders ---
        const sections = { // Maps Header Title to Content Div ID
            'Concept / Key Visual': 'result-concept',
            'Requirements for MV': 'result-requirements',
            'Estimated Budget': 'result-budget',
            // Gemini prompt asks for 'Visual Demo (Key Image Descriptions)'
            // Replicate function will process 'Visual Demo (Key Images)'
            // Keep both possibilities here to handle potential AI response variation
            'Visual Demo (Key Image Descriptions)': 'result-visuals',
            'Visual Demo (Key Images)': 'result-visuals', // Added for Replicate section title
            'Moodboard Influences': 'result-moodboard',
            'Color Palette': 'result-palette'
        };
        const cardElements = { // Maps Header Title to Card Element
            'Concept / Key Visual': conceptCard,
            'Requirements for MV': document.getElementById('result-requirements-card'),
            'Estimated Budget': document.getElementById('result-budget-card'),
            'Visual Demo (Key Image Descriptions)': document.getElementById('result-visuals-card'), // Keep mapping consistent
            'Visual Demo (Key Images)': document.getElementById('result-visuals-card'), // Map the new title too
            'Moodboard Influences': document.getElementById('result-moodboard-card'),
            'Color Palette': document.getElementById('result-palette-card')
         };

        // --- Page Navigation ---
        function showPage(pageId) {
            activePage = pageId;
            pages.forEach(page => {
                page.classList.toggle('active', page.id === `${pageId}-page`);
            });
            navLinks.forEach(link => {
                 const linkPage = link.getAttribute('data-page');
                 if (link.classList.contains('logo') || (link.parentElement && link.parentElement.tagName === 'LI')) {
                     link.classList.toggle('active', linkPage === pageId);
                 }
            });
            window.scrollTo(0, 0);
             if (pageId !== 'feature') {
                 resultsOutputArea.style.display = 'none';
                 detailedResultsGrid.style.display = 'none';
                 conceptCard.style.display = 'none';
                 errorMessageDiv.style.display = 'none';
                 clearResultsContent();
             }
            console.log(`Navigated to: ${pageId}`);
        }

        // --- Loading Overlay Control ---
        function showLoading(messageKey = "generatingCreativeSparks", fallbackMessage = "Generating creative sparks...") {
             if (!loadingOverlay) return;
             const textElement = loadingOverlay.querySelector('p');
             if (textElement) {
                 const translatedMessage = getTranslatedText(textElement, messageKey, false, fallbackMessage);
                 textElement.textContent = translatedMessage;
                 textElement.dataset.lastKey = messageKey; // Store key for re-translation
             }
             loadingOverlay.classList.add('show');
             // Disable buttons
             if(generateConceptButton) generateConceptButton.disabled = true;
             if(generateRandomLyricButton) generateRandomLyricButton.disabled = true; // Disable new button too
             if(exploreMoreButton) exploreMoreButton.disabled = true;
             if(regenerateButton) regenerateButton.disabled = true;
             if(recordAudioButton) recordAudioButton.disabled = true;
        }
        function hideLoading() {
            if (!loadingOverlay) return;
            loadingOverlay.classList.remove('show');
             // Re-enable buttons (consider states)
             if(generateConceptButton) generateConceptButton.disabled = false;
             if(generateRandomLyricButton) generateRandomLyricButton.disabled = false; // Enable new button too
             if(exploreMoreButton) exploreMoreButton.disabled = !currentInputs;
             if(regenerateButton) regenerateButton.disabled = !currentInputs;
             if(recordAudioButton) {
                  recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported) || isRecording;
             }
        }

        // --- Microphone Recording & Speech Recognition Logic ---
         if (recordAudioButton) {
            recordAudioButton.addEventListener('click', handleRecordButtonClick);
            if (!navigator.mediaDevices?.getUserMedia) {
                updateRecordStatus('Audio recording not supported.', 'error', true, 'statusAudioNotSupported');
                recordAudioButton.disabled = true;
            } else if (!isSpeechRecognitionSupported) {
                updateRecordStatus('Speech recognition not supported.', 'error', true, 'statusSpeechRecNotSupported');
                recordAudioButton.disabled = true;
            }
        }

        async function handleRecordButtonClick() {
             if (!navigator.mediaDevices?.getUserMedia) { updateRecordStatus('Recording not supported by browser.', 'error', true, 'statusAudioNotSupported'); return; }
             if (!isSpeechRecognitionSupported) { updateRecordStatus('Speech recognition not supported.', 'error', true, 'statusSpeechRecNotSupported'); return; }

            if (!isRecording) { // Start Recording
                try {
                    recordedAudioBlob = null; trackUploadInput.value = ''; transcriptOutput.value = '';
                    finalTranscript = ''; transcriptGroup.style.display = 'none'; clearRecordStatus();
                    updateRecordStatus('Requesting mic access...', '', false, 'statusRequestingMic');
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    updateRecordStatus('', 'recording', false); // UI updated below

                    // MediaRecorder
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
                    mediaRecorder.onstop = () => {
                        recordedAudioBlob = (audioChunks.length > 0) ? new Blob(audioChunks, { type: 'audio/webm;codecs=opus' }) : null;
                        audioChunks = []; stream.getTracks().forEach(track => track.stop());
                        updateRecordingUI(false);
                        if (!recognition || !recognition.recognizing) { updateFinalRecordStatus(); }
                    };
                     mediaRecorder.onerror = (event) => {
                        console.error("MediaRecorder error:", event.error);
                        const errorMsg = getTranslatedText(null, 'statusRecordingError', false, `Recording error: ${event.error.name}`).replace('${errorName}', event.error.name);
                        updateRecordStatus(errorMsg, 'error', true);
                        if (recognition?.abort) { try { recognition.abort(); } catch(e){} }
                        stream.getTracks().forEach(track => track.stop()); updateRecordingUI(false);
                     };

                    // Speech Recognition
                    recognition = new SpeechRecognition();
                    recognition.continuous = true; recognition.interimResults = true;
                    const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' };
                    recognition.lang = bcp47Map[currentLang] || (currentLang.includes('-') ? currentLang : `${currentLang}-${currentLang.toUpperCase()}`);
                    console.log("SpeechRecognition language set to:", recognition.lang);

                    recognition.onresult = (event) => {
                        let interimTranscript = ''; finalTranscript = '';
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) { finalTranscript += event.results[i][0].transcript + ' '; }
                            else { interimTranscript += event.results[i][0].transcript; }
                        }
                        const currentFullTranscript = (finalTranscript + interimTranscript).trim();
                        transcriptOutput.value = currentFullTranscript;
                        if (currentFullTranscript) { transcriptGroup.style.display = 'block'; }
                         updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing');
                    };
                    recognition.onerror = (event) => {
                        console.error("Speech Recognition Error:", event.error, event.message);
                        let errorMsgKey = 'transcriptionErrorGeneric', errorParam = event.error;
                         if (event.error === 'no-speech') { errorMsgKey = 'transcriptionErrorNoSpeech'; errorParam = '';}
                         else if (event.error === 'audio-capture') { errorMsgKey = 'transcriptionErrorMicProblem'; errorParam = ''; }
                         else if (event.error === 'not-allowed') { errorMsgKey = 'transcriptionErrorPermission'; errorParam = '';}
                         else if (event.error === 'network') { errorMsgKey = 'transcriptionErrorNetwork'; errorParam = '';}
                         const translatedError = getTranslatedText(null, errorMsgKey, false, `Transcription error: ${errorParam}`);
                         if (!recordStatus?.classList.contains('error')) { updateRecordStatus(translatedError, 'error', true, errorMsgKey); }
                         if (mediaRecorder?.state === "recording" && event.error !== 'no-speech') { try { mediaRecorder.stop(); } catch(e){} }
                    };
                    recognition.onstart = () => { console.log("Speech recognition started."); updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing'); };
                    recognition.onend = () => {
                        console.log("Speech recognition ended."); finalTranscript = finalTranscript.trim();
                        transcriptOutput.value = finalTranscript;
                         if (!finalTranscript && transcriptGroup.style.display === 'block') { transcriptGroup.style.display = 'none'; }
                         if (!isRecording) { updateFinalRecordStatus(); }
                    };

                    // Start
                    audioChunks = []; mediaRecorder.start(); recognition.start(); updateRecordingUI(true);

                } catch (err) {
                    console.error("Error accessing microphone:", err);
                     let errorMsgKey = 'micErrorGeneric';
                     if (err.name === 'NotAllowedError') { errorMsgKey = 'micErrorPermission'; }
                     else if (err.name === 'NotFoundError') { errorMsgKey = 'micErrorNotFound'; }
                     else if (err.name === 'NotReadableError') { errorMsgKey = 'micErrorHardware'; }
                     updateRecordStatus(getTranslatedText(null, errorMsgKey, false, 'Microphone access error.'), 'error', true, errorMsgKey);
                    updateRecordingUI(false);
                }
            } else { // Stop Recording
                 if (mediaRecorder?.state === "recording") {
                    updateRecordStatus(getTranslatedText(null, 'statusStopping', false, 'Stopping...'), '', false, 'statusStopping');
                    try { mediaRecorder.stop(); } catch(e){}
                }
                if (recognition?.stop) {
                     try { recognition.stop(); }
                     catch (e) { if (!isRecording) { updateFinalRecordStatus(); } }
                } else if (!isRecording) { updateFinalRecordStatus(); }
            }
        }

         function updateFinalRecordStatus() {
             setTimeout(() => {
                  if (recordStatus?.classList.contains('error')) return; // Don't overwrite error
                  let finalStatusMsgKey = 'stoppedStatus', finalStatusClass = '', isPersistent = false;
                  if (recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'recordTranscriptComplete'; finalStatusClass = 'complete'; isPersistent = true; }
                  else if (recordedAudioBlob && !finalTranscript) { finalStatusMsgKey = 'recordCompleteNoTranscript'; finalStatusClass = 'complete'; isPersistent = true; }
                  else if (!recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'transcriptCompleteNoRecord'; finalStatusClass = 'complete'; isPersistent = true; }
                  updateRecordStatus(getTranslatedText(null, finalStatusMsgKey, false, 'Stopped.'), finalStatusClass, isPersistent, finalStatusMsgKey);
             }, 100);
         }

        function updateRecordingUI(recording) {
            if (!recordAudioButton) return; isRecording = recording;
            const recordKey = 'record', stopKey = 'stop';
            // Get translated text based on recording state using data attributes
            const buttonText = recording
                 ? (recordAudioButton.dataset[formatDatasetKey(currentLang, stopKey)] || recordAudioButton.dataset[formatDatasetKey('en', stopKey)] || 'Stop Recording')
                 : (recordAudioButton.dataset[formatDatasetKey(currentLang, recordKey)] || recordAudioButton.dataset[formatDatasetKey('en', recordKey)] || 'Record Audio');

            recordAudioButton.textContent = buttonText; recordAudioButton.disabled = false;
            if (recording) {
                recordAudioButton.classList.remove('btn-warning'); recordAudioButton.classList.add('btn-danger');
                if(recordingAnimation) recordingAnimation.style.display = 'inline-block';
                 updateRecordStatus(getTranslatedText(null, 'statusRecording', false, 'Recording...'), 'recording', false, 'statusRecording');
            } else {
                recordAudioButton.classList.remove('btn-danger'); recordAudioButton.classList.add('btn-warning');
                if(recordingAnimation) recordingAnimation.style.display = 'none';
                recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported);
            }
         }

        function updateRecordStatus(message, statusClass = '', persistent = false, translationKey = '') {
            if (!recordStatus || !recordStatusText || !recordingAnimation) return;
             if (updateRecordStatus.timeoutId) { clearTimeout(updateRecordStatus.timeoutId); updateRecordStatus.timeoutId = null; }
             // Get the potentially translated message based on the key first
             const displayMessage = translationKey ? getTranslatedText(null, translationKey, false, message) : message;
            recordStatusText.textContent = displayMessage;
            recordStatus.className = 'record-status-base'; // Reset
            recordStatus.dataset.statusKey = translationKey; // Store key for re-translation
            recordStatus.dataset.statusFallback = message; // Store original fallback for safety
            if (statusClass) recordStatus.classList.add(statusClass);
            recordingAnimation.style.display = (statusClass === 'recording' || statusClass === 'transcribing') ? 'inline-block' : 'none';
            if (!persistent && statusClass !== 'error' && displayMessage) {
                updateRecordStatus.timeoutId = setTimeout(() => {
                     // Only clear if the message/key hasn't changed (prevents clearing a new status)
                     if (recordStatusText.textContent === displayMessage && recordStatus.dataset.statusKey === translationKey) { clearRecordStatus(); }
                }, 4000);
            }
         }
         updateRecordStatus.timeoutId = null;

         function clearRecordStatus() {
            if (recordStatusText) recordStatusText.textContent = '';
            if (recordStatus) { recordStatus.className = 'record-status-base'; delete recordStatus.dataset.statusKey; delete recordStatus.dataset.statusFallback; }
            if (recordingAnimation) recordingAnimation.style.display = 'none';
            if (updateRecordStatus.timeoutId) { clearTimeout(updateRecordStatus.timeoutId); updateRecordStatus.timeoutId = null; }
         }

        if(trackUploadInput) {
             trackUploadInput.addEventListener('change', () => {
                 if (trackUploadInput.files.length > 0) {
                     if (isRecording) {
                         if (mediaRecorder?.state === "recording") try { mediaRecorder.stop(); } catch(e){}
                         if (recognition?.abort) try { recognition.abort(); } catch(e){}
                         updateRecordingUI(false);
                     }
                     recordedAudioBlob = null; transcriptOutput.value = ''; finalTranscript = '';
                     transcriptGroup.style.display = 'none';
                     updateRecordStatus(getTranslatedText(null, 'statusFileSelected', false, 'File selected.'), 'complete', true, 'statusFileSelected');
                     console.log("File selected, cleared recording state.");
                 }
             });
        }

        // --- Gemini API Call Helper ---
        async function callGeminiAPI(promptText, loadingMessageKey = "generatingCreativeSparks", loadingFallback = "Generating...") {
            // --- !!! SECURITY WARNING: API KEY HARDCODED IN FRONTEND !!! ---
            // This key is exposed. For production, use a backend proxy.
            const GEMINI_API_KEY = "AIzaSyB5c-hp-QeKBpBTz8qwANe4j5Kc4dZ_bWM"; // <-- VERY INSECURE
            // --- !!! END SECURITY WARNING !!! ---

            if (!GEMINI_API_KEY || GEMINI_API_KEY.startsWith("YOUR_") || GEMINI_API_KEY.length < 30) {
                 displayError(getTranslatedText(null, 'errorApiKeyInvalid', false, "API Key is missing or invalid. Configure it securely (backend recommended)."), 'errorApiKeyInvalid');
                 return null;
            }
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
            showLoading(loadingMessageKey, loadingFallback);

            const requestBody = {
                contents: [{ parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.75, maxOutputTokens: 4096 },
                safetySettings: [ /* Standard safety settings */
                   { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                ]
            };

            try {
                console.log("Sending API request to Gemini...");
                const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                const responseData = await response.json();
                console.log("Raw API Response (Gemini):", responseData);

                if (!response.ok) {
                     const errorDetail = responseData?.error?.message || `HTTP Error: ${response.status}`;
                     const httpErrorMsg = getTranslatedText(null, 'errorApiHttp', false, `API request failed: ${errorDetail}`).replace('${errorDetail}', errorDetail);
                     if (response.status === 0) { // Often indicates a CORS block
                        throw new Error(getTranslatedText(null, 'errorCorsOrNetwork', false, 'Network or CORS error contacting Gemini API. Check console & consider backend proxy.'));
                     }
                     throw new Error(httpErrorMsg);
                }
                 const candidate = responseData?.candidates?.[0];
                 if (!candidate || responseData?.promptFeedback?.blockReason || candidate.finishReason === "SAFETY") {
                     const reason = candidate?.finishReason || responseData?.promptFeedback?.blockReason || "Unknown Safety Block";
                     const blockMessage = getTranslatedText(null, 'errorApiBlocked', false, `Content blocked due to safety filters (Reason: ${reason}). Please revise your input.`)
                                           .replace('${reason}', reason);
                     throw new Error(blockMessage);
                 }
                 if (responseData?.error) {
                     const apiErrorMsg = getTranslatedText(null, 'errorApiGeneral', false, `API returned an error: ${responseData.error.message}`).replace('${errorMessage}', responseData.error.message);
                     throw new Error(apiErrorMsg);
                 }

                 const finishReason = candidate.finishReason;
                 if (finishReason && !["STOP", "MAX_TOKENS"].includes(finishReason)) {
                     console.warn(`Gemini generation finished abnormally. Reason: ${finishReason}`);
                 }
                 if (finishReason === "MAX_TOKENS") { console.warn("Gemini generation stopped due to maximum token limit."); }

                 if (candidate?.content?.parts?.[0]?.text) {
                     return candidate.content.parts[0].text.trim();
                 } else {
                     throw new Error(getTranslatedText(null, 'errorApiEmptyResponse', false, "Received an unexpected or empty text response from the AI."));
                 }

            } catch (error) {
                console.error("Error during Gemini fetch or processing:", error);
                // Determine Error Key from Message
                 let errorKey = 'errorUnknown';
                 const msg = String(error.message).toLowerCase();
                 if (msg.includes("api key") || msg.includes("invalid")) errorKey = 'errorApiKeyInvalid';
                 else if (msg.includes("http error")) errorKey = 'errorApiHttp';
                 else if (msg.includes("blocked") || msg.includes("safety filter")) errorKey = 'errorApiBlocked';
                 else if (msg.includes("api returned an error")) errorKey = 'errorApiGeneral';
                 else if (msg.includes("no response candidate")) errorKey = 'errorApiNoCandidate';
                 else if (msg.includes("empty text response")) errorKey = 'errorApiEmptyResponse';
                 else if (msg.includes('failed to fetch') || msg.includes('networkerror') || msg.includes('cors')) errorKey = 'errorCorsOrNetwork';
                 displayError(error.message, errorKey);
                 return null;
            } finally {
                hideLoading();
            }
        }

         // --- NEW: Generate Random Lyrics ---
         async function handleGenerateRandomLyrics() {
            clearResultsAndErrors(); // Clear any previous results/errors

            const prompt = `
Generate a random short song lyric suitable for pop, RnB, or folk music.
The lyrics should have a clear structure with labels like [Intro], [Verse 1], [Chorus], [Verse 2], [Chorus], [Bridge], [Outro].
Include at least 10 sentences in total across all sections.
Each sentence should be on its own line.
Output *only* the lyrics with the structure labels, nothing else. Example:
[Intro]
Sunlight on the pavement
Another day begins

[Verse 1]
Walking down this empty street
Thinking 'bout the place we meet
Empty coffee cup in hand
Trying hard to understand

[Chorus]
Where did we go wrong?
Was our love not strong?
Echoes of our favorite song
Fade out before too long

[Outro]
Just echoes now...
Fading out...
`;
            const loadingMsgKey = "generatingLyrics";
            const loadingFallback = "Generating Random Lyrics...";
            const generatedText = await callGeminiAPI(prompt, loadingMsgKey, loadingFallback);

            if (generatedText && lyricsInput) {
                // Basic cleanup - remove potential leading/trailing markdown/code blocks
                let cleanedLyrics = generatedText.replace(/^```(text|lyric)?\s*/i, '').replace(/```\s*$/i, '');
                lyricsInput.value = cleanedLyrics.trim();
                lyricsInput.focus(); // Focus on the input box
                lyricsInput.scrollTop = 0; // Scroll to top
                 // Optionally, you could try to pre-fill keywords based on lyrics, but let's keep it simple
                 // keywordsInput.value = "Generated lyrics theme";
                 // genreSelect.value = "Pop"; // Or guess genre?

                 // Display a temporary success message (optional)
                 updateRecordStatus(getTranslatedText(null, 'randomLyricsGenerated', false, 'Random lyrics generated!'), 'complete', false, 'randomLyricsGenerated'); // Use record status temporarily
            } else if (!generatedText) {
                 // Error was already displayed by callGeminiAPI
            }
        }

        // --- Generate Initial Concept ---
        async function handleGenerateConcept() {
            const lyrics = lyricsInput.value.trim();
            const keywords = keywordsInput.value.trim();
            const selectedGenre = genreSelect.value;
            const singingTranscript = transcriptOutput.value.trim();

             // Validation
             let validationError = false, errorMsg = '', errorKey = '', focusEl = null;
             if (!lyrics) { errorMsg = getTranslatedText(lyricsInput, 'placeholder', true) || "Provide lyrics."; errorKey = 'validationLyricsMissing'; focusEl = lyricsInput; validationError = true; }
             else if (!keywords) { errorMsg = getTranslatedText(keywordsInput, 'placeholder', true) || "Provide keywords."; errorKey = 'validationKeywordsMissing'; focusEl = keywordsInput; validationError = true; }
             else if (!selectedGenre) { errorMsg = getTranslatedText(genreSelect.options[0]) || "Select genre."; errorKey = 'validationGenreMissing'; focusEl = genreSelect; validationError = true; }
             if(validationError) { displayError(errorMsg, errorKey); focusEl?.focus(); return; }

            currentInputs = { lyrics, keywords, selectedGenre, singingTranscript };
            clearResultsAndErrors();

            // Prompt for ONLY Concept
             const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Analyze the following song details:
**Lyrics:**\n\`\`\`\n${lyrics}\n\`\`\`${singingTranscript ? `\n**Singing Transcript (Optional Context):**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}\n**Music Genre:** ${selectedGenre}
Generate **ONLY** the "Concept / Key Visual" section for a music video based on these details. Structure your response *exactly* like this, starting directly with the header and providing content below it in well-written English:
## Concept / Key Visual
(Provide a concise, compelling core concept description here. Mention 1-2 key visual motifs or scenes.)`;

            const loadingMsgKey = "generatingConcept";
            const loadingFallback = "Generating Concept...";
            // !!! Consider changing this to call a backend proxy /api/generate-concept !!!
            const generatedText = await callGeminiAPI(prompt, loadingMsgKey, loadingFallback);

            if (generatedText) {
                resultsOutputArea.style.display = 'block';
                conceptCard.style.display = 'flex';
                detailedResultsGrid.style.display = 'none';
                const conceptContentDiv = document.getElementById('result-concept');
                 if (conceptContentDiv) { conceptContentDiv.innerHTML = ''; conceptContentDiv.classList.remove('placeholder-notice'); }
                parseAndDisplayResults(generatedText); // Populates concept card
                conceptCard.style.transitionDelay = '0s'; conceptCard.classList.add('visible'); // Animate
                 if(exploreMoreButton) exploreMoreButton.disabled = false;
                 if(regenerateButton) regenerateButton.disabled = false;
                 setTimeout(() => { resultsOutputArea.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);
            }
        }

        // --- Explore More Details ---
        async function handleExploreMore() {
            if (!currentInputs) { displayError(getTranslatedText(null, 'errorExploreNoConcept', false, "Generate concept first."), 'errorExploreNoConcept'); return; }
            if(exploreMoreButton) exploreMoreButton.disabled = true;
            if(regenerateButton) regenerateButton.disabled = true;

            // --- <<< UPDATED Prompt for Detailed Results (including budget format and image section name) >>> ---
            const { lyrics, keywords, selectedGenre, singingTranscript } = currentInputs;
            const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Based on the original song details:
**Lyrics:**\n\`\`\`\n${lyrics}\n\`\`\`${singingTranscript ? `\n**Singing Transcript (Optional Context):**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}\n**Music Genre:** ${selectedGenre}
Provide the **remaining detailed sections** (excluding 'Concept / Key Visual'). Structure *exactly* like this in English:

## Requirements for MV
(* or - list item: Detail about location, casting, props, wardrobe, cinematography, VFX, editing style, etc.)

## Estimated Budget
(**Low Budget:** ~$Range (Optional). Description of approach.
- Example Item - $Cost (Optional, list a few key cost drivers if applicable)

**Mid Budget:** ~$Range (Optional). Description of approach, potentially scaling up elements from Low.
- Example Item - $Cost

**High Budget:** ~$Range (Optional). Description of approach, allowing for higher production value.
- Example Item - $Cost
)

## Visual Demo (Key Images)
(1. Vivid description of a key scene or visual moment suitable for image generation.
2. Another vivid description for image generation.
3. A third vivid description for image generation.)

## Moodboard Influences
(A short sentence describing the overall mood and visual style.
* Specific visual element or reference suitable for image generation (e.g., Film noir lighting, rainy cityscape).
* Another specific element for image generation (e.g., Wes Anderson symmetrical composition, pastel diner).
* Style reference for image generation (e.g., Surrealist painting style, dreamlike forest).
* Color influence (e.g., Muted pastels).
* Textural element (e.g., Grainy film stock).
)

## Color Palette
(Strictly format: Color Name (#XXXXXX), Another Color (#XXXXXX), ...)

Adhere strictly to the format: Use the exact headers (##), use bullet points (* or -) for Requirements and Moodboard lists, use numbering (1., 2., 3.) for Visual Demo, use the bold format **Level Budget:** for budget tiers, and the exact comma-separated Name (#XXXXXX) format for colors. Provide detailed, relevant content for each section based on the song inputs. Use plausible USD ($) ranges for budget tiers (e.g., ~$1k-5k, ~$10k-30k, ~$50k+). Ensure Visual Demo and Moodboard list items are descriptive image prompts.`;

            const loadingMsgKey = "fetchingDetails";
            const loadingFallback = "Fetching More Details...";
             // !!! Consider changing this to call a backend proxy /api/generate-concept !!!
            const generatedText = await callGeminiAPI(prompt, loadingMsgKey, loadingFallback);

            if (generatedText) {
                 clearDetailedResultsContentOnly(); // Clear placeholders
                 parseAndDisplayResults(generatedText); // Populate detail cards
                 detailedResultsGrid.style.display = 'grid'; // Show the grid

                 // Animate cards in
                 const detailCards = detailedResultsGrid.querySelectorAll('.result-card');
                 detailCards.forEach((card, index) => {
                     const contentDiv = card.querySelector('.card-content');
                     const hasRealContent = contentDiv && !contentDiv.classList.contains('placeholder-notice') && contentDiv.innerHTML.trim() !== '' && !contentDiv.querySelector('.placeholder-notice');
                     // Only apply animation delay if the card is meant to be shown and has real content
                     if (card.style.display === 'flex' && hasRealContent) {
                         card.style.transitionDelay = `${index * 0.1}s`;
                         card.classList.add('visible');
                     } else if (card.style.display === 'flex') { // Show immediately if only placeholder/error
                         card.style.opacity = 1;
                         card.style.transform = 'translateY(0)';
                         card.classList.remove('visible'); // Ensure visible class isn't stuck if no animation
                     }
                 });
                 // Scroll to new cards
                  setTimeout(() => {
                    const firstDetailCard = detailedResultsGrid.querySelector('.result-card[style*="display: flex"]');
                    (firstDetailCard || detailedResultsGrid).scrollIntoView({ behavior: 'smooth', block: 'start' });
                  }, 150);
                 if (regenerateButton) regenerateButton.disabled = false; // Keep explore disabled, enable regenerate
            } else {
                 // Buttons re-enabled by hideLoading if API failed
                 if (exploreMoreButton) exploreMoreButton.disabled = false; // Re-enable explore on failure
                 if (regenerateButton) regenerateButton.disabled = currentInputs ? false : true;
            }
        }

        // --- Re-Generate Concept ---
        function handleRegenerateConcept() {
            clearResultsAndErrors();
            handleGenerateConcept(); // Restart the process
        }

        // --- Parsing and Displaying Results ---
        function parseAndDisplayResults(text) {
            console.log("Parsing AI response...");
            const lines = text.split('\n');
            let currentSectionKey = null; let contentBuffer = '';
            let foundAnySection = false; const processedSections = new Set();

            // Hide all detail cards initially (except concept if it's already shown)
             Object.values(cardElements).forEach(card => { if (card !== conceptCard) card.style.display = 'none'; });

            lines.forEach(line => {
                let matchedHeader = false;
                for (const title in sections) {
                    // Make regex more robust to handle slight variations in spacing or markdown emphasis
                    // Escape regex special chars, handle optional bolding/italics around title
                    const escapedTitle = title.trim().replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const headerRegex = new RegExp(`^\\s*##\\s*\\*?\\*?${escapedTitle}\\*?\\*?\\s*$`, 'i');
                    if (headerRegex.test(line.trim())) {
                        if (currentSectionKey && contentBuffer.trim()) {
                            const targetElementId = sections[currentSectionKey]; const targetCard = cardElements[currentSectionKey];
                            if (targetElementId && targetCard) {
                                try { processSectionContent(targetElementId, currentSectionKey, contentBuffer.trim()); processedSections.add(currentSectionKey); foundAnySection = true; }
                                catch (processError) { handleProcessingError(targetElementId, targetCard, currentSectionKey, processError); processedSections.add(currentSectionKey); }
                            }
                        }
                        currentSectionKey = title; contentBuffer = ''; matchedHeader = true; console.log(`--- Found Header: ${currentSectionKey} ---`); break;
                    }
                }
                if (!matchedHeader && currentSectionKey) { contentBuffer += line + '\n'; }
            });

            // Process last section
            if (currentSectionKey && contentBuffer.trim()) {
                 const targetElementId = sections[currentSectionKey]; const targetCard = cardElements[currentSectionKey];
                 if (targetElementId && targetCard) {
                     try { processSectionContent(targetElementId, currentSectionKey, contentBuffer.trim()); processedSections.add(currentSectionKey); foundAnySection = true; }
                     catch (processError) { handleProcessingError(targetElementId, targetCard, currentSectionKey, processError); processedSections.add(currentSectionKey); }
                 }
            }

             // Check for missing sections if details were requested
             const detailsRequested = detailedResultsGrid.style.display === 'grid' || // If grid is already shown
                                       (exploreMoreButton && exploreMoreButton.disabled && !regenerateButton?.disabled); // Or if explore was just clicked

            if (detailsRequested) {
                 Object.keys(sections).forEach(sectionTitle => {
                    // Skip concept check, also skip checking alternate visual title if the primary one was processed
                    if (sectionTitle === 'Concept / Key Visual') return;
                    if (sectionTitle === 'Visual Demo (Key Image Descriptions)' && processedSections.has('Visual Demo (Key Images)')) return;
                    if (sectionTitle === 'Visual Demo (Key Images)' && processedSections.has('Visual Demo (Key Image Descriptions)')) return;

                    if (!processedSections.has(sectionTitle)) {
                         const targetElementId = sections[sectionTitle]; const targetCard = cardElements[sectionTitle];
                         const contentDiv = document.getElementById(targetElementId);
                         if (targetCard && contentDiv) {
                             console.warn(`Section "${sectionTitle}" not found in response. Displaying placeholder.`);
                             setPlaceholderForMissingSection(contentDiv, sectionTitle);
                             targetCard.style.display = 'flex'; // Show card with placeholder
                         }
                     }
                 });
            }

            if (!foundAnySection && text.trim()) {
                 // Avoid showing parse error if only concept was requested and received successfully
                 const onlyConceptRequested = exploreMoreButton && !exploreMoreButton.disabled;
                 const conceptWasProcessed = processedSections.has('Concept / Key Visual');

                 if (!(onlyConceptRequested && conceptWasProcessed)) {
                    displayError(getTranslatedText(null, 'errorParsingFailed', false, "Could not parse expected sections. Check AI response format. Raw output logged."), 'errorParsingFailed');
                    console.warn("Raw AI Response Text (Parsing Failed):\n", text);
                 } else {
                    console.log("Concept processed, other sections not requested yet or not found in initial response.");
                 }
            } else if (foundAnySection) {
                 console.log("Parsing complete."); errorMessageDiv.style.display = 'none';
            } else {
                 console.log("No sections found or text empty.");
                 // Avoid error if only generating lyrics (not expecting sections)
                 if (loadingOverlay.querySelector('p')?.dataset?.lastKey !== 'generatingLyrics') {
                    displayError(getTranslatedText(null, 'errorApiEmptyResponse', false, "Received empty response."), 'errorApiEmptyResponse');
                    resultsOutputArea.style.display = 'none';
                 }
            }
        }

        // Helper for handling errors during section processing
        function handleProcessingError(targetElementId, targetCard, sectionKey, error) {
             console.error(`Error processing section "${sectionKey}":`, error);
              const contentDiv = document.getElementById(targetElementId);
             if (contentDiv) {
                  contentDiv.innerHTML = `<p class="placeholder-notice error">${getTranslatedText(null, 'errorDisplayingSection', false, 'Error displaying section.')}</p>`;
                  contentDiv.classList.add('placeholder-notice');
                  if (targetCard) targetCard.style.display = 'flex';
             }
        }

        // --- Process Individual Section Content ---
        function processSectionContent(elementId, sectionTitle, content) {
            const contentDiv = document.getElementById(elementId);
            if (!contentDiv) { console.error(`Content div not found: ${elementId}`); return; }
             contentDiv.innerHTML = ''; contentDiv.classList.remove('placeholder-notice');
             const parentCard = contentDiv.closest('.result-card');
             if (!parentCard) { console.error(`Parent card not found for ${elementId}`); return; }
             let sectionHasContent = false;

            try {
                console.log(`Processing Section: ${sectionTitle} into #${elementId}`);
                // Handle both possible visual demo section titles
                if (sectionTitle === 'Visual Demo (Key Image Descriptions)' || sectionTitle === 'Visual Demo (Key Images)') {
                     const container = document.createElement('div'); container.className = 'image-placeholder-container'; contentDiv.appendChild(container);
                     // Regex tries to capture numbered list items more reliably
                     const descs = content.split(/^\s*[1-9][0-9]*[\.\)\-]\s+/gm).filter(Boolean).map(d => d.trim().replace(/\n$/, ''));
                     if (descs.length > 0) {
                        descs.slice(0, 3).forEach((d, i) => { if(d) { createImagePlaceholder(container, d, `v-${i}`); sectionHasContent = true; } }); // Call BACKEND version
                    }
                     if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noVisualsFound', false, 'No visuals found.')}</p>`; container.classList.add('placeholder-notice'); }
                     // Add note below container
                     const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                     note.dataset.langEn = "Illustrative images based on descriptions."; note.dataset.placeholderKey="visualsNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);

                } else if (sectionTitle === 'Moodboard Influences') {
                     const descEl = document.createElement('p'); descEl.id = 'moodboard-description'; contentDiv.appendChild(descEl);
                     const imgContainer = document.createElement('div'); imgContainer.className = 'image-placeholder-container'; imgContainer.id = 'moodboard-images'; contentDiv.appendChild(imgContainer);
                     const lines = content.trim().split('\n'); let mainDesc = '', items = []; let readingDesc = true;
                     for (const line of lines) { const trimmed = line.trim(); if (trimmed.match(/^[\*\-]\s+/)) { readingDesc = false; items.push(trimmed.replace(/^[\*\-]\s+/, '').trim()); } else if (readingDesc && trimmed) { mainDesc += line + '\n'; } else if (!readingDesc && trimmed && items.length > 0) { items[items.length - 1] += '\n' + trimmed; } }
                     mainDesc = mainDesc.trim(); items = items.filter(Boolean);
                     if (mainDesc) { descEl.innerHTML = mainDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); descEl.style.display = 'block'; descEl.classList.remove('placeholder-notice'); sectionHasContent = true; }
                     else { descEl.innerHTML = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Desc...'); descEl.style.display = 'block'; descEl.classList.add('placeholder-notice'); descEl.dataset.placeholderKey="moodboardDescPlaceholder"; }
                     if (items.length > 0) { imgContainer.innerHTML = ''; imgContainer.classList.remove('placeholder-notice'); items.slice(0, 5).forEach((d, i) => { if(d) { createImagePlaceholder(imgContainer, d, `m-${i}`); sectionHasContent = true; } }); } // Call BACKEND version
                     else { imgContainer.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'noMoodboardItemsFound', false, 'No items...')}</p>`; imgContainer.classList.add('placeholder-notice'); }

                     if (sectionHasContent) {
                         const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                         note.dataset.langEn = "Visual styles for inspiration."; note.dataset.placeholderKey="moodboardNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);
                     } else {
                        // Only show placeholders if BOTH description and items are missing
                        if (!mainDesc && items.length === 0) {
                            contentDiv.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardDescPlaceholder">${getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Description missing.')}</p><div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'Images missing.')}</p></div>`; contentDiv.classList.add('placeholder-notice');
                        } else {
                             // If one part exists, keep it and add the note
                             const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                             note.dataset.langEn = "Visual styles for inspiration."; note.dataset.placeholderKey="moodboardNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);
                        }
                     }

                // --- <<< START: Budget Section Processing (Using robust Regex) >>> ---
                } else if (sectionTitle === 'Estimated Budget') {
                     let container = contentDiv.querySelector('.budget-columns-container');
                     if (!container) {
                         container = document.createElement('div'); container.className = 'budget-columns-container'; contentDiv.appendChild(container);
                     } else { container.innerHTML = ''; } // Clear previous content if reusing
                     container.classList.remove('placeholder-notice'); // Assume content unless proven otherwise

                     // Regex to find **Level Budget:** and capture content until the next level or end of string
                     const budgetRegex = /\*\*(Low\s*Budget|Mid\s*Budget|High\s*Budget)\*\*\s*:?\s*([\s\S]*?)(?=\n?\s*\*\*(?:Low|Mid|High)\s*Budget\*\*|$)/gi;
                     const budgetLevels = {}; let match; let parsingSuccess = false;

                     while ((match = budgetRegex.exec(content)) !== null) {
                         parsingSuccess = true;
                         const levelTitle = match[1].replace(/\s+/g, ' ').trim(); // Normalize spacing
                         const levelKey = levelTitle.split(' ')[0]; // "Low", "Mid", "High"
                         let rawContent = match[2].trim();
                         let range = ''; let description = '';

                         // Try to extract range like ~$Xk-Yk or ~$Zk+ or $W
                         const rangePatterns = [
                            /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*[-–—]\s*[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*USD|EUR|GBP)?/i, // Range X-Y
                            /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*\+(?:\s*USD|EUR|GBP)?/i, // Minimum Z+
                            /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*USD|EUR|GBP)?/i // Single value W
                         ];
                         // Match the pattern ONLY at the beginning of the rawContent, possibly wrapped in ()
                         for (const pattern of rangePatterns) {
                              const rangeMatch = rawContent.match(new RegExp(`^\\s*\\(?(${pattern.source})\\)?\\s*`, 'i'));
                              if (rangeMatch) {
                                  range = rangeMatch[1].trim(); // Capture the range part
                                  description = rawContent.substring(rangeMatch[0].length).trim(); // The rest is description
                                  break;
                              }
                         }
                         if (!range) { description = rawContent; } // If no range matched, assume all is description

                         budgetLevels[levelKey] = { title: levelTitle, range: range, description: description };
                         console.log(`Parsed Budget Level: ${levelKey}, Range: ${range || 'N/A'}, Desc Start: ${description.substring(0,50)}...`);
                     }

                     const order = ["Low", "Mid", "High"]; let anyColumnHasContent = false;

                     order.forEach(levelKey => {
                         const colDiv = document.createElement('div'); colDiv.className = 'budget-column';
                         const titleH3 = document.createElement('h3'); const descP = document.createElement('p');

                         if (budgetLevels[levelKey]) {
                             const data = budgetLevels[levelKey];
                             titleH3.textContent = data.title + (data.range ? ` (${data.range})` : ''); // Add range to title

                             let processedDesc = data.description;
                             // Regex for items like "- Item Name - $Cost" or "* Item - Cost range"
                             const itemCostRegex = /^\s*[-*]\s*(.+?)\s*[-–—:]\s*([\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*[-–—]\s*[\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b)?(?:\s*USD|\s*EUR|\s*GBP)?)\s*$/gm;
                             let itemBoxesHTML = '';
                             // Replace list items with boxes and remove them from the main description
                             processedDesc = processedDesc.replace(itemCostRegex, (matchStr, item, cost) => {
                                 itemBoxesHTML += `<div class="budget-item-box">${item.trim()}: <strong>${cost.trim()}</strong></div>`;
                                 return ''; // Remove the line from the description
                             }).trim();

                             // Basic formatting for the remaining description text
                             processedDesc = processedDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                             processedDesc = processedDesc.replace(/\n/g, '<br>'); // Keep line breaks
                             descP.innerHTML = processedDesc + itemBoxesHTML; // Append item boxes after desc

                             if(descP.innerHTML.trim() === ''){
                                descP.innerHTML = `(${getTranslatedText(null, 'budgetDetailsMissing', false, 'Details missing')})`;
                                descP.classList.add('placeholder-notice');
                             } else {
                                anyColumnHasContent = true; // Mark if we have actual content
                             }

                         } else { // Level not found by Regex
                             titleH3.textContent = getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`);
                             descP.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`;
                             descP.classList.add('placeholder-notice');
                             colDiv.classList.add('placeholder-notice'); // Style the column as placeholder
                         }
                         colDiv.appendChild(titleH3); colDiv.appendChild(descP); container.appendChild(colDiv);
                     });

                      // Fallback: If Regex found nothing but there *was* text content from AI
                      if (!parsingSuccess && content.trim()) {
                         container.innerHTML = `<pre>${content}</pre>`; // Show raw text in pre tag
                         container.classList.add('raw-budget-output'); // Add class for styling pre
                         container.classList.add('placeholder-notice'); // Style container holding pre
                         console.warn("Budget parsing failed, displaying raw content.");
                      } else if (!anyColumnHasContent && !parsingSuccess) { // No sections found AND content was empty/irrelevant
                         container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noBudgetContentFound', false, 'No budget details provided.')}</p>`;
                         container.classList.add('placeholder-notice');
                      } else {
                          sectionHasContent = true; // Mark section as having content if parsing was successful or columns were generated
                      }

                      // Ensure the budget note is present
                      let note = contentDiv.querySelector('small');
                      if (!note) {
                          note = document.createElement('small');
                          note.dataset.langEn = "Note: Budgets are conceptual estimates..."; note.dataset.placeholderKey="budgetNotePlaceholder";
                          contentDiv.appendChild(note);
                      }
                      note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;";
                      note.textContent = getTranslatedText(note, '', false, note.dataset.langEn);
                // --- <<< END: Budget Section Processing >>> ---

                } else if (sectionTitle === 'Requirements for MV') {
                    const listEl = document.createElement('ul'); contentDiv.appendChild(listEl);
                    const items = content.trim().split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(item => item.trim().replace(/\n$/, ''));
                    if (items.length > 0) { items.forEach(item => { const li = document.createElement('li'); li.innerHTML = item.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); listEl.appendChild(li); }); sectionHasContent = true; }
                    else { listEl.innerHTML = `<li class="placeholder-notice" data-placeholder-key="requirementsPlaceholder">${getTranslatedText(null, 'noRequirementsFound', false, 'No requirements listed.')}.</li>`; listEl.classList.add('placeholder-notice'); }

                } else if (sectionTitle === 'Color Palette') {
                     const container = document.createElement('div'); container.className = 'color-palette-display'; contentDiv.appendChild(container);
                     sectionHasContent = createColorSwatches(container, content.trim());
                     if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice" data-placeholder-key="palettePlaceholder">${getTranslatedText(null, 'noColorsFound', false, 'Could not parse colors.')}</p>`; container.classList.add('placeholder-notice'); }

                } else { // Default (e.g., Concept)
                     // Use innerHTML to render potential <strong> tags from the AI
                     const processedContent = content.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
                     contentDiv.innerHTML = processedContent; // Directly set HTML
                     if (processedContent) sectionHasContent = true;
                }

                 if (!sectionHasContent && contentDiv.innerHTML.trim() === '') {
                    // Add a generic placeholder if processing resulted in nothing
                    contentDiv.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Content not available.')}</p>`;
                    contentDiv.classList.add('placeholder-notice');
                 }
                 parentCard.style.display = 'flex'; // Show card after processing

            } catch (error) {
                handleProcessingError(elementId, parentCard, sectionTitle, error);
            }
        }

         // --- Helper to set placeholders in cards for sections MISSING from AI response ---
         function setPlaceholderForMissingSection(contentDiv, sectionTitle) {
             if (!contentDiv) return;
             contentDiv.innerHTML = ''; // Clear existing content
             contentDiv.classList.add('placeholder-notice'); // Mark as placeholder container
             let placeholderKey = 'placeholderGeneric', fallbackText = 'Content missing.', placeholderHTML = '';

             switch (sectionTitle) {
                 case 'Requirements for MV':
                     placeholderKey = 'requirementsPlaceholder'; fallbackText = 'Requirements list...';
                     placeholderHTML = `<ul class="placeholder-notice"><li class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</li></ul>`;
                     break;
                 case 'Estimated Budget':
                     placeholderKey = 'budgetPlaceholder'; fallbackText = 'Budget details...';
                     const noteText = getTranslatedText(null, 'budgetNotePlaceholder', false, 'Note: Budgets are conceptual estimates...');
                     placeholderHTML = `<div class="budget-columns-container placeholder-notice">`; // Add placeholder class here too
                      placeholderHTML += `<p data-placeholder-key="${placeholderKey}" class="placeholder-notice">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
                     // ["Low", "Mid", "High"].forEach(levelKey => { // Keep columns structure for layout consistency maybe? Or just single text? Let's try single text for simplicity on error.
                     //    placeholderHTML += `<div class="budget-column placeholder-notice">
                     //                            <h3>${getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`)}</h3>
                     //                            <p class="placeholder-notice" data-placeholder-key="budgetDetailsMissing">(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})</p>
                     //                        </div>`;
                     // });
                     placeholderHTML += `</div><small data-placeholder-key="budgetNotePlaceholder" style="display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;">${noteText}</small>`;
                     break;
                 case 'Visual Demo (Key Image Descriptions)': // Fallthrough
                 case 'Visual Demo (Key Images)':
                     placeholderKey = 'visualsPlaceholder'; fallbackText = 'Visual descriptions...'; const visualsNote = getTranslatedText(null, 'visualsNotePlaceholder', false,'Illustrative images...');
                     placeholderHTML = `<div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div><small data-placeholder-key="visualsNotePlaceholder">${visualsNote}</small>`;
                     break;
                 case 'Moodboard Influences':
                     const moodDesc = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Moodboard description...'); const moodImgs = getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'Moodboard images...'); const moodNote = getTranslatedText(null, 'moodboardNotePlaceholder', false,'Visual styles...');
                     placeholderHTML = `<p data-placeholder-key="moodboardDescPlaceholder" id="moodboard-description" class="placeholder-notice">${moodDesc}</p><div class="image-placeholder-container placeholder-notice" id="moodboard-images"><p data-placeholder-key="moodboardImgsPlaceholder">${moodImgs}</p></div><small data-placeholder-key="moodboardNotePlaceholder">${moodNote}</small>`;
                     break;
                 case 'Color Palette':
                     placeholderKey = 'palettePlaceholder'; fallbackText = 'Color palette...';
                     placeholderHTML = `<div class="color-palette-display placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div>`;
                     break;
                 case 'Concept / Key Visual':
                      placeholderKey = 'conceptPlaceholder'; fallbackText = 'Concept will appear here...';
                      placeholderHTML = `<p data-placeholder-key="${placeholderKey}" class="placeholder-notice">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
                      break;
                 default:
                      placeholderHTML = `<p class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
             }
             contentDiv.innerHTML = placeholderHTML;
         }


        // --- Image Generation Function (Using Backend Proxy) ---
        async function createImagePlaceholder(container, description, seedSuffix) {
             const figure = document.createElement('figure'); figure.className = 'image-placeholder';
             const img = document.createElement('img'); img.alt = `Loading image for: ${description.substring(0,50)}...`; img.src = ''; img.loading = 'lazy';
             let phHeight = (container?.id === 'moodboard-images') ? 130 : 160;
             img.style.cssText = `height: ${phHeight}px; width: 100%; object-fit: cover; background-color: #444; border-bottom: 1px solid var(--border-color);`;
             const figcaption = document.createElement('figcaption');
             figcaption.innerHTML = description.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
             figure.appendChild(img); figure.appendChild(figcaption); container.appendChild(figure);

             // --- Backend Proxy API Call Logic ---
             const prompt = description.replace(/<[^>]*>/g, '').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
             if (!prompt) {
                 console.warn("Empty prompt after cleaning description.");
                 setFallbackImage(img, figcaption, description, seedSuffix, 'empty-prompt', phHeight);
                 return;
             }

             // --- Call your backend endpoint ---
             const BACKEND_API_URL = '/api/generate-image'; // Relative URL to your server endpoint

             try {
                 console.log(`Requesting image via backend proxy: "${prompt.substring(0, 50)}..."`);
                 // Add slight delay if needed, though less critical with backend proxy
                 await new Promise(resolve => setTimeout(resolve, 50));

                 const response = await fetch(BACKEND_API_URL, {
                     method: 'POST',
                     headers: {
                         // No Authorization header needed here! Backend handles it.
                         'Content-Type': 'application/json'
                     },
                     body: JSON.stringify({ description: prompt }) // Send description in body
                 });

                 const responseData = await response.json();
                 console.log("Backend Proxy Response Data:", responseData);

                 if (!response.ok) {
                     // Error came from *your* backend or its interaction with Replicate
                     const errorDetail = responseData?.error || `Backend Error: ${response.status}`;
                     console.error("Backend proxy error:", errorDetail);
                     // Display the error message from your backend
                     displayError(`${getTranslatedText(null, 'errorBackendProxy', false, 'Image Gen Error:')} ${errorDetail}`, 'errorBackendProxy');
                     setFallbackImage(img, figcaption, description, seedSuffix, `backend-err-${response.status}`, phHeight);
                     return;
                 }

                 // Check if the backend indicated success and returned a URL
                 if (responseData.imageUrl && typeof responseData.imageUrl === 'string' && responseData.imageUrl.startsWith('http')) {
                     const imageUrl = responseData.imageUrl;
                     img.onload = () => { img.style.backgroundColor = 'transparent'; }
                     img.onerror = () => {
                          console.error("Failed to load image from Backend/Replicate URL:", imageUrl);
                          setFallbackImage(img, figcaption, description, seedSuffix, 'backend-img-load-err', phHeight);
                     }
                     img.src = imageUrl;
                     img.alt = prompt; // Use the prompt as alt text

                 } else {
                     // Backend succeeded but didn't return a valid URL (shouldn't happen with good backend logic)
                     console.warn("Backend proxy did not return a valid image URL.", responseData);
                     setFallbackImage(img, figcaption, description, seedSuffix, 'backend-invalid-url', phHeight);
                 }

             } catch (error) {
                 console.error("Error fetching from Backend Proxy API:", error);
                 // This is likely a network error talking to *your* backend
                 let reason = 'backend-fetch-error';
                 let userMessage = getTranslatedText(null, 'errorBackendFetch', false, 'Network error contacting our server for image generation.');
                 if (error instanceof TypeError) { // Basic check for network-related errors
                     reason = 'backend-network';
                 }
                 displayError(userMessage, reason);
                 setFallbackImage(img, figcaption, description, seedSuffix, reason, phHeight);
             }
        }


        function setFallbackImage(imgEl, figcaptionEl, desc, seed, reason, height) {
             console.warn(`Setting fallback image. Reason: ${reason}`);
             const seedEnc = encodeURIComponent(desc.substring(0, 15) + seed + '-' + reason);
             const picSumH = Math.max(150, Math.round(height * 1.5)); // Request slightly larger picsum
             const picSumW = Math.round(picSumH * 1.6); // Maintain aspect ratio
             imgEl.onload = () => { imgEl.style.backgroundColor = 'transparent'; }
             imgEl.onerror = () => { imgEl.style.backgroundColor = '#555'; imgEl.alt = `Fallback failed (Reason: ${reason})` }
             imgEl.src = `https://picsum.photos/seed/${seedEnc}/${picSumW}/${picSumH}.webp`; // Use webp
             imgEl.alt = `Placeholder: ${desc.substring(0, 50)}... (Reason: ${reason})`;

             // Remove any existing source/fallback spans first
             const existingSource = figcaptionEl.querySelector('.generation-source');
             if(existingSource) existingSource.remove();
             const existingFallback = figcaptionEl.querySelector('.fallback-notice');
             if(existingFallback) existingFallback.remove();

             // Add the new fallback notice
             const notice = document.createElement('span'); notice.className = 'fallback-notice';
             notice.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${reason})`;
             figcaptionEl.appendChild(notice);
        }

        // --- Color Swatch Creation ---
        function createColorSwatches(container, text) {
             if (!container) return false; container.innerHTML = ''; container.classList.remove('placeholder-notice');
             const colorRegex = /([\w\s\-\/()]+?)\s*\(?\s*(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})\s*\)?/gi;
             let match; let foundColors = false; let swatchIndex = 0;
             const potentialColors = text.split(/[,;\n]+/);
             potentialColors.forEach(part => {
                 colorRegex.lastIndex = 0;
                 while ((match = colorRegex.exec(part)) !== null) {
                     let name = match[1].trim().replace(/[():]/g, '').replace(/^-+|-+$/g, '').trim();
                     let hex = match[2].trim().toUpperCase();
                     if (!name || name.length < 2) continue;
                     if (hex.length === 4) hex = '#' + hex[1].repeat(2) + hex[2].repeat(2) + hex[3].repeat(2);
                     if (!/^#[0-9A-F]{6}$/.test(hex)) { console.warn(`Invalid hex: ${match[2]}`); continue; }
                     foundColors = true;
                     const swatch = document.createElement('div'); swatch.className = 'color-swatch';
                     try {
                         swatch.style.backgroundColor = hex;
                         swatch.style.color = isColorDarkGuess(hex) ? 'var(--text-primary)' : 'var(--bg-dark)';
                     } catch (e) { continue; }
                     const nameSpan = document.createElement('span'); nameSpan.textContent = name;
                     const hexSpan = document.createElement('span'); hexSpan.className = 'hex-code'; hexSpan.textContent = hex;
                     swatch.appendChild(nameSpan); swatch.appendChild(hexSpan); container.appendChild(swatch);
                     requestAnimationFrame(() => { setTimeout(() => { swatch.classList.add('visible'); }, 50 + swatchIndex * 70); });
                     swatchIndex++;
                 }
             });
             return foundColors;
        }

        // --- Color Lightness Guess ---
        function isColorDarkGuess(hexColor) {
            try {
                if (!hexColor?.startsWith('#')) return false; let hex = hexColor.substring(1);
                if (hex.length === 3) hex = hex[0].repeat(2) + hex[1].repeat(2) + hex[2].repeat(2);
                if (hex.length !== 6) return false;
                const r = parseInt(hex.substring(0, 2), 16), g = parseInt(hex.substring(2, 4), 16), b = parseInt(hex.substring(4, 6), 16);
                return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255 < 0.5;
            } catch (e) { return false; }
        }

        // --- Utility Functions ---
        function clearResultsContent() {
             const contentAreas = resultsOutputArea.querySelectorAll('.card-content');
             if (!contentAreas.length) return;
             contentAreas.forEach(area => {
                 const sectionId = area.id;
                 const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId);
                 if (sectionTitle) { setPlaceholderForMissingSection(area, sectionTitle); }
                 else { // Fallback for unknown areas
                     area.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Cleared.')}</p>`;
                     area.classList.add('placeholder-notice');
                 }
             });
             resultsOutputArea.querySelectorAll('.result-card.visible, .color-swatch.visible').forEach(el => el.classList.remove('visible'));
             console.log("Cleared results content and added placeholders.");
         }
         function clearDetailedResultsContentOnly() {
             if (!detailedResultsGrid) return;
             detailedResultsGrid.querySelectorAll('.result-card').forEach(card => {
                 const contentArea = card.querySelector('.card-content'); if (!contentArea) return;
                 const sectionId = contentArea.id;
                 const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId);
                  if (sectionTitle) { setPlaceholderForMissingSection(contentArea, sectionTitle); }
                  else { contentArea.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Cleared.')}</p>`; contentArea.classList.add('placeholder-notice'); }
                  card.style.display = 'none'; card.classList.remove('visible');
             });
             console.log("Cleared detailed results content.");
         }
        function clearResultsAndErrors() {
             resultsOutputArea.style.display = 'none'; conceptCard.style.display = 'none';
             conceptCard.classList.remove('visible'); detailedResultsGrid.style.display = 'none';
             errorMessageDiv.style.display = 'none'; errorMessageDiv.textContent = '';
             errorMessageDiv.removeAttribute('data-error-key');
             clearResultsContent();
             if(exploreMoreButton) exploreMoreButton.disabled = true;
             if(regenerateButton) regenerateButton.disabled = true;
             console.log("Cleared results area and errors.");
        }
        function displayError(message, errorKey = 'errorUnknown') {
             const fallbackMessage = getTranslatedText(null, 'errorUnknown', false, 'An unknown error occurred.');
             message = String(message || fallbackMessage);
             errorMessageDiv.textContent = message; errorMessageDiv.dataset.errorKey = errorKey;
             errorMessageDiv.style.display = 'block'; hideLoading();
             console.error("Displayed user error:", message, `(Key: ${errorKey})`);
             // Avoid scrolling for certain non-critical errors
             if (!errorKey.startsWith('repl-') && !errorKey.startsWith('no-repl-key') && !errorKey.startsWith('backend-') && errorKey !== 'randomLyricsGenerated') {
                 errorMessageDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
             }
        }

        // --- Language Switching ---
        function formatDatasetKey(langCode, suffix = '') {
            // Handles zh-CN specifically
             let keyBase = (langCode === 'zh-CN') ? 'zhcn' : langCode.toLowerCase().split('-')[0];
             const capitalizedBase = keyBase.charAt(0).toUpperCase() + keyBase.slice(1);
             let key = 'lang' + capitalizedBase;
             if (suffix) {
                 let camelSuffix = suffix.replace(/[-_](.)/g, (_, c) => c.toUpperCase());
                 camelSuffix = camelSuffix.charAt(0).toUpperCase() + camelSuffix.slice(1);
                 key += camelSuffix;
             }
             return key.charAt(0).toLowerCase() + key.slice(1); // e.g., langEn, langEs, langZhcn, langEnPlaceholder
         }

         function getTranslatedText(element, suffixOrKey = '', isPlaceholderAttr = false, fallbackText = '') {
            const translations = { // Predefined translations for specific keys (especially status/errors/guide)
                // Dynamic Status/Errors
                generatingCreativeSparks: { en: "Generating creative sparks...", es: "Generando chispas creativas...", vi: "Đang tạo ra những tia sáng sáng tạo...", ja: "創造的な火花を生成中...", zhcn: "正在生成创意火花..." },
                generatingConcept: { en: "Generating Concept...", es: "Generando Concepto...", vi: "Đang tạo ý tưởng...", ja: "コンセプトを生成中...", zhcn: "正在生成概念..." },
                fetchingDetails: { en: "Fetching More Details...", es: "Obteniendo Más Detalles...", vi: "Đang lấy thêm chi tiết...", ja: "詳細を取得中...", zhcn: "正在获取更多细节..." },
                generatingLyrics: { en: "Generating Random Lyrics...", es: "Generando Letra Aleatoria...", vi: "Đang tạo lời ngẫu nhiên...", ja: "ランダムな歌詞を生成中...", zhcn: "正在生成随机歌词..." },
                statusRequestingMic: { en: "Requesting mic access...", es: "Solicitando acceso al micro...", vi: "Đang yêu cầu quyền truy cập mic...", ja: "マイクアクセスを要求中...", zhcn: "请求麦克风访问权限..." },
                statusRecording: { en: "Recording...", es: "Grabando...", vi: "Đang ghi âm...", ja: "録音中...", zhcn: "录音中..." },
                statusTranscribing: { en: "Transcribing...", es: "Transcribiendo...", vi: "Đang chuyển đổi...", ja: "文字起こし中...", zhcn: "转录中..." },
                statusStopping: { en: "Stopping...", es: "Deteniendo...", vi: "Đang dừng...", ja: "停止中...", zhcn: "停止中..." },
                stoppedStatus: { en: "Stopped.", es: "Detenido.", vi: "Đã dừng.", ja: "停止しました。", zhcn: "已停止。" },
                recordTranscriptComplete: { en: "Recording & transcript complete.", es: "Grabación y transcripción completas.", vi: "Ghi âm & bản ghi hoàn tất.", ja: "録音＆文字起こし完了。", zhcn: "录音和转录完成。" },
                recordCompleteNoTranscript: { en: "Recording complete (no transcript).", es: "Grabación completa (sin transcripción).", vi: "Ghi âm hoàn tất (không có bản ghi).", ja: "録音完了（文字起こしなし）。", zhcn: "录音完成（无转录稿）。" },
                transcriptCompleteNoRecord: { en: "Transcript complete (no recording saved).", es: "Transcripción completa (grabación no guardada).", vi: "Bản ghi hoàn tất (ghi âm chưa lưu).", ja: "文字起こし完了（録音は保存されず）。", zhcn: "转录完成（未保存录音）。" },
                statusFileSelected: { en: "File selected.", es: "Archivo seleccionado.", vi: "Đã chọn tệp.", ja: "ファイルが選択されました。", zhcn: "文件已选择。" },
                randomLyricsGenerated: { en: "Random lyrics generated!", es: "¡Letra aleatoria generada!", vi: "Đã tạo lời ngẫu nhiên!", ja: "ランダムな歌詞が生成されました！", zhcn: "已生成随机歌词！" },
                statusAudioNotSupported: { en: "Audio recording not supported.", es: "Grabación de audio no soportada.", vi: "Không hỗ trợ ghi âm.", ja: "音声録音はサポートされていません。", zhcn: "不支持音频录制。" },
                statusSpeechRecNotSupported: { en: "Speech recognition not supported.", es: "Reconocimiento de voz no soportado.", vi: "Không hỗ trợ nhận dạng giọng nói.", ja: "音声認識はサポートされていません。", zhcn: "不支持语音识别。" },
                micErrorGeneric: { en: "Microphone access error.", es: "Error de acceso al micrófono.", vi: "Lỗi truy cập micrô.", ja: "マイクアクセスエラー。", zhcn: "麦克风访问错误。" },
                micErrorPermission: { en: "Microphone permission denied.", es: "Permiso de micrófono denegado.", vi: "Đã từ chối quyền truy cập micrô.", ja: "マイクの許可が拒否されました。", zhcn: "麦克风权限被拒绝。" },
                micErrorNotFound: { en: "No microphone found.", es: "No se encontró micrófono.", vi: "Không tìm thấy micrô.", ja: "マイクが見つかりません。", zhcn: "未找到麦克风。" },
                micErrorHardware: { en: "Microphone hardware error.", es: "Error de hardware del micrófono.", vi: "Lỗi phần cứng micrô.", ja: "マイクハードウェアエラー。", zhcn: "麦克风硬件错误。" },
                statusRecordingError: { en: "Recording error: ${errorName}", es: "Error de grabación: ${errorName}", vi: "Lỗi ghi âm: ${errorName}", ja: "録音エラー：${errorName}", zhcn: "录音错误：${errorName}" },
                transcriptionErrorGeneric: { en: "Transcription error.", es: "Error de transcripción.", vi: "Lỗi chuyển đổi.", ja: "文字起こしエラー。", zhcn: "转录错误。" },
                transcriptionErrorNoSpeech: { en: "No speech detected.", es: "No se detectó voz.", vi: "Không phát hiện giọng nói.", ja: "音声が検出されませんでした。", zhcn: "未检测到语音。" },
                transcriptionErrorMicProblem: { en: "Mic problem during transcription.", es: "Problema de micro durante transcripción.", vi: "Sự cố micrô khi chuyển đổi.", ja: "文字起こし中にマイクの問題が発生しました。", zhcn: "转录过程中麦克风出现问题。" },
                transcriptionErrorPermission: { en: "Transcription permission denied.", es: "Permiso de transcripción denegado.", vi: "Đã từ chối quyền chuyển đổi.", ja: "文字起こしの許可が拒否されました。", zhcn: "转录权限被拒绝。" },
                transcriptionErrorNetwork: { en: "Network error during transcription.", es: "Error de red durante transcripción.", vi: "Lỗi mạng khi chuyển đổi.", ja: "文字起こし中にネットワークエラーが発生しました。", zhcn: "转录期间网络错误。" },
                errorUnknown: { en: "An unknown error occurred.", es: "Ocurrió un error desconocido.", vi: "Đã xảy ra lỗi không xác định.", ja: "不明なエラーが発生しました。", zhcn: "发生未知错误。" },
                errorApiKeyInvalid: { en: "API Key is missing or invalid.", es: "La clave API falta o es inválida.", vi: "Khóa API bị thiếu hoặc không hợp lệ.", ja: "APIキーが見つからないか、無効です。", zhcn: "API 密钥丢失或无效。" },
                errorApiHttp: { en: "API request failed: ${errorDetail}", es: "Falló la solicitud API: ${errorDetail}", vi: "Yêu cầu API thất bại: ${errorDetail}", ja: "APIリクエストが失敗しました：${errorDetail}", zhcn: "API 请求失败：${errorDetail}" },
                errorApiBlocked: { en: "Content blocked by safety filters (Reason: ${reason}).", es: "Contenido bloqueado por filtros de seguridad (Razón: ${reason}).", vi: "Nội dung bị chặn bởi bộ lọc an toàn (Lý do: ${reason}).", ja: "セーフティフィルターによりコンテンツがブロックされました（理由：${reason}）。", zhcn: "内容被安全过滤器阻止（原因：${reason}）。" },
                errorApiGeneral: { en: "API returned an error: ${errorMessage}", es: "La API devolvió un error: ${errorMessage}", vi: "API trả về lỗi: ${errorMessage}", ja: "APIがエラーを返しました：${errorMessage}", zhcn: "API 返回错误：${errorMessage}" },
                errorApiNoCandidate: { en: "No valid response candidate from AI.", es: "Ningún candidato de respuesta válido de la IA.", vi: "Không có phản hồi hợp lệ từ AI.", ja: "AIからの有効な応答候補がありません。", zhcn: "AI 无有效响应候选项。" },
                errorApiEmptyResponse: { en: "Received an unexpected or empty text response from AI.", es: "Se recibió una respuesta de texto inesperada o vacía de la IA.", vi: "Đã nhận phản hồi văn bản không mong muốn hoặc trống từ AI.", ja: "AIから予期しない、または空のテキスト応答を受け取りました。", zhcn: "从 AI 收到意外或空的文本响应。" },
                errorCorsOrNetwork: { en: "Network/CORS error calling API. Check console/proxy.", es: "Error Red/CORS llamando API. Revisa consola/proxy.", vi: "Lỗi Mạng/CORS khi gọi API. Kiểm tra console/proxy.", ja: "API呼び出し中のネットワーク/CORSエラー。コンソール/プロキシ確認。", zhcn: "调用 API 时网络/CORS错误。检查控制台/代理。" },
                errorExploreNoConcept: { en: "Generate a concept first before exploring details.", es: "Genera un concepto primero antes de explorar detalles.", vi: "Hãy tạo ý tưởng trước khi khám phá chi tiết.", ja: "詳細を探索する前にコンセプトを生成してください。", zhcn: "在探索细节之前先生成概念。" },
                errorParsingFailed: { en: "Could not parse expected sections. Check AI response format.", es: "No se pudieron analizar las secciones esperadas. Revisa formato de respuesta IA.", vi: "Không thể phân tích các phần mong đợi. Kiểm tra định dạng phản hồi AI.", ja: "期待されるセクションを解析できませんでした。AI応答形式を確認してください。", zhcn: "无法解析预期的部分。检查 AI 响应格式。" },
                errorDisplayingSection: { en: "Error displaying this section.", es: "Error al mostrar esta sección.", vi: "Lỗi hiển thị phần này.", ja: "このセクションの表示中にエラーが発生しました。", zhcn: "显示此部分时出错。" },
                errorBackendProxy: { en: "Image Generation Error:", es: "Error Generación Imagen:", vi: "Lỗi Tạo ảnh:", ja: "画像生成エラー：", zhcn: "图像生成错误：" },
                errorBackendFetch: { en: "Network error contacting server for image generation.", es: "Error de red contactando servidor para generar imagen.", vi: "Lỗi mạng khi liên hệ máy chủ tạo ảnh.", ja: "画像生成サーバー接続エラー。", zhcn: "联系图像生成服务器时网络错误。" },
                // Validation
                validationLyricsMissing: { en: "Please provide song lyrics.", es: "Por favor, proporciona la letra de la canción.", vi: "Vui lòng cung cấp lời bài hát.", ja: "歌詞を入力してください。", zhcn: "请输入歌词。" },
                validationKeywordsMissing: { en: "Please provide keywords or a theme.", es: "Por favor, proporciona palabras clave o un tema.", vi: "Vui lòng cung cấp từ khóa hoặc chủ đề.", ja: "キーワードまたはテーマを入力してください。", zhcn: "请输入关键词或主题。" },
                validationGenreMissing: { en: "Please select a music genre.", es: "Por favor, selecciona un género musical.", vi: "Vui lòng chọn thể loại nhạc.", ja: "音楽ジャンルを選択してください。", zhcn: "请选择音乐流派。" },
                 // Result Placeholders/Notes
                 conceptPlaceholder: { en: "Your generated concept will appear here...", es: "Tu concepto generado aparecerá aquí...", vi: "Ý tưởng được tạo của bạn sẽ xuất hiện ở đây...", ja: "生成されたコンセプトがここに表示されます...", zhcn: "您生成的概念将显示在此处..." },
                 requirementsPlaceholder: { en: "Requirements list will appear here...", es: "La lista de requisitos aparecerá aquí...", vi: "Danh sách yêu cầu sẽ xuất hiện ở đây...", ja: "要件リストがここに表示されます...", zhcn: "要求列表将显示在此处..." },
                 budgetPlaceholder: { en: "Budget details will appear here...", es: "Los detalles del presupuesto aparecerán aquí...", vi: "Chi tiết ngân sách sẽ xuất hiện ở đây...", ja: "予算の詳細がここに表示されます...", zhcn: "预算细节将显示在此处..." },
                 budgetNotePlaceholder: { en: "Note: Budgets are conceptual estimates...", es: "Nota: Los presupuestos son estimaciones conceptuales...", vi: "Lưu ý: Ngân sách là ước tính khái niệm...", ja: "注：予算は概念的な見積もりであり...", zhcn: "注意：预算是概念性估算..." },
                 visualsPlaceholder: { en: "Key visual descriptions will appear here...", es: "Las descripciones visuales clave aparecerán aquí...", vi: "Mô tả hình ảnh chính sẽ xuất hiện ở đây...", ja: "主要なビジュアルの説明がここに表示されます...", zhcn: "关键视觉描述将显示在此处..." },
                 visualsNotePlaceholder: { en: "Illustrative images based on descriptions.", es: "Imágenes ilustrativas basadas en descripciones.", vi: "Hình ảnh minh họa dựa trên mô tả.", ja: "説明に基づいた説明的な画像。", zhcn: "基于描述的说明性图片。" },
                 moodboardDescPlaceholder: { en: "Moodboard description will appear here...", es: "La descripción del moodboard aparecerá aquí...", vi: "Mô tả moodboard sẽ xuất hiện ở đây...", ja: "ムードボードの説明がここに表示されます...", zhcn: "情绪板描述将显示在此处..." },
                 moodboardImgsPlaceholder: { en: "Moodboard influence images will appear here...", es: "Las imágenes de influencia del moodboard aparecerán aquí...", vi: "Hình ảnh ảnh hưởng moodboard sẽ xuất hiện ở đây...", ja: "ムードボードの影響画像がここに表示されます...", zhcn: "情绪板影响图片将显示在此处..." },
                 moodboardNotePlaceholder: { en: "Visual styles and elements for inspiration.", es: "Estilos visuales y elementos para inspiración.", vi: "Phong cách và yếu tố hình ảnh để lấy cảm hứng.", ja: "インスピレーションのための視覚的なスタイルと要素。", zhcn: "用于灵感的视觉风格和元素。" },
                 palettePlaceholder: { en: "Color palette will appear here...", es: "La paleta de colores aparecerá aquí...", vi: "Bảng màu sẽ xuất hiện ở đây...", ja: "カラーパレットがここに表示されます...", zhcn: "调色板将显示在此处..." },
                 placeholderGeneric: { en: "Content not available.", es: "Contenido no disponible.", vi: "Nội dung không có sẵn.", ja: "コンテンツはありません。", zhcn: "内容不可用。" },
                 noVisualsFound: { en: "No visuals found.", es: "No se encontraron visuales.", vi: "Không tìm thấy hình ảnh.", ja: "ビジュアルが見つかりません。", zhcn: "未找到视觉效果。" },
                 noMoodboardItemsFound: { en: "No moodboard items found.", es: "No se encontraron elementos de moodboard.", vi: "Không tìm thấy mục moodboard.", ja: "ムードボードの項目が見つかりません。", zhcn: "未找到情绪板项目。" },
                 noRequirementsFound: { en: "No requirements listed.", es: "No se listaron requisitos.", vi: "Không có yêu cầu nào được liệt kê.", ja: "要件はリストされていません。", zhcn: "未列出要求。" },
                 noBudgetContentFound: { en: "No budget details provided.", es: "No se proporcionaron detalles de presupuesto.", vi: "Không có chi tiết ngân sách được cung cấp.", ja: "予算の詳細は提供されていません。", zhcn: "未提供预算详细信息。" },
                 budgetDetailsMissing: { en: "Details missing.", es: "Detalles faltantes.", vi: "Thiếu chi tiết.", ja: "詳細がありません。", zhcn: "缺少细节。" },
                 noColorsFound: { en: "Could not parse colors.", es: "No se pudieron analizar los colores.", vi: "Không thể phân tích màu sắc.", ja: "色を解析できませんでした。", zhcn: "无法解析颜色。" },
                 generatedViaBackend: { en: "Gen. via Server", es: "Gen. vía Servidor", vi: "Tạo bởi Máy chủ", ja: "サーバー経由で生成", zhcn: "通过服务器生成" },
                 placeholderReason: { en: "Placeholder", es: "Marcador", vi: "Giữ chỗ", ja: "プレースホルダ", zhcn: "占位符" },
                 budgetLowTitle: { en: "Low Budget", es: "Presupuesto Bajo", vi: "Ngân sách thấp", ja: "低予算", zhcn: "低预算" },
                 budgetMidTitle: { en: "Mid Budget", es: "Presupuesto Medio", vi: "Ngân sách trung bình", ja: "中予算", zhcn: "中等预算" },
                 budgetHighTitle: { en: "High Budget", es: "Presupuesto Alto", vi: "Ngân sách cao", ja: "高予算", zhcn: "高预算" },
                 // Guide Text Keys (Map to data-guide-* attributes)
                 guideTitle: { en: "How to Use MV Concept Generator", es: "Cómo Usar el Generador de Conceptos MV", vi: "Cách Sử dụng Trình tạo Ý tưởng MV", ja: "MVコンセプトジェネレーターの使い方", zhcn: "如何使用 MV 概念生成器" },
                 guideNav: { en: "Navigation", es: "Navegación", vi: "Điều hướng", ja: "ナビゲーション", zhcn: "导航" },
                 guideNavDesc: { en: "Use the links at the top (Home, About, Generate) to switch sections.", es: "Usa los enlaces superiores (Inicio, Acerca de, Generar) para cambiar de sección.", vi: "Sử dụng các liên kết ở trên cùng (Trang chủ, Giới thiệu, Tạo) để chuyển đổi các phần.", ja: "上部のリンク（ホーム、概要、生成）でセクションを切り替えます。", zhcn: "使用顶部链接（首页、关于、生成）切换部分。" },
                 guideLang: { en: "Language Selection", es: "Selección de Idioma", vi: "Chọn ngôn ngữ", ja: "言語選択", zhcn: "语言选择" },
                 guideLangDesc: { en: "Use the dropdown in the top-right to change the display language.", es: "Usa el menú desplegable superior derecho para cambiar el idioma.", vi: "Sử dụng menu thả xuống ở góc trên bên phải để thay đổi ngôn ngữ hiển thị.", ja: "右上のドロップダウンで表示言語を変更します。", zhcn: "使用右上角的下拉菜单更改显示语言。" },
                 guideGenerate: { en: "Generate Page Features", es: "Funciones de la Página de Generación", vi: "Tính năng Trang Tạo", ja: "生成ページの機能", zhcn: "生成页面功能" },
                 guideLyrics: { en: "Music Lyrics: Paste your full song lyrics here. Main AI input.", es: "Letra Musical: Pega tu letra completa aquí. Entrada principal para IA.", vi: "Lời bài hát: Dán toàn bộ lời bài hát của bạn vào đây. Đầu vào chính cho AI.", ja: "歌詞：ここに完全な歌詞を貼り付けます。AIの主要入力。", zhcn: "歌词：在此粘贴完整歌词。AI 主要输入。" },
                 guideRandomLyrics: { en: "Generate Random Lyric: Click if you need inspiration or lack lyrics. Fills the box.", es: "Generar Letra Aleatoria: Haz clic si necesitas inspiración o no tienes letra. Rellena el cuadro.", vi: "Tạo lời ngẫu nhiên: Nhấp nếu bạn cần cảm hứng hoặc thiếu lời. Tự động điền vào ô.", ja: "ランダム歌詞生成：インスピレーションが必要な場合や歌詞がない場合にクリック。ボックスに入力されます。", zhcn: "生成随机歌词：如需灵感或无歌词，请单击。将填充文本框。" },
                 guideKeywords: { en: "Keywords/Theme: Enter words describing mood, style, ideas (e.g., upbeat, city night).", es: "Palabras Clave/Tema: Ingresa palabras sobre ánimo, estilo, ideas (ej. alegre, noche ciudad).", vi: "Từ khóa/Chủ đề: Nhập từ mô tả tâm trạng, phong cách, ý tưởng (vd: lạc quan, đêm thành phố).", ja: "キーワード/テーマ：ムード、スタイル、アイデアを説明する言葉（例：アップビート、夜の街）。", zhcn: "关键词/主题：输入描述情绪、风格、想法的词语（例如，欢快、城市之夜）。" },
                 guideGenre: { en: "Music Genre: Select the genre that best fits.", es: "Género Musical: Selecciona el que mejor encaje.", vi: "Thể loại âm nhạc: Chọn thể loại phù hợp nhất.", ja: "音楽ジャンル：最も合うジャンルを選択。", zhcn: "音乐流派：选择最适合的流派。" },
                 guideTrack: { en: "Track Input (Optional): Upload audio or record singing for enhanced suggestions.", es: "Entrada de Pista (Opcional): Sube audio o graba canto para mejores sugerencias.", vi: "Nhập bản nhạc (Tùy chọn): Tải lên âm thanh hoặc ghi âm giọng hát để có đề xuất tốt hơn.", ja: "トラック入力（任意）：オーディオをアップロードするか歌を録音して提案を強化。", zhcn: "音轨输入（可选）：上传音频或录制演唱以获得更好建议。" },
                 guideGenerateBtn: { en: "Generate Concept: Click this after filling inputs to get the initial concept.", es: "Generar Concepto: Haz clic tras rellenar entradas para obtener el concepto inicial.", vi: "Tạo ý tưởng: Nhấp vào đây sau khi điền thông tin đầu vào để nhận ý tưởng ban đầu.", ja: "コンセプト生成：入力後、これをクリックして初期コンセプトを取得。", zhcn: "生成概念：填写输入后单击此按钮获取初始概念。" },
                 guideResults: { en: "Understanding the Results", es: "Entendiendo los Resultados", vi: "Hiểu kết quả", ja: "結果の理解", zhcn: "理解结果" },
                 guideResultsDesc: { en: "After generating, results appear below:", es: "Tras generar, los resultados aparecen abajo:", vi: "Sau khi tạo, kết quả xuất hiện bên dưới:", ja: "生成後、結果は以下に表示されます：", zhcn: "生成后，结果显示在下方：" },
                 guideConcept: { en: "Concept / Key Visual: The main idea for your MV.", es: "Concepto / Visual Clave: La idea principal para tu MV.", vi: "Ý tưởng / Hình ảnh chủ đạo: Ý tưởng chính cho MV của bạn.", ja: "コンセプト / キービジュアル：MVの主なアイデア。", zhcn: "概念 / 关键视觉：您 MV 的主要想法。" },
                 guideExplore: { en: "Explore More Details: Click for detailed sections:", es: "Explorar Más Detalles: Haz clic para secciones detalladas:", vi: "Khám phá thêm chi tiết: Nhấp để xem các phần chi tiết:", ja: "詳細を探索：クリックして詳細セクションを表示：", zhcn: "探索更多细节：单击查看详细部分：" },
                 guideReqs: { en: "Requirements: List of potential needs (locations, props).", es: "Requisitos: Lista de necesidades potenciales (ubicaciones, props).", vi: "Yêu cầu: Danh sách nhu cầu tiềm năng (địa điểm, đạo cụ).", ja: "要件：潜在的なニーズのリスト（場所、小道具）。", zhcn: "要求：潜在需求列表（地点、道具）。" },
                 guideBudget: { en: "Estimated Budget: Rough ideas for Low, Mid, High production.", es: "Presupuesto Estimado: Ideas aproximadas para producción Baja, Media, Alta.", vi: "Ngân sách ước tính: Ý tưởng sơ bộ cho sản xuất Thấp, Trung bình, Cao.", ja: "推定予算：低、中、高プロダクションのおおよそのアイデア。", zhcn: "预估预算：低、中、高制作水平的粗略想法。" },
                 guideVisuals: { en: "Visual Demo: Key scene descriptions, often with images.", es: "Demo Visual: Descripciones de escenas clave, a menudo con imágenes.", vi: "Minh họa Hình ảnh: Mô tả cảnh chính, thường kèm hình ảnh.", ja: "ビジュアルデモ：主要シーンの説明、しばしば画像付き。", zhcn: "视觉演示：关键场景描述，通常附带图像。" },
                 guideMoodboard: { en: "Moodboard Influences: Style references, often with images.", es: "Influencias Moodboard: Referencias de estilo, a menudo con imágenes.", vi: "Ảnh hưởng Moodboard: Tham khảo phong cách, thường kèm hình ảnh.", ja: "ムードボード影響：スタイル参照、しばしば画像付き。", zhcn: "情绪板影响：风格参考，通常附带图像。" },
                 guidePalette: { en: "Color Palette: Suggested colors matching the mood.", es: "Paleta de Colores: Colores sugeridos que coinciden con el ánimo.", vi: "Bảng màu: Màu sắc gợi ý phù hợp với tâm trạng.", ja: "カラーパレット：ムードに合った提案色。", zhcn: "调色板：与情绪匹配的建议颜色。" },
                 guideRegenerate: { en: "Re-Generate Concept: Try again with the same inputs.", es: "Re-Generar Concepto: Intenta de nuevo con las mismas entradas.", vi: "Tạo lại ý tưởng: Thử lại với cùng đầu vào.", ja: "コンセプト再生成：同じ入力で再試行。", zhcn: "重新生成概念：使用相同输入重试。" },
                 guideAiNote: { en: "Note: AI suggestions are starting points. Budgets are rough estimates.", es: "Nota: Sugerencias IA son puntos de partida. Presupuestos son estimados.", vi: "Lưu ý: Đề xuất AI là điểm khởi đầu. Ngân sách là ước tính sơ bộ.", ja: "注：AIの提案は出発点です。予算は概算です。", zhcn: "注意：AI 建议是起点。预算为粗略估算。" },
            };

            // Check predefined translations first (covers dynamic messages, errors, guide keys)
            if (translations[suffixOrKey] && translations[suffixOrKey][currentLang]) {
                return translations[suffixOrKey][currentLang];
            }
            // Fallback to English for predefined keys if current language is missing
            if (translations[suffixOrKey] && translations[suffixOrKey]['en']) {
                 return translations[suffixOrKey]['en'];
            }

            // If it's not a predefined key, try getting translation from element data attributes
            if (element) {
                let targetKey = '';
                // Special handling for record button states
                if ((suffixOrKey === 'record' || suffixOrKey === 'stop') && element.id === 'record-audio-button') {
                     targetKey = formatDatasetKey(currentLang, suffixOrKey);
                     const enKey = formatDatasetKey('en', suffixOrKey);
                     return element.dataset[targetKey] || element.dataset[enKey] || fallbackText || suffixOrKey; // Return suffix if no translation
                }
                 // Handle general placeholders vs text content
                 const attrKey = isPlaceholderAttr ? 'placeholder' : '';
                 targetKey = formatDatasetKey(currentLang, attrKey);
                 const enKey = formatDatasetKey('en', attrKey);

                // Prioritize current lang, then English, then original attribute/content, then fallback
                if (element.dataset[targetKey] !== undefined) return element.dataset[targetKey];
                if (element.dataset[enKey] !== undefined) return element.dataset[enKey];
                if (isPlaceholderAttr && element.getAttribute('placeholder')) return element.getAttribute('placeholder');
                if (!isPlaceholderAttr && element.textContent) {
                    // Special case for logo span - only use textContent if it's not just 'Logo'
                    if (element.dataset.logoText === 'true' && element.textContent.trim().toLowerCase() === 'logo' && fallbackText) {
                        return fallbackText; // Use fallback if original is just 'Logo'
                    }
                    // For other simple elements, use textContent as a last resort before the final fallback
                    if (['BUTTON', 'P', 'SMALL', 'LABEL', 'H1', 'H2', 'H3', 'LI', 'A', 'OPTION', 'TITLE', 'SPAN'].includes(element.tagName) && !element.children.length) {
                         return element.textContent.trim();
                    }
                }
            }

            // Absolute fallback
            return fallbackText;
         }

        function updateLanguage(langCode) {
            currentLang = langCode; console.log(`Switching language to: ${langCode}`);
            document.documentElement.lang = langCode;

            // Update all elements with data-lang attributes
            document.querySelectorAll('[data-lang-en], [data-lang-en-placeholder], [data-lang-en-record], [data-lang-en-stop]').forEach(el => {
                const isPlaceholder = el.hasAttribute('data-lang-en-placeholder');
                const isRecordBtn = el.hasAttribute('data-lang-en-record'); // Check if it's the record button
                let suffix = '';
                if (isPlaceholder) suffix = 'placeholder';
                // Determine fallback differently for record button vs others
                let fallback = '';
                if (isRecordBtn) {
                    // Fallback logic handled within updateRecordingUI now
                } else {
                    fallback = el.dataset[formatDatasetKey('en', suffix)] ||
                           (isPlaceholder ? el.getAttribute('placeholder') : el.textContent) || '';
                }

                // Use getTranslatedText carefully, especially for fallback value
                let translation = getTranslatedText(el, suffix, isPlaceholder, fallback);

                // Apply translation
                if (isPlaceholder) { el.placeholder = translation; }
                else if (el.tagName === 'TITLE') { document.title = translation; }
                else if (el.tagName === 'OPTION' && el.disabled) { el.textContent = translation; } // Handle disabled select option
                else if (!isRecordBtn && // Avoid overwriting record button text here (handled by updateRecordingUI)
                         !el.closest('.card-content') && // Avoid static text update inside dynamic results
                         !el.closest('#guide-modal') && // Avoid updating guide text here (handled separately)
                         el.id !== 'record-status-text' && // Avoid updating status text directly
                         el.id !== 'error-message') {     // Avoid updating error message directly
                     // Update simple text content elements like nav links, buttons (except record), labels, simple spans
                    if (['A', 'BUTTON', 'LABEL', 'H1', 'P', 'SMALL', 'SPAN'].includes(el.tagName)) {
                        // Check if it only contains text or other translatable spans
                        let onlyTextOrTranslatableSpans = Array.from(el.childNodes).every(node =>
                             node.nodeType === Node.TEXT_NODE ||
                             (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN' && node.hasAttribute('data-lang-en')) ||
                             (node.nodeType === Node.ELEMENT_NODE && !node.hasChildNodes() && !node.hasAttributes()) // Allow empty, simple spans
                         );
                        if (onlyTextOrTranslatableSpans || el.dataset.logoText === 'true') {
                            el.textContent = translation;
                        }
                    }
                }
            });

             // Update How-to-Use Guide Text using predefined keys
             if (guideContent) {
                 guideContent.querySelectorAll('[data-guide-title], [data-guide-nav], [data-guide-nav-desc], [data-guide-lang], [data-guide-lang-desc], [data-guide-generate], [data-guide-lyrics], [data-guide-random-lyrics], [data-guide-keywords], [data-guide-genre], [data-guide-track], [data-guide-generate-btn], [data-guide-results], [data-guide-results-desc], [data-guide-concept], [data-guide-explore], [data-guide-reqs], [data-guide-budget], [data-guide-visuals], [data-guide-moodboard], [data-guide-palette], [data-guide-regenerate], [data-guide-ai-note]').forEach(el => {
                     const key = Object.keys(el.dataset).find(k => k.startsWith('guide'));
                     if (key) {
                         // Convert data-guide-nav-desc to guideNavDesc
                         const translationKey = key.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                         // Use innerHTML for elements that might contain <code> or <strong>
                         if (['P', 'LI'].includes(el.tagName)) {
                              // Basic formatting preservation (replace with more robust later if needed)
                             let englishText = getTranslatedText(null, translationKey, false, ''); // Get English for structure
                             let translatedText = getTranslatedText(null, translationKey, false, englishText); // Get target lang

                             // Try to apply formatting tags from English version to translated version
                             const formattingTags = ['<code>', '</strong>', '<strong>']; // Tags to preserve
                             let tempHtml = englishText;
                             let placeholders = [];
                             formattingTags.forEach((tag, index) => {
                                const regex = new RegExp(tag.replace(/([><\/])/g, '\\$1'), 'gi');
                                tempHtml = tempHtml.replace(regex, `@@TAG${index}@@`);
                             });
                              // Apply placeholders to translated text if structure matches somewhat
                             formattingTags.forEach((tag, index) => {
                                translatedText = translatedText.replace(`@@TAG${index}@@`, tag); // Simple replace, might not be perfect
                             });

                             el.innerHTML = translatedText; // Use innerHTML to render tags

                         } else {
                             el.textContent = getTranslatedText(null, translationKey, false, el.textContent); // Use predefined keys for simple text
                         }
                     }
                 });
             }
             // Update floating button text
             if (howToUseButton) {
                 howToUseButton.textContent = getTranslatedText(howToUseButton, '', false, 'How to use');
             }


            // Update dynamic/status elements using their stored keys
             if(recordAudioButton) updateRecordingUI(isRecording); // Refreshes record button text
             if(recordStatus?.dataset?.statusKey) {
                  let statusKey = recordStatus.dataset.statusKey;
                  let fallback = recordStatus.dataset.statusFallback || '';
                  let statusClass = Array.from(recordStatus.classList).find(c => ['complete', 'error', 'recording', 'transcribing'].includes(c)) || '';
                  let isPersistent = statusClass === 'complete' || statusClass === 'error';
                  updateRecordStatus(getTranslatedText(null, statusKey, false, fallback), statusClass, isPersistent, statusKey);
             } else if (!isRecording) { clearRecordStatus(); } // Clear if no status key and not recording

             if (loadingOverlay.classList.contains('show')) {
                 const loadingP = loadingOverlay.querySelector('p');
                 if(loadingP && loadingP.dataset.lastKey) {
                    loadingP.textContent = getTranslatedText(loadingP, loadingP.dataset.lastKey, false, 'Loading...');
                 }
             }
             if (errorMessageDiv.style.display === 'block' && errorMessageDiv.dataset.errorKey) {
                 const errorKey = errorMessageDiv.dataset.errorKey;
                 let baseMessage = getTranslatedText(null, errorKey, false, ''); // Get base translation

                 // Re-append error details if they exist and aren't already in the base message
                 const currentText = errorMessageDiv.textContent;
                 const detailMatch = currentText.match(/:\s*(.*)$/); // Try to find detail after colon
                 if (baseMessage && detailMatch && detailMatch[1] && !baseMessage.includes(detailMatch[1])) {
                      baseMessage += `: ${detailMatch[1]}`;
                 } else if (!baseMessage) { // If no base translation, use the current full text
                      baseMessage = currentText;
                 }
                 errorMessageDiv.textContent = baseMessage;
             }
             if (isSpeechRecognitionSupported) { // Update speech rec language
                 const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' };
                 const newRecLang = bcp47Map[langCode] || (langCode.includes('-') ? langCode : `${langCode}-${langCode.toUpperCase()}`);
                 if (recognition && recognition.lang !== newRecLang) {
                      if (isRecording) { console.log("Stopping recording to change speech language..."); handleRecordButtonClick(); }
                      if(recognition) recognition.lang = newRecLang; console.log("Updated speech recognition language:", newRecLang);
                 }
            }

            // Re-apply placeholders and notes in results using current language (if results are visible)
             if (resultsOutputArea.style.display === 'block') {
                  // Update result card headers
                  resultsOutputArea.querySelectorAll('.result-card h2 > span[data-lang-en]').forEach(span => {
                      span.textContent = getTranslatedText(span, '', false, span.textContent);
                  });
                  // Update placeholders within cards
                 resultsOutputArea.querySelectorAll('.placeholder-notice[data-placeholder-key]').forEach(ph => {
                    ph.textContent = getTranslatedText(null, ph.dataset.placeholderKey, false, ph.textContent);
                 });
                  resultsOutputArea.querySelectorAll('.card-content > small[data-placeholder-key]').forEach(note => {
                     note.textContent = getTranslatedText(null, note.dataset.placeholderKey, false, note.textContent);
                  });
                 // Retranslate budget column titles if they are placeholders
                 const budgetCard = document.getElementById('result-budget-card');
                 if (budgetCard && budgetCard.style.display === 'flex') {
                     budgetCard.querySelectorAll('.budget-column.placeholder-notice h3').forEach(h3 => {
                         const levelMatch = h3.textContent.match(/^(Low|Mid|High)/i) || Object.keys(h3.dataset).find(k => k.startsWith('budget'));
                         let levelKey = '';
                         if(levelMatch && typeof levelMatch === 'string') levelKey = levelMatch.replace('budget','').replace('Title','');
                         else if(levelMatch) levelKey = levelMatch[1];

                         if (levelKey) {
                             levelKey = levelKey.charAt(0).toUpperCase() + levelKey.slice(1).toLowerCase(); // Normalize Low, Mid, High
                             h3.textContent = getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`);
                         }
                     });
                     budgetCard.querySelectorAll('.budget-column.placeholder-notice p[data-placeholder-key="budgetDetailsMissing"]').forEach(p => {
                         p.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`;
                     });
                 }
                 // Retranslate image generation source notes & fallbacks
                 resultsOutputArea.querySelectorAll('.image-placeholder figcaption .generation-source').forEach(span => {
                    span.textContent = getTranslatedText(null, 'generatedViaBackend', false, 'Gen. via Server');
                 });
                 resultsOutputArea.querySelectorAll('.image-placeholder figcaption .fallback-notice').forEach(span => {
                    const reasonMatch = span.textContent.match(/\(([^:]+):\s*(.*)\)/);
                    if (reasonMatch) {
                         const reasonText = reasonMatch[2] || 'unknown';
                         span.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${reasonText})`;
                    }
                 });
             }
             console.log("Language update complete:", langCode);
        }
        function saveLanguagePreference(langCode) { try { localStorage.setItem('mvGeneratorLang', langCode); } catch (e) { console.warn("Could not save language preference:", e)} }
        function loadLanguagePreference() {
            try { const saved = localStorage.getItem('mvGeneratorLang'); if (saved && Array.from(languageSelect.options).some(o => o.value === saved)) { languageSelect.value = saved; return saved; } } catch (e) {}
            return languageSelect ? languageSelect.value : 'en';
        }

        // --- Event Listeners Setup ---
        navLinks.forEach(link => { link.addEventListener('click', (e) => { const page = link.getAttribute('data-page'); if (page) { e.preventDefault(); showPage(page); } }); });
        if (exploreButton) { exploreButton.addEventListener('click', () => showPage('feature')); }
        backButtons.forEach(button => { button.addEventListener('click', (e) => { e.preventDefault(); showPage('home'); }); });
        if (generateConceptButton) { generateConceptButton.addEventListener('click', handleGenerateConcept); }
        if (generateRandomLyricButton) { generateRandomLyricButton.addEventListener('click', handleGenerateRandomLyrics); } // Listener for new button
        if (exploreMoreButton) { exploreMoreButton.addEventListener('click', handleExploreMore); }
        if (regenerateButton) { regenerateButton.addEventListener('click', handleRegenerateConcept); }
        if (languageSelect) { languageSelect.addEventListener('change', (e) => { updateLanguage(e.target.value); saveLanguagePreference(e.target.value); }); }
         // Listeners for How to Use Modal
        if (howToUseButton) { howToUseButton.addEventListener('click', () => guideModal.classList.add('show')); }
        if (guideCloseButton) { guideCloseButton.addEventListener('click', () => guideModal.classList.remove('show')); }
        if (guideModal) { guideModal.addEventListener('click', (e) => { if (e.target === guideModal) guideModal.classList.remove('show'); }); } // Close on overlay click


        // --- Initial Setup ---
        const initialLang = loadLanguagePreference(); updateLanguage(initialLang);
        showPage('home'); clearResultsAndErrors();
        console.log("MV Generator Initialized. Lang:", currentLang, "Speech Support:", isSpeechRecognitionSupported);
        // Initial check for audio support display
        if(recordAudioButton && recordAudioButton.disabled && (!navigator.mediaDevices?.getUserMedia || !isSpeechRecognitionSupported)) {
           const errorKey = !navigator.mediaDevices?.getUserMedia ? 'statusAudioNotSupported' : 'statusSpeechRecNotSupported';
           const errorMsg = getTranslatedText(null, errorKey, false, 'Audio/Speech input not supported.');
           updateRecordStatus(errorMsg, 'error', true, errorKey);
        }

    }); // End DOMContentLoaded
    </script>
    <!-- ========= END JAVASCRIPT ========= -->

</body>
</html>
