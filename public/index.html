<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be updated by JS -->
    <title
        data-lang-en="MV Concept Generator"
        data-lang-es="Generador de Conceptos MV"
        data-lang-vi="Trình tạo ý tưởng MV"
        data-lang-ja="MVコンセプトジェネレーター"
        data-lang-zhcn="MV概念生成器"
    >MV Concept Generator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Add common fonts requested by the AI (Optional, improves display if generated) -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Playfair+Display:wght@400;700&family=Roboto+Mono:wght@400&family=Lora:wght@400;700&family=Oswald:wght@400;700&display=swap" rel="stylesheet">

    <!-- Three.js CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
            }
        }
    </script>
    <!-- JSZip CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>


    <style>
        /* --- NEW DESIGN SYSTEM (Mostly Unchanged) --- */

        /* CSS Variables for Theme */
        :root {
            --bg-dark: #1a1a1d; /* Very dark grey, almost black */
            --bg-card: #2c2c30; /* Slightly lighter card background */
            --bg-card-hover: #35353a;
            --bg-output-area: #222225; /* Slightly darker for contrast with sidebar */
            --text-primary: #f0f0f5; /* Off-white */
            --text-secondary: #a9a9b3; /* Lighter grey */
            --accent-primary: #6a8ee7; /* Soft blue */
            --accent-secondary: #e476e4; /* Soft magenta/purple */
            --accent-gradient: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            --border-color: #404045;
            --input-bg-color: #38383d; /* Slightly lighter input background */
            --success-color: #57cc99;
            --warning-color: #ffb703;
            --error-color: #e63946;
            --font-family: 'Poppins', sans-serif;
            --nav-height: 70px;
            --border-radius-sm: 6px;
            --border-radius-md: 10px;
            --box-shadow-soft: 0 4px 15px rgba(0, 0, 0, 0.2);
            --box-shadow-glow: 0 0 15px rgba(106, 142, 231, 0.3); /* Glow for accent elements */
             /* Loader Variables */
            --loader-sp: 2.5s; /* Speed for new loader */
            /* Feature Page Specific */
            --sidebar-width: 380px;
            --sidebar-width-md: 320px;
            --sidebar-width-sm: 100%; /* Full width on small screens */
        }

        /* Basic Reset & Defaults */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family);
            line-height: 1.7;
            color: var(--text-primary);
            background-color: var(--bg-dark);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scrollbar */
            transition: background-color 0.3s ease;
            position: relative; /* Needed for z-index stacking */
        }
        main {
            flex-grow: 1;
            padding-top: var(--nav-height); /* Remove extra padding */
            width: 100%;
            position: relative; /* Needed for content to stay above canvas */
            z-index: 1; /* Ensure main content is above background canvas */
            display: flex; /* Make main a flex container for pages */
            flex-direction: column; /* Stack pages vertically */
        }

        /* --- START: 3D Background Canvas --- */
        #bg-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; display: block; margin: 0; padding: 0;
            pointer-events: none; outline: none;
        }
        /* --- END: 3D Background Canvas --- */

        /* --- LOADING OVERLAY (Unchanged) --- */
        #loading-overlay { position: fixed; inset: 0; background-color: rgba(26, 26, 29, 0.85); backdrop-filter: blur(5px); display: none; justify-content: center; align-items: center; z-index: 9999; flex-direction: column; opacity: 0; transition: opacity 0.4s ease-in-out; }
        #loading-overlay.show { display: flex; opacity: 1; }
        .new-loader-container { width: 100px; height: 100px; position: relative; display: flex; align-items: center; justify-content: center; margin-bottom: 1rem; }
        .new-loader-content { width: 50vmin; height: 50vmin; max-width: 100%; max-height: 100%; position: relative; display: flex; align-items: center; justify-content: center; transform: scale(0.2); animation: spin-all calc(var(--loader-sp) * 2) linear 0s infinite; }
        .new-loader-circle { --ar: var(--accent-primary); --dt: var(--accent-secondary); --shadow: drop-shadow(0vmin 0vmin 0.5vmin rgba(0,0,0,0.5)) drop-shadow(0vmin 0.5vmin 0.5vmin rgba(0,0,0,0.3)); --cross: linear-gradient(0deg, #fff0 calc(50% - 1px), rgba(255,255,255,0.2) calc(50% - 0.5px) calc(50% + 0.5px), #fff0 calc(50% + 1px)), linear-gradient(90deg, #fff0 calc(50% - 1px), rgba(255,255,255,0.2) calc(50% - 0.5px) calc(50% + 0.5px), #fff0 calc(50% + 1px)); --in: 80%; border: 6vmin solid var(--ar); width: var(--in); height: var(--in); border-radius: 100%; position: absolute; box-sizing: border-box; border-top-color: #fff0; border-left-color: #fff0; top: 15vmin; right: -10vmin; animation: spin-bot var(--loader-sp) ease 0s infinite; background-image: var(--cross), radial-gradient(var(--dt) 5.5vmin, #fff0 calc(5.5vmin + 1px)); background-repeat: no-repeat; background-size: 3vmin 1vmin, 1vmin 3vmin, 100% 100%; background-position: center center; filter: var(--shadow); }
        .new-loader-circle:nth-child(2) { --in: 60%; top: -2vmin; animation: spin-top var(--loader-sp) ease 0s infinite; transform: rotate(-45deg); background-image: var(--cross), radial-gradient(var(--dt) 1.25vmin, #fff0 calc(1.25vmin + 1px)); right: -4vmin; filter: hue-rotate(15deg) var(--shadow); background-size: 1.4vmin 1vmin, 1vmin 1.4vmin, 100% 100%; }
        .new-loader-circle:nth-child(3) { --in: 100%; top: -5vmin; left: -13vmin; transform: rotate(175deg); animation: spin-left var(--loader-sp) ease calc(var(--loader-sp) / 4) infinite; background-image: var(--cross), radial-gradient(var(--dt) 9vmin, #fff0 calc(9vmin + 1px)); filter: hue-rotate(30deg) var(--shadow); background-size: 5vmin 1vmin, 1vmin 5vmin, 100% 100%; }
        .new-loader-circle:nth-child(4) { --in: 60%; top: 35vmin; left: -6vmin; transform: rotate(-280deg); animation: spin-last var(--loader-sp) ease calc(calc(calc(var(--loader-sp) / 4) + var(--loader-sp)) * -1) infinite; background-image: var(--cross), radial-gradient(var(--dt) 2.5vmin, #fff0 calc(2.5vmin + 1px)); filter: hue-rotate(45deg) var(--shadow); background-size: 2vmin 1vmin, 1vmin 2vmin, 100% 100%; }
        @keyframes spin-all { 0% { transform: rotate(0deg) scale(0.2); } 100% { transform: rotate(360deg) scale(0.2); } } @keyframes spin-top { 0% { transform: rotate(-45deg); } 100% { transform: rotate(315deg); } } @keyframes spin-bot { 0%, 35% { transform: rotate(0deg); } 80%, 100% { transform: rotate(-360deg); } } @keyframes spin-left { 0%, 35% { transform: rotate(175deg); } 80%, 100% { transform: rotate(535deg); } } @keyframes spin-last { 0%, 10% { transform: rotate(-280deg); } 90%, 100% { transform: rotate(-640deg); } }
        #loading-overlay p { font-weight: 500; color: var(--text-primary); margin-top: 1rem; font-size: 1.2em; text-align: center; max-width: 80%; }

        /* --- Navigation (Unchanged + New Button Style) --- */
        .main-nav { background-color: rgba(44, 44, 48, 0.8); backdrop-filter: blur(10px); color: var(--text-primary); position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; padding: 0 2rem; height: var(--nav-height); }
        .logo { font-weight: 600; font-size: 1.4rem; color: var(--text-primary); text-decoration: none; user-select: none; display: flex; align-items: center; gap: 0.5rem; }
        .logo img { max-height: 40px; width: auto; object-fit: contain; vertical-align: middle; }
        .main-nav ul { list-style: none; display: flex; align-items: center; gap: 1.5rem; }
        .main-nav ul li a { color: var(--text-secondary); text-decoration: none; padding: 0.5rem 0.8rem; font-size: 1rem; font-weight: 500; border-radius: var(--border-radius-sm); transition: color 0.3s ease, background-color 0.3s ease; position: relative; overflow: hidden; cursor: pointer; }
        .main-nav ul li a::after { content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px; background: var(--accent-gradient); transform: scaleX(0); transform-origin: right; transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1); }
        .main-nav ul li a:hover, .main-nav ul li a.active { color: var(--text-primary); background-color: rgba(255, 255, 255, 0.05); }
        .main-nav ul li a.active::after { transform: scaleX(1); transform-origin: left; }
        #settings-box { display: flex; align-items: center; gap: 0.6rem; }
        #settings-box label { font-size: 0.9rem; color: var(--text-secondary); }
        #settings-box select { padding: 0.4rem 0.6rem; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); background-color: var(--bg-card); color: var(--text-primary); font-size: 0.9rem; cursor: pointer; transition: border-color 0.3s ease, box-shadow 0.3s ease; }
        #settings-box select:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 2px rgba(106, 142, 231, 0.3); }
        
        /* New Icon Button Style */
        .main-nav #settings-box .btn-icon {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 0.4rem; /* Adjust padding as needed */
            margin-left: 0.4rem; /* Space from select */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--border-radius-sm);
            transition: color 0.3s ease, background-color 0.3s ease;
        }
        .main-nav #settings-box .btn-icon:hover {
            color: var(--text-primary);
            background-color: rgba(255, 255, 255, 0.05);
        }
        .main-nav #settings-box .btn-icon svg {
            width: 20px; /* Adjust icon size */
            height: 20px; /* Adjust icon size */
            fill: currentColor;
        }


        /* --- General Content & Pages (Unchanged) --- */
        .container { max-width: 1100px; margin: 0 auto; padding: 0 1.5rem; }
        .page { display: none; animation: sectionFadeIn 0.8s ease-out forwards; width: 100%; flex-grow: 1; position: relative; }
        .page.active { display: flex; flex-direction: column; }
        @keyframes sectionFadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Home Page (Unchanged) --- */
        #home-page { text-align: center; padding-top: 3rem; align-items: center; justify-content: center;}
        .hero-section { padding: 4rem 1rem; border-radius: var(--border-radius-md); background: rgba(44, 44, 48, 0.65); margin-bottom: 3rem; position: relative; overflow: hidden; width: 100%; max-width: 1100px; }
        .hero-section::before { content: ''; position: absolute; inset: 0; z-index: 0; opacity: 0.6; background: radial-gradient(circle at top left, rgba(106, 142, 231, 0.08), transparent 60%), radial-gradient(circle at bottom right, rgba(228, 118, 228, 0.08), transparent 60%); animation: pulseGlow 10s infinite alternate ease-in-out; }
        @keyframes pulseGlow { from { opacity: 0.4; transform: scale(1); } to { opacity: 0.8; transform: scale(1.03); } }
        .hero-content { position: relative; z-index: 1; }
        .hero-section h1 { font-size: clamp(2rem, 5vw, 3.2rem); font-weight: 700; margin-bottom: 1.5rem; color: var(--text-primary); line-height: 1.3; animation: textFadeUp 1s 0.2s ease-out forwards; opacity: 0; }
        @keyframes textFadeUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .hero-section .tagline { font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 2.5rem; max-width: 650px; margin-left: auto; margin-right: auto; animation: textFadeUp 1s 0.4s ease-out forwards; opacity: 0; }
        .hero-section .btn { animation: buttonScaleIn 0.8s 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; opacity: 0; transform: scale(0.8); }
        @keyframes buttonScaleIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        /* --- About Page (Unchanged) --- */
        #about-page { padding-top: 3rem; align-items: center; }
        #about-page .content-container { max-width: 850px; margin: 0 auto; padding: 2.5rem; background-color: var(--bg-card); border-radius: var(--border-radius-md); box-shadow: var(--box-shadow-soft); width: 100%; }
        #about-page h2 { font-size: 2rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--accent-primary); text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 0.8rem; }
        #about-page p { font-size: 1.05rem; color: var(--text-secondary); text-align: justify; line-height: 1.8; }
        #about-page .btn-back { display: block; width: fit-content; margin: 2rem auto 0 auto; }


        /* --- START: Generate Page Redesign (Unchanged from original) --- */
        #feature-page.active {
            display: flex; flex-direction: row; align-items: stretch;
            padding: 0; height: calc(100vh - var(--nav-height)); overflow: hidden;
        }

        .input-sidebar {
            width: var(--sidebar-width); flex-shrink: 0;
            background-color: var(--bg-card); padding: 2rem 1.5rem;
            border-right: 1px solid var(--border-color);
            display: flex; flex-direction: column;
            overflow-y: auto; height: 100%;
        }

        .form-container {
             padding: 0; background-color: transparent; box-shadow: none;
             max-width: 100%; margin: 0; display: flex;
             flex-direction: column; flex-grow: 1;
        }

        .input-sidebar h1 {
            font-size: 1.6rem; font-weight: 600; text-align: left;
            margin-bottom: 1.8rem; padding-bottom: 0.8rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--accent-gradient); -webkit-background-clip: text; background-clip: text; color: transparent;
            flex-shrink: 0;
        }
        .input-sidebar #feature-form { flex-grow: 1; display: flex; flex-direction: column; }

        .form-group { margin-bottom: 1.5rem; flex-shrink: 0; } /* Added consistent bottom margin */
        .form-group label { display: block; /* Ensure label is on its own line */ margin-bottom: 0.6rem; font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); }

        /* Consistent Input Styling */
        .form-group input[type="text"],
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.8rem 0.9rem;
            font-size: 0.95rem;
            background-color: var(--input-bg-color); /* Use dedicated input bg */
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm); /* Consistent radius */
            color: var(--text-primary);
            font-family: inherit;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .form-group input[type="text"]:focus,
        .form-group textarea:focus,
        .form-group select:focus {
             outline: none;
             border-color: var(--accent-primary);
             box-shadow: 0 0 0 3px rgba(106, 142, 231, 0.2);
        }
        /* Specific Input Sizes */
        .form-group textarea#lyrics-input {
            min-height: 160px; /* Larger height */
            resize: vertical;
        }
        .form-group textarea#transcript-output {
             min-height: 80px;
             font-size: 0.9rem;
             background-color: #333; /* Keep slightly different bg for readonly */
             cursor: default;
        }
        .form-group select {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23a9a9b3" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat; background-position: right 1rem center; background-size: 20px; padding-right: 3rem; cursor: pointer;
        }
        .form-group select option[disabled] { color: #777; }

        /* Button Consistency */
        #generate-lyrics-button {
             margin-top: 0.8rem; /* Space above button */
             padding: 0.7rem 1.3rem; /* Slightly adjusted padding */
             font-size: 0.9rem;
             width: auto; /* Allow natural width */
             display: inline-block; /* Align with potential future elements */
        }

        /* Audio Input Group Alignment */
        .audio-input-group {
             display: flex;
             flex-wrap: wrap; /* Allow wrapping */
             align-items: center; /* Vertically align items */
             gap: 1rem; /* Space between elements */
             margin-top: 0.3rem; /* Small space below label */
        }
        .form-group input[type="file"] {
             padding: 0; cursor: pointer; flex-grow: 1; min-width: 150px; margin-bottom: 0;
             background-color: transparent; border: none; box-shadow: none; color: var(--text-secondary);
             font-size: 0.9rem; /* Match other inputs */
        }
        input[type="file"]::file-selector-button {
             padding: 0.7rem 1rem; /* Consistent padding */
             margin-right: 0.8rem; border: none; border-radius: var(--border-radius-sm);
             background: linear-gradient(135deg, #4f4f55, #414145); /* Slightly adjusted secondary button look */
             color: var(--text-primary);
             cursor: pointer; transition: background 0.3s ease, transform 0.1s ease; font-weight: 500;
             font-size: 0.9rem; /* Match other buttons */
        }
        input[type="file"]::file-selector-button:hover { background: linear-gradient(135deg, #5a5a60, #48484d); transform: translateY(-1px); }
        #record-audio-button {
             padding: 0.7rem 1.3rem; /* Consistent padding */
             font-size: 0.9rem; /* Match other buttons */
             flex-shrink: 0; /* Prevent shrinking */
        }
        #record-status {
             font-size: 0.9rem;
             flex-basis: 100%; /* Force status to new line if wrapping */
             text-align: left; /* Keep text aligned left */
             margin-top: 0.2rem; /* Small space when wrapped */
             min-height: 20px; /* Ensure space */
        }
        .form-group small { font-size: 0.85em; display: block; margin-top: 0.8rem; /* Ensure consistent space */ }


        #generate-concept-button {
            width: 100%; max-width: none; margin-top: auto; /* Push to bottom */
            padding: 0.9rem 1.5rem; font-size: 1rem; flex-shrink: 0;
        }

        /* --- Output Area & States (Unchanged from previous refinement) --- */
        .output-area { flex-grow: 1; background-color: var(--bg-output-area); padding: 2.5rem; overflow-y: auto; height: 100%; position: relative; display: flex; flex-direction: column; }
        #initial-prompt { display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; height: 100%; color: var(--text-secondary); }
        #initial-prompt .prompt-icon { font-size: 4rem; margin-bottom: 1.5rem; opacity: 0.5; display: block; width: 60px; height: 60px; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23a9a9b3" opacity="0.5"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/></svg>'); background-repeat: no-repeat; background-position: center; background-size: contain; }
        #initial-prompt p { font-size: 1.1rem; max-width: 450px; }
        #concept-display-area { display: none; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 2rem; background-color: var(--bg-card); border-radius: var(--border-radius-md); box-shadow: var(--box-shadow-soft); margin: auto; max-width: 700px; width: 90%; animation: fadeInScaleUp 0.5s ease-out forwards; }
        @keyframes fadeInScaleUp { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        #concept-display-area h2 { font-size: 1.5rem; font-weight: 600; color: var(--accent-primary); margin-bottom: 1.5rem; width: 100%; text-align: center; }
        #concept-text-output { font-size: 1rem; color: var(--text-secondary); line-height: 1.7; margin-bottom: 2.5rem; white-space: pre-wrap; max-height: 50vh; overflow-y: auto; width: 100%; text-align: left; padding: 1rem; background-color: rgba(0,0,0,0.1); border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); }
        .concept-actions { display: flex; gap: 1.5rem; justify-content: center; width: 100%; }
        .concept-actions .btn { padding: 0.8rem 1.8rem; font-size: 1rem; }
        #tabbed-results-area { display: none; flex-direction: column; height: 100%; width: 100%; animation: fadeIn 0.6s ease-out forwards; }
         @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .results-tabs { display: flex; flex-wrap: wrap; gap: 0.5rem; padding-bottom: 1rem; margin-bottom: 1.5rem; border-bottom: 2px solid var(--border-color); flex-shrink: 0; }
        .results-tabs button { padding: 0.7rem 1.3rem; font-size: 0.95rem; font-weight: 500; color: var(--text-secondary); background-color: transparent; border: none; border-bottom: 3px solid transparent; cursor: pointer; transition: color 0.3s ease, border-color 0.3s ease, background-color 0.3s ease; border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0; white-space: nowrap; }
        .results-tabs button:hover { color: var(--text-primary); background-color: rgba(255, 255, 255, 0.05); }
        .results-tabs button.active { color: var(--text-primary); font-weight: 600; border-bottom: 3px solid; border-image-slice: 1; border-image-source: var(--accent-gradient); }
        .tab-content-area { flex-grow: 1; overflow-y: auto; padding: 0.5rem; position: relative; } /* Added this wrapper */
        .tab-content { display: none; animation: sectionFadeIn 0.6s ease-out forwards; background-color: var(--bg-card); border-radius: var(--border-radius-md); padding: 1.8rem; box-shadow: var(--box-shadow-soft); border: 1px solid var(--border-color); margin-bottom: 1rem; }
        .tab-content.active { display: block; }
        .tab-content h2 { font-size: 1.5rem; font-weight: 600; color: var(--accent-primary); margin-bottom: 1.2rem; padding-bottom: 0.6rem; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 0.5rem; }
        .tab-content p, .tab-content ul, .tab-content div:not(.budget-columns-container):not(.image-placeholder-container):not(.color-palette-display):not(.font-suggestion) { font-size: 0.95rem; color: var(--text-secondary); line-height: 1.7; } /* Avoid applying to structural divs */
        .tab-content p:not(:last-child), .tab-content ul:not(:last-child), .tab-content > div:not(.budget-columns-container):not(.image-placeholder-container):not(.color-palette-display):not(.font-suggestion):not(:last-child) { margin-bottom: 1rem; }
        .tab-content strong { color: var(--text-primary); font-weight: 600; }
        #tab-content-requirements ul { margin: 0.5rem 0 0 0; padding-left: 0; list-style: none; }
        #tab-content-requirements li:not(.placeholder-notice) { margin-bottom: 0.8rem; padding-left: 1.8rem; position: relative; }
        #tab-content-requirements li:not(.placeholder-notice)::before { content: '✓'; color: var(--accent-primary); font-size: 1.1em; font-weight: 600; position: absolute; left: 0; top: 1px; transition: transform 0.3s ease; }
        #tab-content-requirements li:not(.placeholder-notice):hover::before { transform: scale(1.2) rotate(-10deg); }
        #tab-content-budget .budget-columns-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1.2rem; margin-top: 1rem; }
        #tab-content-budget .budget-column { border: 1px solid var(--border-color); padding: 1.2rem; border-radius: var(--border-radius-sm); background-color: rgba(26, 26, 29, 0.7); display: flex; flex-direction: column; transition: background-color 0.3s ease; min-height: 180px; }
        #tab-content-budget .budget-column:hover { background-color: rgba(40, 40, 43, 0.8); }
        #tab-content-budget .budget-column h3 { margin-top: 0; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #555; color: var(--text-primary); font-size: 1.1rem; font-weight: 600; flex-shrink: 0; text-align: center; }
        #tab-content-budget .budget-column p { font-size: 0.95rem; line-height: 1.7; color: var(--text-secondary); white-space: normal; margin-bottom: 0; flex-grow: 1; }
        #tab-content-budget .budget-column .budget-item-box { border: 1px solid #555; background-color: var(--bg-dark); padding: 0.6rem 0.8rem; margin-top: 0.8rem; margin-bottom: 0.6rem; border-radius: 4px; font-size: 0.85em; box-shadow: 0 1px 2px rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: center; }
        #tab-content-budget .budget-column .budget-item-box strong { color: var(--text-primary); margin-left: 0.5rem; white-space: nowrap; font-weight: 600; }
        #tab-content-budget .budget-column.placeholder-notice { border-style: dashed; opacity: 0.7; }
        #tab-content-budget .budget-column.placeholder-notice h3 { color: var(--text-secondary); border-bottom-color: rgba(85, 85, 85, 0.5); }
        #tab-content-budget .budget-column.placeholder-notice p.placeholder-notice { text-align: center; font-style: italic; color: var(--text-secondary); margin-top: 1rem; font-size: 0.95rem; line-height: 1.7; }
        #tab-content-budget .budget-columns-container.placeholder-notice { display: block; text-align: center; padding: 1rem; }
        #tab-content-budget .budget-columns-container.placeholder-notice .budget-column { display: none; }
        #tab-content-budget .raw-budget-output pre { white-space: pre-wrap; font-family: monospace; font-size: 1.2em; text-align: left; background-color: rgba(0,0,0,0.3); border: 1px dashed var(--border-color); color: var(--text-secondary); padding: 1rem; border-radius: var(--border-radius-sm); margin-top: 0.5rem; max-height: 250px; overflow-y: auto; }
        #tab-content-budget > small { display: block; text-align: center; margin-top: 1.5rem; font-size: 0.85em; opacity: 0.8; }
        #tab-content-visuals .image-placeholder-container, #tab-content-moodboard .image-placeholder-container { display: grid; gap: 1.2rem; margin-top: 1rem; }
        #tab-content-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
        #tab-content-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
        #tab-content-visuals .image-placeholder, #tab-content-moodboard .image-placeholder { border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); background-color: var(--bg-dark); overflow: hidden; text-align: center; color: var(--text-secondary); box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: transform 0.3s ease, box-shadow 0.3s ease; position: relative; }
        #tab-content-visuals .image-placeholder:hover, #tab-content-moodboard .image-placeholder:hover { transform: scale(1.03); box-shadow: 0 5px 12px rgba(0,0,0,0.3); z-index: 5; }
        #tab-content-visuals .image-placeholder img, #tab-content-moodboard .image-placeholder img { display: block; width: 100%; object-fit: cover; background-color: #444; border-bottom: 1px solid var(--border-color); opacity: 0; transition: opacity 0.5s ease-in-out; }
        #tab-content-visuals .image-placeholder img[src]:not([src=""]), #tab-content-moodboard .image-placeholder img[src]:not([src=""]) { opacity: 1; }
        #tab-content-visuals .image-placeholder img { height: 160px; }
        #tab-content-moodboard .image-placeholder img { height: 130px; }
        #tab-content-visuals .image-placeholder figcaption, #tab-content-moodboard .image-placeholder figcaption { font-size: 0.85em; padding: 0.8rem; background-color: var(--bg-card); min-height: 55px; line-height: 1.4; color: var(--text-secondary); }
        #tab-content-visuals .image-placeholder figcaption strong, #tab-content-moodboard .image-placeholder figcaption strong { color: var(--text-primary); }
        #tab-content-visuals .image-placeholder figcaption .generation-source, #tab-content-moodboard .image-placeholder figcaption .generation-source, #tab-content-visuals .image-placeholder figcaption .fallback-notice, #tab-content-moodboard .image-placeholder figcaption .fallback-notice { font-size: 0.8em; display: block; margin-top: 5px; font-style: italic; }
        #tab-content-visuals .image-placeholder figcaption .generation-source, #tab-content-moodboard .image-placeholder figcaption .generation-source { color: var(--accent-primary); }
        #tab-content-visuals .image-placeholder figcaption .fallback-notice, #tab-content-moodboard .image-placeholder figcaption .fallback-notice { color: #888; }
         #tab-content-visuals > small, #tab-content-moodboard > small { display: block; margin-top: 1.5rem; font-size: 0.85em; opacity: 0.8; }
        #tab-content-palette .color-palette-display { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 1rem; align-items: stretch; }
        #tab-content-palette .color-swatch { min-width: 120px; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); display: flex; flex-direction: column; align-items: center; justify-content: flex-start; font-size: 0.85em; font-weight: 500; text-align: center; overflow: hidden; box-shadow: 0 1px 4px rgba(0,0,0,0.15); transition: transform 0.25s ease, box-shadow 0.25s ease; flex-grow: 1; opacity: 0; transform: scale(0.8); padding: 0; }
        #tab-content-palette .color-swatch.visible { opacity: 1; transform: scale(1); transition: opacity 0.4s ease-out, transform 0.4s ease-out; }
        #tab-content-palette .color-swatch:hover { transform: scale(1.05); box-shadow: 0 4px 10px rgba(0,0,0,0.25); z-index: 5; }
        #tab-content-palette .color-swatch .color-block { width: 100%; height: 70px; display: flex; align-items: center; justify-content: center; border-bottom: 1px solid rgba(0,0,0,0.1); }
        #tab-content-palette .color-swatch .hex-code { margin-top: 0; font-size: 0.9em; font-family: monospace; user-select: all; opacity: 0.8; padding: 0.3rem; }
        #tab-content-palette .color-swatch .color-info { padding: 0.8rem; width: 100%; flex-grow: 1; display: flex; flex-direction: column; background-color: rgba(0,0,0,0.1); }
        #tab-content-palette .color-swatch .color-name { font-weight: 600; display: block; margin-bottom: 0.4rem; word-break: break-word; }
        #tab-content-palette .color-swatch .color-application { font-size: 0.9em; line-height: 1.4; color: var(--text-secondary); word-break: break-word; text-align: left; }
        #tab-content-palette .color-swatch.dominant-swatch { border: 2px solid var(--accent-primary); box-shadow: 0 2px 8px rgba(106, 142, 231, 0.2); }
        #tab-content-fonts .font-suggestion { margin-bottom: 1.8rem; padding-bottom: 1.5rem; border-bottom: 1px dashed var(--border-color); }
        #tab-content-fonts .font-suggestion:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        #tab-content-fonts h3 { font-size: 1.2rem; color: var(--text-primary); margin-bottom: 0.6rem; font-weight: 600; }
        #tab-content-fonts .font-reason { font-style: italic; margin-bottom: 1rem; font-size: 0.95em; }
        #tab-content-fonts .font-sample { background-color: rgba(0,0,0,0.15); padding: 0.8rem 1rem; border-radius: var(--border-radius-sm); margin-bottom: 0.8rem; border-left: 3px solid var(--accent-secondary); font-size: 1.1em; }
        #tab-content-fonts .font-sample strong { color: var(--accent-primary); font-weight: 600; margin-right: 0.5rem; }

        /* --- END: Generate Page Redesign --- */


        /* Action Buttons (General, might not be needed in tabs) */
        .action-buttons { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; flex-shrink: 0; width: 100%; }
        #download-action-area {
            display: none; /* Initially hidden */
            /* Styles moved to .action-buttons for consistency */
        }


        /* --- General Button Styling (Unchanged) --- */
        .btn { display: inline-block; padding: 0.8rem 1.8rem; border: none; border-radius: var(--border-radius-sm); cursor: pointer; font-size: 1rem; font-weight: 600; text-align: center; text-decoration: none; color: var(--text-primary); background: var(--accent-gradient); transition: transform 0.2s ease, box-shadow 0.3s ease, background-size 0.4s ease, opacity 0.3s ease; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); position: relative; overflow: hidden; z-index: 1; user-select: none; }
        .btn::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%); transition: left 0.5s ease; z-index: -1; }
        .btn:hover:not(:disabled) { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 15px rgba(106, 142, 231, 0.3); }
        .btn:hover:not(:disabled)::before { left: 100%; }
        .btn:active:not(:disabled) { transform: translateY(0) scale(0.98); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; background: #555; box-shadow: none; }
        .btn-secondary { background: linear-gradient(135deg, #5a5a60, #404045); }
        .btn-secondary:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(80, 80, 80, 0.3); }
        .btn-warning { background: linear-gradient(135deg, var(--warning-color), #d4a00e); color: #222; }
        .btn-warning:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(255, 183, 3, 0.4); color: #000; }
        .btn-danger { background: linear-gradient(135deg, var(--error-color), #b82c3a); }
        .btn-danger:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(230, 57, 70, 0.4); }
        .btn-success { background: linear-gradient(135deg, var(--success-color), #3a9a70); } /* Added success button style */
        .btn-success:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(87, 204, 153, 0.4); }

        #home-page .btn-back, #about-page .btn-back { display: block; width: fit-content; margin: 2rem auto 0 auto; }
        #feature-page .btn-back { display: none; }


        /* --- Error Message (Place within output-area if needed) --- */
        #error-message {
            background-color: rgba(230, 57, 70, 0.15); color: var(--error-color); border: 1px solid rgba(230, 57, 70, 0.5);
            padding: 1rem 1.3rem; /* Slightly smaller padding */ border-radius: var(--border-radius-sm); margin: 1rem auto; text-align: center;
            font-weight: 500; display: none; max-width: 90%; /* Adjust width */ width: fit-content; white-space: pre-wrap; font-size: 0.9rem; /* Smaller text */
        }
         /* Error styling within tabs */
        .tab-content p.error { color: var(--error-color); font-weight: 500; }


        /* --- Footer (Unchanged) --- */
        .main-footer { background-color: #111; color: var(--text-secondary); padding: 1.5rem 0; text-align: center; font-size: 0.9rem; margin-top: auto; position: relative; z-index: 1; flex-shrink: 0; }
        .main-footer p { margin: 0; }
        .main-footer a { color: var(--accent-primary); text-decoration: none; transition: color 0.3s ease; }
        .main-footer a:hover { color: var(--accent-secondary); }

        /* --- Utility Placeholders (Unchanged) --- */
        .placeholder-notice { font-style: italic; color: var(--text-secondary); opacity: 0.8; text-align: center; padding: 1rem; font-size: 0.9em; }
        #tab-content-requirements ul .placeholder-notice { padding: 0; text-align: left; list-style: none; margin-left: 1.8rem; }
        #tab-content-requirements ul .placeholder-notice::before { display: none; }
        #tab-content-budget .budget-columns-container.placeholder-notice,
        #tab-content-visuals .image-placeholder-container.placeholder-notice,
        #tab-content-moodboard .image-placeholder-container.placeholder-notice,
        #tab-content-palette .color-palette-display.placeholder-notice,
        #tab-content-fonts p.placeholder-notice { display: block; text-align: center; padding: 1rem; }


        /* --- How to Use Button and Modal (Unchanged) --- */
        #how-to-use-button { position: fixed; bottom: 20px; right: 20px; z-index: 1001; padding: 0.6rem 1.2rem; font-size: 0.9rem; border-radius: 50px; background: var(--accent-secondary); box-shadow: var(--box-shadow-soft); }
         #how-to-use-button:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(228, 118, 228, 0.4); transform: translateY(-2px) scale(1.05); }
        #guide-modal { position: fixed; inset: 0; background-color: rgba(26, 26, 29, 0.8); backdrop-filter: blur(4px); display: none; justify-content: center; align-items: center; z-index: 1002; padding: 1rem; opacity: 0; transition: opacity 0.3s ease-in-out; }
         #guide-modal.show { display: flex; opacity: 1; }
        #guide-modal-content { background-color: var(--bg-card); padding: 2.5rem; border-radius: var(--border-radius-md); max-width: 700px; width: 90%; max-height: 85vh; overflow-y: auto; position: relative; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4); border: 1px solid var(--border-color); transform: scale(0.95); transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
         #guide-modal.show #guide-modal-content { transform: scale(1); }
        #guide-modal-content h3 { font-size: 1.8rem; font-weight: 600; color: var(--accent-primary); text-align: center; margin-bottom: 2rem; padding-bottom: 0.8rem; border-bottom: 1px solid var(--border-color); }
        #guide-modal-content h4 { font-size: 1.2rem; color: var(--text-primary); margin-top: 1.5rem; margin-bottom: 0.6rem; font-weight: 600; }
        #guide-modal-content p, #guide-modal-content li { font-size: 0.95rem; color: var(--text-secondary); line-height: 1.7; margin-bottom: 0.5rem; }
        #guide-modal-content ul { padding-left: 20px; margin-top: 0.5rem; }
        #guide-modal-content strong { color: var(--text-primary); font-weight: 500; }
        #close-guide-modal { position: absolute; top: 15px; right: 20px; background: none; border: none; font-size: 1.8rem; color: var(--text-secondary); cursor: pointer; padding: 5px; line-height: 1; transition: color 0.2s ease, transform 0.2s ease; }
        #close-guide-modal:hover { color: var(--text-primary); transform: scale(1.1) rotate(90deg); }

        /* --- START: Music Player Modal Styles --- */
        #music-modal {
            position: fixed; inset: 0; background-color: rgba(26, 26, 29, 0.8);
            backdrop-filter: blur(4px); display: none; justify-content: center;
            align-items: center; z-index: 1003; /* Higher than guide modal */
            padding: 1rem; opacity: 0; transition: opacity 0.3s ease-in-out;
        }
        #music-modal.show { display: flex; opacity: 1; }
        #music-modal-content {
            background-color: var(--bg-card); padding: 2rem;
            border-radius: var(--border-radius-md); max-width: 400px; /* Smaller modal */
            width: 90%; position: relative; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border-color); transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center; /* Center content */
        }
        #music-modal.show #music-modal-content { transform: scale(1); }
        #music-modal-content h3 {
            font-size: 1.5rem; font-weight: 600; color: var(--accent-primary);
            margin-bottom: 1.5rem; padding-bottom: 0.8rem;
            border-bottom: 1px solid var(--border-color);
        }
        #close-music-modal { /* Shared style with #close-guide-modal practically */
            position: absolute; top: 10px; right: 15px; background: none;
            border: none; font-size: 1.8rem; color: var(--text-secondary);
            cursor: pointer; padding: 5px; line-height: 1;
            transition: color 0.2s ease, transform 0.2s ease;
        }
        #close-music-modal:hover { color: var(--text-primary); transform: scale(1.1) rotate(90deg); }

        .music-controls {
            display: flex;
            align-items: center;
            justify-content: center; /* Center controls */
            gap: 1.5rem;
            margin-top: 1rem;
        }
        .music-controls button#play-pause-music-button {
            background-color: var(--input-bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.8rem;
            border-radius: 50%; /* Circular button */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px; /* Fixed size */
            height: 50px; /* Fixed size */
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        .music-controls button#play-pause-music-button:hover {
            background-color: var(--bg-card-hover);
            transform: scale(1.05);
        }
        .music-controls button#play-pause-music-button svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
        .music-controls input[type="range"] {
            flex-grow: 1;
            max-width: 200px; /* Limit slider width */
            accent-color: var(--accent-primary); /* Modern way to style slider thumb */
            cursor: pointer;
            background: var(--input-bg-color); /* Match other inputs */
            border-radius: var(--border-radius-sm);
            padding: 0.2rem 0; /* Minor vertical padding for track */
        }
        /* Custom track styles for WebKit */
        .music-controls input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: var(--border-color);
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--bg-dark);
        }
        .music-controls input[type="range"]::-webkit-slider-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -6px; /* (track height - thumb height) / 2 + border */
            box-shadow: var(--box-shadow-glow);
        }
        /* Custom track styles for Mozilla */
        .music-controls input[type="range"]::-moz-range-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: var(--border-color);
            border-radius: var(--border-radius-sm);
             border: 1px solid var(--bg-dark);
        }
        .music-controls input[type="range"]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            border: none;
            box-shadow: var(--box-shadow-glow);
        }
        /* --- END: Music Player Modal Styles --- */


        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
            :root { --sidebar-width: var(--sidebar-width-md); }
            .container { max-width: 90%; }
            .main-nav ul { gap: 1rem; }
            .main-nav ul li a { font-size: 0.95rem; padding: 0.4rem 0.6rem; }
            #settings-box label { display: none; } /* Hide label for lang select */
            #settings-box { gap: 0.4rem; } /* Reduce gap in settings box */
            .main-nav #settings-box .btn-icon { padding: 0.3rem; }
            .input-sidebar { padding: 1.5rem 1rem; }
            .output-area { padding: 2rem; }
            #concept-display-area { padding: 1.5rem; }
            .results-tabs button { padding: 0.6rem 1rem; font-size: 0.9rem; }
            .tab-content { padding: 1.5rem; }
            #guide-modal-content { padding: 2rem; }
            #music-modal-content { padding: 1.5rem; max-width: 360px; }
            #music-modal-content h3 { font-size: 1.3rem; }
            .music-controls { gap: 1rem; }
            .music-controls button#play-pause-music-button { width: 45px; height: 45px; }
            .music-controls button#play-pause-music-button svg { width: 20px; height: 20px; }
            #tab-content-budget .budget-columns-container { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
        }

        @media (max-width: 768px) {
            html { font-size: 15px; }
            :root { --nav-height: auto; /* Allow nav to wrap */ min-height: 60px; } /* Responsive nav */
            main { padding-top: 60px; /* Adjust based on min-height */ }
             #feature-page.active { flex-direction: column; height: auto; overflow-y: auto; overflow-x: hidden; }
             .input-sidebar { width: 100%; border-right: none; border-bottom: 1px solid var(--border-color); height: auto; max-height: none; /* Remove max-height for scroll */ overflow-y: visible; /* Let page scroll handle it */ padding-bottom: 1.5rem; }
             .output-area { height: auto; min-height: 50vh; /* Give output more min-height */ padding: 1.5rem; overflow-y: visible; }
            #generate-concept-button { margin-top: 2rem; /* More definite space */ }
             .main-nav { padding: 0 1.5rem; flex-wrap: wrap; height: auto; min-height: 60px; align-content: center; }
            .logo { font-size: 1.2rem; padding: 0.5rem 0; }
            .main-nav ul { order: 3; width: 100%; justify-content: center; padding: 0.5rem 0; border-top: 1px solid var(--border-color); margin-top: 0.5rem; gap: 0.8rem; }
            #settings-box { order: 2; margin-left: auto; padding-bottom: 0.5rem; } /* Keep settings box with lang and music */
            .hero-section { padding: 3rem 0.5rem; }
            .hero-section h1 { font-size: clamp(1.8rem, 6vw, 2.5rem); }
            .hero-section .tagline { font-size: 1rem; }
            #about-page .content-container { padding: 1.5rem; }
            #how-to-use-button { bottom: 15px; right: 15px; padding: 0.5rem 1rem; font-size: 0.85rem; }
            #guide-modal-content { padding: 1.5rem; max-height: 80vh; }
            #guide-modal-content h3 { font-size: 1.5rem; }
            #close-guide-modal, #close-music-modal { top: 10px; right: 15px; font-size: 1.6rem; }
            .new-loader-content { transform: scale(0.18); }
            /* Stack budget columns */
            #tab-content-budget .budget-columns-container { grid-template-columns: 1fr; gap: 1rem; }
            #tab-content-budget .budget-column { min-height: auto; }
            /* Adjust image grids */
            #tab-content-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            #tab-content-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            /* Adjust audio group wrapping */
            .audio-input-group { align-items: flex-start; }
            #record-status { flex-basis: auto; /* Allow status next to button if space */ margin-top: 0; }
        }

        @media (max-width: 480px) {
            html { font-size: 14px; }
             .main-nav { padding: 0 1rem; }
             .main-nav ul { gap: 0.5rem; flex-wrap: wrap; justify-content: space-around; }
             .main-nav ul li a { padding: 0.4rem; font-size: 0.9rem; }
             #settings-box { width: auto; /* Don't make settings full width if nav items wrap below */ order: 2; margin-left:auto; } /* Keep settings on right */

             .input-sidebar { padding: 1.5rem 1rem; }
             .output-area { padding: 1rem; }
             .input-sidebar h1 { font-size: 1.5rem; }
             .form-group { margin-bottom: 1.2rem; }
             .form-group input[type="text"], .form-group textarea, .form-group select { font-size: 0.9rem; }
             textarea#lyrics-input { min-height: 140px; }
             .audio-input-group { flex-direction: column; align-items: stretch; gap: 0.8rem; }
             input[type="file"]::file-selector-button { width: 100%; text-align: center; margin-right: 0; }
             .audio-input-group .btn { width: 100%; margin: 0;}
             #record-status { margin-left: 0; justify-content: center; width: 100%; margin-top: 0.3rem; }
             #generate-concept-button { padding: 0.8rem 1.2rem; font-size: 0.95rem; }
             #generate-lyrics-button { width: 100%; margin-top: 1rem; padding: 0.7rem 1.2rem; font-size: 0.9rem; }
             .btn { padding: 0.7rem 1.5rem; font-size: 0.95rem; }
            #concept-display-area { padding: 1rem; max-width: 95%; }
            #concept-display-area h2 { font-size: 1.3rem; }
            #concept-text-output { font-size: 0.9rem; }
            .concept-actions { flex-direction: column; gap: 0.8rem; }
            .concept-actions .btn { width: 100%; }
             .results-tabs { gap: 0.3rem; padding-bottom: 0.8rem; margin-bottom: 1rem; }
             .results-tabs button { padding: 0.6rem 0.8rem; font-size: 0.85rem; }
             .tab-content-area { padding: 0; } /* Remove padding for small screens if download button is inside */
             .tab-content { padding: 1rem; }
             .action-buttons { flex-direction: column; gap: 0.5rem; } /* Stack download buttons */
             .action-buttons .btn { width: 100%; }
            #tab-content-visuals .image-placeholder-container, #tab-content-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            #tab-content-visuals .image-placeholder img { height: 130px; }
            #tab-content-moodboard .image-placeholder img { height: 110px; }
            #tab-content-palette .color-palette-display { gap: 0.8rem; }
            #tab-content-palette .color-swatch { min-width: calc(50% - 0.4rem); }
            #tab-content-palette .color-swatch .color-block { height: 60px; }
            #tab-content-fonts .font-sample { font-size: 1em; }
             #how-to-use-button { bottom: 10px; right: 10px; padding: 0.4rem 0.8rem; font-size: 0.8rem; }
             #guide-modal-content { padding: 1.5rem 1rem; }
             #music-modal-content { padding: 1.5rem 1rem; max-width: 90%;}
             #music-modal-content h3 { font-size: 1.2rem; margin-bottom: 1rem;}
             .music-controls { flex-direction: column; gap: 0.8rem; }
             .music-controls input[type="range"] { max-width: 100%; width: 100%; }
             .new-loader-container { width: 80px; height: 80px; }
             .new-loader-content { transform: scale(0.15); }
        }

    </style>
</head>
<body>
    <!-- Background Canvas for 3D Object -->
    <canvas id="bg-canvas"></canvas>

    <!-- Audio Placeholders -->
    <audio id="hover-sound" src="/button-hover-sound.mp3" preload="auto"></audio>
    <audio id="click-sound" src="/button-click-sound.mp3" preload="auto"></audio>
    <!-- Background Music Player -->
    <audio id="background-music" src="/background-music.mp3" loop></audio> <!-- Placeholder SRC, set loop -->


    <!-- Loading Overlay Div (Unchanged) -->
    <div id="loading-overlay">
        <div class="new-loader-container"> <div class="new-loader-content"> <div class="new-loader-circle"></div> <div class="new-loader-circle"></div> <div class="new-loader-circle"></div> <div class="new-loader-circle"></div> </div> </div>
        <p data-lang-en="Generating creative sparks..." data-lang-es="Generando chispas creativas..." data-lang-vi="Đang tạo ra những tia sáng sáng tạo..." data-lang-ja="創造的な火花を生成中..." data-lang-zhcn="正在生成创意火花..." data-last-key="generatingCreativeSparks">Generating creative sparks...</p>
    </div>

    <!-- Navigation -->
    <nav class="main-nav">
        <a href="#" data-page="home" class="logo nav-link">
             <img src="logofinal(white).png" alt="MV Generator Logo" style="max-height: 40px; width: auto; vertical-align: middle; border-radius: 3px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
             <span style="display: none;" data-lang-en="Logo" data-lang-es="Logo" data-lang-vi="Logo" data-lang-ja="ロゴ" data-lang-zhcn="标志">Logo</span>
        </a>
        <ul>
            <li><a data-page="home" class="nav-link active" data-lang-en="Home" data-lang-es="Inicio" data-lang-vi="Trang chủ" data-lang-ja="ホーム" data-lang-zhcn="首页">Home</a></li>
            <li><a data-page="about" class="nav-link" data-lang-en="About" data-lang-es="Acerca de" data-lang-vi="Giới thiệu" data-lang-ja="概要" data-lang-zhcn="关于">About</a></li>
            <li><a data-page="feature" class="nav-link" data-lang-en="Generate" data-lang-es="Generar" data-lang-vi="Tạo" data-lang-ja="生成" data-lang-zhcn="生成">Generate</a></li>
        </ul>
        <div id="settings-box">
            <label for="language-select" data-lang-en="Language:" data-lang-es="Idioma:" data-lang-vi="Ngôn ngữ:" data-lang-ja="言語：" data-lang-zhcn="语言：">Language:</label>
            <select id="language-select">
                <option value="en">English</option> <option value="es">Español</option> <option value="vi">Tiếng Việt</option> <option value="ja">日本語</option> <option value="zh-CN">中文</option>
            </select>
            <!-- Music Settings Gear Icon Button -->
            <button id="music-settings-button" class="btn-icon" aria-label="Music Settings">
                <!-- SVG will be injected by JS -->
            </button>
        </div>
    </nav>

    <main>
        <!-- Home Page Section (Unchanged) -->
        <section id="home-page" class="page active container">
             <div class="hero-section">
                 <div class="hero-content">
                     <h1 data-lang-en="Unlock Visual Concepts for Your Music" data-lang-es="Desbloquea Conceptos Visuales para Tu Música" data-lang-vi="Mở khóa ý tưởng hình ảnh cho âm nhạc của bạn" data-lang-ja="あなたの音楽のためのビジュアルコンセプトを解き放つ" data-lang-zhcn="为您的音乐解锁视觉概念">Unlock Visual Concepts for Your Music</h1>
                     <p class="tagline" data-lang-en="Transform your lyrics and ideas into stunning music video concepts with the power of AI." data-lang-es="Transforma tus letras e ideas en impresionantes conceptos de videos musicales con el poder de la IA." data-lang-vi="Biến lời bài hát và ý tưởng của bạn thành những ý tưởng video âm nhạc tuyệt đẹp với sức mạnh của AI." data-lang-ja="AIの力で、あなたの歌詞やアイデアを見事なミュージックビデオコンセプトに変えましょう。" data-lang-zhcn="借助人工智能的力量，将您的歌词和想法转化为令人惊叹的音乐视频概念。">Transform your lyrics and ideas into stunning music video concepts with the power of AI.</p>
                     <button id="explore-button" class="btn btn-primary" data-lang-en="Start Generating" data-lang-es="Comenzar a Generar" data-lang-vi="Bắt đầu tạo" data-lang-ja="生成を開始" data-lang-zhcn="开始生成">Start Generating</button>
                 </div>
             </div>
             <button class="btn btn-secondary btn-back" data-target="home" data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页">Back to Home</button>
         </section>

        <!-- About Page Section (Unchanged) -->
        <section id="about-page" class="page container">
             <div class="content-container">
                 <h2 data-lang-en="About MV Generator" data-lang-es="Acerca del Generador MV" data-lang-vi="Về Trình tạo MV" data-lang-ja="MVジェネレーターについて" data-lang-zhcn="关于 MV 生成器">About MV Generator</h2>
                 <p data-lang-en="Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, genre, and potentially audio transcript, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, color palettes, and even font suggestions. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!" data-lang-es="¡Bienvenido al Generador de MV! Nos apasiona ayudar a los artistas a traducir sus creaciones musicales en historias visuales convincentes. Crear el concepto perfecto para un video musical puede ser desafiante, requiriendo una mezcla de visión artística y planificación práctica. Nuestra herramienta impulsada por IA está diseñada para cerrar esa brecha. Al analizar tus letras, palabras clave, género y potentially la transcripción de audio, el Generador de MV genera sugerencias personalizadas para conceptos de videos musicales, requisitos, estimaciones de presupuesto, inspiraciones visuales, paletas de colores e incluso sugerencias de fuentes. Nuestro objetivo es agilizar el proceso creativo, proporcionando una plataforma de lanzamiento para tus ideas y empoderándote para dar vida visual a tu música, ya seas un artista independiente o parte de una producción más grande. ¡Hagamos algo increíble juntos!" data-lang-vi="Chào mừng bạn đến với Trình tạo MV! Chúng tôi đam mê giúp các nghệ sĩ chuyển đổi những sáng tạo âm nhạc của họ thành những câu chuyện hình ảnh hấp dẫn. Việc tạo ra ý tưởng video âm nhạc hoàn hảo có thể đầy thử thách, đòi hỏi sự kết hợp giữa tầm nhìn nghệ thuật và kế hoạch thực tế. Công cụ hỗ trợ AI của chúng tôi được thiết kế để thu hẹp khoảng cách đó. Bằng cách phân tích lời bài hát, từ khóa, thể loại và có thể cả bản ghi âm thanh của bạn, Trình tạo MV tạo ra các đề xuất phù hợp cho các khái niệm video âm nhạc, yêu cầu, ước tính ngân sách, nguồn cảm hứng trực quan, bảng màu và thậm chí cả đề xuất phông chữ. Chúng tôi mong muốn hợp lý hóa quy trình sáng tạo, cung cấp bệ phóng cho ý tưởng của bạn và trao quyền cho bạn để đưa âm nhạc của mình vào cuộc sống một cách trực quan, cho dù bạn là một nghệ sĩ độc lập hay là một phần của một nhà sản xuất lớn hơn. Hãy cùng nhau tạo ra điều gì đó tuyệt vời!" data-lang-ja="MVジェネレーターへようこそ！私たちは、アーティストが音楽作品を魅力的なビジュアルストーリーに変換するお手伝いをすることに情熱を注いでいます。完璧なミュージックビデオのコンセプトを作り上げることは、芸術的なビジョンと実践的な計画の融合を必要とする、困難な作業となる場合があります。当社のAI搭載ツールは、そのギャップを埋めるために設計されています。あなたの歌詞、キーワード、ジャンル、そして場合によってはオーディオトランスクリプトを分析することにより、MVジェネレーターはミュージックビデオのコンセプト、要件、予算の見積もり、視覚的なインスピレーション、カラーパレット、さらにはフォントの提案に関するカスタマイズされた提案を生成します。私たちは、インディーズアーティストであろうと大規模なプロダクションの一部であろうと、あなたのアイデアの出発点を提供し、あなたの音楽を視覚的に実現する力を与えることで、創造的なプロセスを合理化することを目指しています。一緒に素晴らしいものを作りましょう！" data-lang-zhcn="欢迎来到 MV 生成器！我们热衷于帮助艺术家将他们的音乐创作转化为引人入胜的视觉故事。制作完美的音乐视频概念可能具有挑战性，需要艺术视野和实际规划的结合。我们的人工智能工具旨在弥合这一差距。通过分析您的歌词、关键词、流派以及可能的音频转录稿，MV 生成器会生成量身定制的音乐视频概念、要求、预算估算、视觉灵感、调色板建议，甚至字体建议。我们的目标是简化创作过程，为您的想法提供一个启动平台，并使您能够将音乐以视觉方式呈现出来，无论您是独立艺术家还是大型制作团队的一员。让我们一起创造一些惊人的东西吧！">
                     Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, genre, and potentially audio transcript, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, color palettes, and even font suggestions. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!
                 </p>
                  <button class="btn btn-secondary btn-back" data-target="home" data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页">Back to Home</button>
             </div>
         </section>

        <!-- ======== START: Feature Page Section (Redesigned) (Unchanged from original) ======== -->
        <section id="feature-page" class="page">

            <!-- Input Sidebar (Left Column) -->
            <aside class="input-sidebar">
                <div class="form-container">
                    <h1 data-lang-en="Input Details" data-lang-es="Ingresar Detalles" data-lang-vi="Nhập chi tiết" data-lang-ja="詳細入力" data-lang-zhcn="输入详情">Input Details</h1>

                    <form id="feature-form" onsubmit="return false;">
                        <div class="form-group">
                            <label for="lyrics-input" data-lang-en="Music Lyrics:" data-lang-es="Letra de la Música:" data-lang-vi="Lời bài hát:" data-lang-ja="歌詞：" data-lang-zhcn="歌词：">Music Lyrics:</label>
                            <textarea id="lyrics-input" rows="8" required data-lang-en-placeholder="Paste lyrics here or generate..." data-lang-es-placeholder="Pega la letra aquí o genera..." data-lang-vi-placeholder="Dán lời vào đây hoặc tạo..." data-lang-ja-placeholder="歌詞を貼付または生成..." data-lang-zhcn-placeholder="粘贴歌词或生成..." placeholder="Paste lyrics here or generate..."></textarea>
                            <button type="button" id="generate-lyrics-button" class="btn btn-secondary" data-lang-en="Generate Random Lyric" data-lang-es="Generar Letra Aleatoria" data-lang-vi="Tạo lời ngẫu nhiên" data-lang-ja="ランダムな歌詞を生成" data-lang-zhcn="生成随机歌词">Generate Random Lyric</button>
                        </div>
                        <div class="form-group">
                            <label for="keywords-input" data-lang-en="Keywords / Theme:" data-lang-es="Palabras Clave / Tema:" data-lang-vi="Từ khóa / Chủ đề:" data-lang-ja="キーワード / テーマ：" data-lang-zhcn="关键词/主题：">Keywords / Theme:</label>
                            <input type="text" id="keywords-input" required data-lang-en-placeholder="e.g., nostalgic, summer vibe" data-lang-es-placeholder="ej., nostálgico, ambiente verano" data-lang-vi-placeholder="vd: hoài cổ, không khí hè" data-lang-ja-placeholder="例：ノスタルジック、夏の雰囲気" data-lang-zhcn-placeholder="例：怀旧、夏日氛围" placeholder="e.g., nostalgic, summer vibe">
                        </div>
                        <div class="form-group">
                            <label for="genre-select" data-lang-en="Music Genre:" data-lang-es="Género Musical:" data-lang-vi="Thể loại âm nhạc:" data-lang-ja="音楽ジャンル：" data-lang-zhcn="音乐流派：">Music Genre:</label>
                            <select id="genre-select" required>
                                <option value="" disabled selected data-lang-en="-- Select a Genre --" data-lang-es="-- Selecciona un Género --" data-lang-vi="-- Chọn một thể loại --" data-lang-ja="-- ジャンルを選択 --" data-lang-zhcn="-- 选择流派 --">-- Select a Genre --</option>
                                <option value="RnB">RnB / Soul</option> <option value="Folk">Folk / Acoustic</option> <option value="Rock">Rock</option> <option value="Pop">Pop</option> <option value="Hiphop">Hip-hop / Rap</option> <option value="Electronic">Electronic</option> <option value="Classical">Classical</option> <option value="Country">Country</option> <option value="Jazz">Jazz / Blues</option> <option value="Reggae">Reggae</option> <option value="Metal">Metal</option> <option value="Other">Other / Fusion</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="track-upload" data-lang-en="Track Input (Optional):" data-lang-es="Entrada de Pista (Opcional):" data-lang-vi="Nhập bản nhạc (Tùy chọn):" data-lang-ja="トラック入力（任意）：" data-lang-zhcn="音轨输入（可选）：">Track Input (Optional):</label>
                            <div class="audio-input-group">
                                <input type="file" id="track-upload" accept="audio/*">
                                <button type="button" id="record-audio-button" class="btn btn-warning" data-lang-en-record="Record Audio" data-lang-es-record="Grabar Audio" data-lang-vi-record="Ghi âm" data-lang-ja-record="音声を録音" data-lang-zhcn-record="录制音频" data-lang-en-stop="Stop Recording" data-lang-es-stop="Detener Grabación" data-lang-vi-stop="Dừng ghi âm" data-lang-ja-stop="録音停止" data-lang-zhcn-stop="停止录制">Record Audio</button>
                                <span id="record-status" class="record-status-base">
                                    <span id="recording-animation" class="recording-dots" style="display: none;"><span></span><span></span><span></span></span>
                                    <span id="record-status-text"></span>
                                </span>
                            </div>
                            <small data-lang-en="Upload or record audio. Analysis enhances suggestions." data-lang-es="Sube o graba audio. El análisis mejora las sugerencias." data-lang-vi="Tải lên hoặc ghi âm. Phân tích giúp cải thiện đề xuất." data-lang-ja="オーディオをアップロードまたは録音。分析で提案強化。" data-lang-zhcn="上传或录制音频。分析可增强建议。">Upload or record audio. Analysis enhances suggestions.</small>
                        </div>
                        <div class="form-group" id="transcript-group" style="display: none;">
                            <label for="transcript-output" data-lang-en="Singing Transcript (from recording):" data-lang-es="Transcripción del Canto (de grabación):" data-lang-vi="Bản ghi lời hát (từ ghi âm):" data-lang-ja="歌唱トランスクリプト（録音より）：" data-lang-zhcn="演唱转录稿（来自录音）：">Singing Transcript (from recording):</label>
                            <textarea id="transcript-output" rows="3" readonly data-lang-en-placeholder="Transcript will appear here..." data-lang-es-placeholder="La transcripción aparecerá aquí..." data-lang-vi-placeholder="Bản ghi sẽ xuất hiện ở đây..." data-lang-ja-placeholder="トランスクリプト表示..." data-lang-zhcn-placeholder="转录稿将显示在此处..." placeholder="Transcript will appear here..."></textarea>
                            <small data-lang-en="This text will be analyzed along with lyrics." data-lang-es="Este texto se analizará junto con la letra." data-lang-vi="Văn bản này sẽ được phân tích cùng với lời bài hát." data-lang-ja="このテキストは歌詞とともに分析されます。" data-lang-zhcn="此文本将与歌词一起分析。">This text will be analyzed along with lyrics.</small>
                        </div>

                        <button type="button" id="generate-concept-button" class="btn btn-primary" data-lang-en="Generate Concept" data-lang-es="Generar Concepto" data-lang-vi="Tạo ý tưởng" data-lang-ja="コンセプトを生成" data-lang-zhcn="生成概念">Generate Concept</button>
                    </form>
                </div>
            </aside>

            <!-- Output Area (Right Column) -->
            <section class="output-area">

                 <!-- Error Message Area -->
                 <div id="error-message" class="error-message" data-lang-en="An error occurred. Please check input or try again." data-lang-es="Ocurrió un error. Revisa entrada o intenta de nuevo." data-lang-vi="Đã xảy ra lỗi. Kiểm tra đầu vào hoặc thử lại." data-lang-ja="エラー発生。入力確認か再試行してください。" data-lang-zhcn="发生错误。请检查输入或重试。" data-error-key="errorUnknown"></div>

                <!-- State 1: Initial Prompt -->
                <div id="initial-prompt">
                    <div class="prompt-icon"></div> <!-- Icon added via CSS -->
                    <p data-lang-en="Enter your song details on the left and click 'Generate Concept' to begin."
                       data-lang-es="Ingresa los detalles de tu canción a la izquierda y haz clic en 'Generar Concepto' para comenzar."
                       data-lang-vi="Nhập chi tiết bài hát ở bên trái và nhấp vào 'Tạo ý tưởng' để bắt đầu."
                       data-lang-ja="左側で曲の詳細を入力し、「コンセプトを生成」をクリックして開始します。"
                       data-lang-zhcn="在左侧输入您的歌曲详情，然后单击“生成概念”开始。"
                    >Enter your song details on the left and click 'Generate Concept' to begin.</p>
                </div>

                <!-- State 2: Concept Display -->
                <div id="concept-display-area">
                     <h2 data-lang-en="Generated Concept" data-lang-es="Concepto Generado" data-lang-vi="Ý tưởng được tạo" data-lang-ja="生成されたコンセプト" data-lang-zhcn="生成的概念">Generated Concept</h2>
                     <div id="concept-text-output" class="placeholder-notice" data-placeholder-key="conceptPlaceholder">
                         Concept text will appear here...
                     </div>
                     <div class="concept-actions">
                         <button id="pick-concept-button" class="btn btn-primary" data-lang-en="Pick this concept!" data-lang-es="¡Elegir este concepto!" data-lang-vi="Chọn ý tưởng này!" data-lang-ja="このコンセプトを選択！" data-lang-zhcn="选择此概念！" disabled>Pick this concept!</button>
                         <button id="regenerate-concept-button-alt" class="btn btn-secondary" data-lang-en="Generate new concept" data-lang-es="Generar nuevo concepto" data-lang-vi="Tạo ý tưởng mới" data-lang-ja="新しいコンセプトを生成" data-lang-zhcn="生成新概念" disabled>Generate new concept</button>
                     </div>
                 </div>

                <!-- State 3: Tabbed Results -->
                <div id="tabbed-results-area">
                    <nav class="results-tabs">
                        <button class="tab-link active" data-tab-target="tab-content-concept" data-lang-en="Concept" data-lang-es="Concepto" data-lang-vi="Ý tưởng" data-lang-ja="コンセプト" data-lang-zhcn="概念">Concept</button>
                        <button class="tab-link" data-tab-target="tab-content-requirements" data-lang-en="Requirements" data-lang-es="Requisitos" data-lang-vi="Yêu cầu" data-lang-ja="要件" data-lang-zhcn="要求">Requirements</button>
                        <button class="tab-link" data-tab-target="tab-content-budget" data-lang-en="Budget" data-lang-es="Presupuesto" data-lang-vi="Ngân sách" data-lang-ja="予算" data-lang-zhcn="预算">Budget</button>
                        <button class="tab-link" data-tab-target="tab-content-visuals" data-lang-en="Key Images" data-lang-es="Imágenes Clave" data-lang-vi="Ảnh chính" data-lang-ja="キーイメージ" data-lang-zhcn="关键图像">Key Images</button>
                        <button class="tab-link" data-tab-target="tab-content-moodboard" data-lang-en="Moodboard" data-lang-es="Moodboard" data-lang-vi="Moodboard" data-lang-ja="ムードボード" data-lang-zhcn="情绪板">Moodboard</button>
                        <button class="tab-link" data-tab-target="tab-content-fonts" data-lang-en="Typography" data-lang-es="Tipografía" data-lang-vi="Kiểu chữ" data-lang-ja="タイポグラフィ" data-lang-zhcn="排版">Typography</button>
                        <button class="tab-link" data-tab-target="tab-content-palette" data-lang-en="Color Palette" data-lang-es="Paleta Color" data-lang-vi="Bảng màu" data-lang-ja="カラーパレット" data-lang-zhcn="调色板">Color Palette</button>
                    </nav>
                    <div class="tab-content-area">
                        <!-- Content will be injected here by JS -->
                        <div id="tab-content-concept" class="tab-content active"></div>
                        <div id="tab-content-requirements" class="tab-content"></div>
                         <div id="tab-content-budget" class="tab-content"></div>
                        <div id="tab-content-visuals" class="tab-content"></div>
                         <div id="tab-content-moodboard" class="tab-content"></div>
                         <div id="tab-content-fonts" class="tab-content"></div>
                         <div id="tab-content-palette" class="tab-content"></div>
                    </div>
                    <!-- Download Button Area -->
                    <div class="action-buttons" id="download-action-area" style="display: none;">
                        <button id="download-text-info-button" class="btn btn-success"
                                data-lang-en="Download Text Info (.txt)"
                                data-lang-es="Descargar Info. Texto (.txt)"
                                data-lang-vi="Tải Thông tin Chữ (.txt)"
                                data-lang-ja="テキスト情報をダウンロード (.txt)"
                                data-lang-zhcn="下载文本信息 (.txt)">Download Text Info (.txt)</button>
                        <button id="download-all-images-button" class="btn btn-primary"
                                data-lang-en="Download All Images (.zip)"
                                data-lang-es="Descargar Todas las Imágenes (.zip)"
                                data-lang-vi="Tải Tất cả Ảnh (.zip)"
                                data-lang-ja="全画像をダウンロード (.zip)"
                                data-lang-zhcn="下载所有图像 (.zip)">Download All Images (.zip)</button>
                    </div>
                </div>

            </section> <!-- End .output-area -->

        </section> <!-- End #feature-page -->
        <!-- ======== END: Feature Page Section (Redesigned) ======== -->

    </main>

    <!-- How to Use Button (Unchanged) -->
    <button id="how-to-use-button" class="btn" data-lang-en="How to Use" data-lang-es="Cómo Usar" data-lang-vi="Cách dùng" data-lang-ja="使い方" data-lang-zhcn="如何使用">How to Use</button>

    <!-- Guide Modal (Unchanged) -->
    <div id="guide-modal">
        <div id="guide-modal-content">
            <button id="close-guide-modal" aria-label="Close Guide">&times;</button>
            <h3 data-lang-en="How to Use MV Generator" data-lang-es="Cómo Usar el Generador MV" data-lang-vi="Cách Sử dụng Trình tạo MV" data-lang-ja="MVジェネレーターの使い方" data-lang-zhcn="如何使用 MV 生成器">How to Use MV Generator</h3>
            <h4 data-lang-en="1. Input Your Song Details" data-lang-es="1. Ingresa los Detalles de tu Canción" data-lang-vi="1. Nhập chi tiết bài hát" data-lang-ja="1. 曲の詳細を入力" data-lang-zhcn="1. 输入您的歌曲详情">1. Input Your Song Details</h4>
            <p data-lang-en="On the 'Generate' page, use the left sidebar:" data-lang-es="En la página 'Generar', usa la barra lateral izquierda:" data-lang-vi="Trên trang 'Tạo', sử dụng thanh bên trái:" data-lang-ja="「生成」ページで、左側のサイドバーを使用します：" data-lang-zhcn="在“生成”页面上，使用左侧边栏：">On the 'Generate' page, use the left sidebar:</p>
            <ul>
                <li data-lang-en="<strong>Music Lyrics:</strong> Paste your full song lyrics or use 'Generate Random Lyric'." data-lang-es="<strong>Letra:</strong> Pega tu letra completa o usa 'Generar Letra Aleatoria'." data-lang-vi="<strong>Lời bài hát:</strong> Dán lời bài hát đầy đủ hoặc dùng 'Tạo lời ngẫu nhiên'." data-lang-ja="<strong>歌詞：</strong>完全な歌詞を貼り付けるか、「ランダムな歌詞を生成」を使用。" data-lang-zhcn="<strong>歌词：</strong>粘贴完整歌词或使用“生成随机歌词”。"><strong>Music Lyrics:</strong> Paste your full song lyrics or use 'Generate Random Lyric'.</li>
                <li data-lang-en="<strong>Keywords / Theme:</strong> Add words describing the mood, style, or visual ideas." data-lang-es="<strong>Palabras Clave / Tema:</strong> Agrega palabras descriptivas del ánimo, estilo o ideas visuales." data-lang-vi="<strong>Từ khóa / Chủ đề:</strong> Thêm từ mô tả tâm trạng, phong cách, ý tưởng hình ảnh." data-lang-ja="<strong>キーワード/テーマ：</strong>ムード、スタイル、視覚的アイデアを説明する単語を追加。" data-lang-zhcn="<strong>关键词/主题：</strong>添加描述情绪、风格或视觉想法的词语。"><strong>Keywords / Theme:</strong> Add words describing the mood, style, or visual ideas.</li>
                <li data-lang-en="<strong>Music Genre:</strong> Select the genre that best fits." data-lang-es="<strong>Género Musical:</strong> Selecciona el género que mejor encaje." data-lang-vi="<strong>Thể loại âm nhạc:</strong> Chọn thể loại phù hợp nhất." data-lang-ja="<strong>音楽ジャンル：</strong>最も合うジャンルを選択。" data-lang-zhcn="<strong>音乐流派：</strong>选择最适合的流派。"><strong>Music Genre:</strong> Select the genre that best fits.</li>
                <li data-lang-en="<strong>Track Input (Optional):</strong> Upload an audio file or record your singing for enhanced suggestions." data-lang-es="<strong>Entrada de Pista (Opcional):</strong> Sube un archivo de audio o graba tu canto para sugerencias mejoradas." data-lang-vi="<strong>Nhập bản nhạc (Tùy chọn):</strong> Tải lên tệp âm thanh hoặc ghi âm giọng hát để cải thiện đề xuất." data-lang-ja="<strong>トラック入力（任意）：</strong>オーディオファイルをアップロードまたは録音して、提案を強化。" data-lang-zhcn="<strong>音轨输入（可选）：</strong>上传音频文件或录制演唱以增强建议。"><strong>Track Input (Optional):</strong> Upload an audio file or record your singing for enhanced suggestions.</li>
            </ul>
            <h4 data-lang-en="2. Generate the Initial Concept" data-lang-es="2. Genera el Concepto Inicial" data-lang-vi="2. Tạo ý tưởng ban đầu" data-lang-ja="2. 初期コンセプトを生成" data-lang-zhcn="2. 生成初始概念">2. Generate the Initial Concept</h4>
            <p data-lang-en="Click the 'Generate Concept' button at the bottom of the sidebar. The AI will analyze your inputs and display an initial concept idea in the right panel." data-lang-es="Haz clic en el botón 'Generar Concepto' al final de la barra lateral. La IA analizará tus entradas y mostrará una idea de concepto inicial en el panel derecho." data-lang-vi="Nhấp vào nút 'Tạo ý tưởng' ở cuối thanh bên. AI sẽ phân tích đầu vào của bạn và hiển thị ý tưởng ban đầu trong bảng điều khiển bên phải." data-lang-ja="サイドバー下部の「コンセプトを生成」ボタンをクリックします。AIがあなたの入力を分析し、右側のパネルに初期コンセプトのアイデアを表示します。" data-lang-zhcn="单击侧边栏底部的“生成概念”按钮。AI 将分析您的输入并在右侧面板中显示初始概念想法。">Click the 'Generate Concept' button at the bottom of the sidebar. The AI will analyze your inputs and display an initial concept idea in the right panel.</p>
            <h4 data-lang-en="3. Choose or Regenerate" data-lang-es="3. Elige o Regenera" data-lang-vi="3. Chọn hoặc Tạo lại" data-lang-ja="3. 選択または再生成" data-lang-zhcn="3. 选择或重新生成">3. Choose or Regenerate</h4>
            <ul>
                <li data-lang-en="<strong>Pick this concept!:</strong> Happy with the idea? Click this to generate the full details (Requirements, Budget, Visuals, etc.) presented in tabs." data-lang-es="<strong>¡Elegir este concepto!:</strong> ¿Contento con la idea? Haz clic aquí para generar todos los detalles (Requisitos, Presupuesto, Visuales, etc.) presentados en pestañas." data-lang-vi="<strong>Chọn ý tưởng này!:</strong> Hài lòng với ý tưởng? Nhấp vào đây để tạo chi tiết đầy đủ (Yêu cầu, Ngân sách, Hình ảnh, v.v.) được trình bày trong các tab." data-lang-ja="<strong>このコンセプトを選択！：</strong>アイデアに満足しましたか？これをクリックして、タブに表示される完全な詳細（要件、予算、ビジュアルなど）を生成します。" data-lang-zhcn="<strong>选择此概念！：</strong>对想法满意吗？单击此按钮可生成以选项卡形式呈现的完整详细信息（要求、预算、视觉效果等）。"><strong>Pick this concept!:</strong> Happy with the idea? Click this to generate the full details (Requirements, Budget, Visuals, etc.) presented in tabs.</li>
                <li data-lang-en="<strong>Generate new concept:</strong> Not quite right? Click this to get a different initial concept based on the same inputs." data-lang-es="<strong>Generar nuevo concepto:</strong> ¿No es exactamente lo que buscas? Haz clic aquí para obtener un concepto inicial diferente basado en lasmmas entradas." data-lang-vi="<strong>Tạo ý tưởng mới:</strong> Chưa đúng ý? Nhấp vào đây để nhận một ý tưởng ban đầu khác dựa trên cùng một đầu vào." data-lang-ja="<strong>新しいコンセプトを生成：</strong>あまり良くありませんか？これをクリックして、同じ入力に基づいて別の初期コンセプトを取得します。" data-lang-zhcn="<strong>生成新概念：</strong>不太对？单击此按钮可根据相同的输入获取不同的初始概念。"><strong>Generate new concept:</strong> Not quite right? Click this to get a different initial concept based on the same inputs.</li>
            </ul>
             <h4 data-lang-en="4. Explore Detailed Results" data-lang-es="4. Explora los Resultados Detallados" data-lang-vi="4. Khám phá Kết quả Chi tiết" data-lang-ja="4. 詳細な結果を探索" data-lang-zhcn="4. 探索详细结果">4. Explore Detailed Results</h4>
             <p data-lang-en="Once you pick a concept, use the tabs (Concept, Requirements, Budget, etc.) at the top of the right panel to navigate through the different generated sections." data-lang-es="Una vez que elijas un concepto, usa las pestañas (Concepto, Requisitos, Presupuesto, etc.) en la parte superior del panel derecho para navegar por las diferentes secciones generadas." data-lang-vi="Sau khi bạn chọn một ý tưởng, hãy sử dụng các tab (Ý tưởng, Yêu cầu, Ngân sách, v.v.) ở đầu bảng điều khiển bên phải để điều hướng qua các phần được tạo khác nhau." data-lang-ja="コンセプトを選択したら、右側のパネル上部にあるタブ（コンセプト、要件、予算など）を使用して、生成されたさまざまなセクションをナビゲートします。" data-lang-zhcn="选择概念后，使用右侧面板顶部的选项卡（概念、要求、预算等）浏览不同的生成部分。">Once you pick a concept, use the tabs (Concept, Requirements, Budget, etc.) at the top of the right panel to navigate through the different generated sections.</p>
             <p data-lang-en="After exploring, you can use the 'Download Text Info' and 'Download All Images' buttons at the bottom of the results to save your concept." data-lang-es="Después de explorar, puedes usar los botones 'Descargar Info. Texto' y 'Descargar Todas las Imágenes' al final de los resultados para guardar tu concepto." data-lang-vi="Sau khi khám phá, bạn có thể sử dụng nút 'Tải Thông tin Chữ' và 'Tải Tất cả Ảnh' ở cuối kết quả để lưu ý tưởng của bạn." data-lang-ja="探索後、結果の下部にある「テキスト情報をダウンロード」および「全画像をダウンロード」ボタンを使用してコンセプトを保存できます。" data-lang-zhcn="探索后，您可以使用结果底部的“下载文本信息”和“下载所有图像”按钮保存您的概念。">After exploring, you can use the 'Download Text Info' and 'Download All Images' buttons at the bottom of the results to save your concept.</p>
            <p style="margin-top: 2rem; text-align: center; font-style: italic;" data-lang-en="Enjoy creating!" data-lang-es="¡Disfruta creando!" data-lang-vi="Thỏa sức sáng tạo!" data-lang-ja="作成をお楽しみください！" data-lang-zhcn="享受创作！">Enjoy creating!</p>
        </div>
    </div>

    <!-- Music Settings Modal -->
    <div id="music-modal">
        <div id="music-modal-content">
            <button id="close-music-modal" aria-label="Close Music Settings">&times;</button>
            <h3 data-lang-en="Background Music" 
                data-lang-es="Música de Fondo" 
                data-lang-vi="Nhạc Nền" 
                data-lang-ja="背景音楽" 
                data-lang-zhcn="背景音乐">Background Music</h3>
            <div class="music-controls">
                <button id="play-pause-music-button" aria-label="Play Music">
                    <!-- SVG Play/Pause Icon will be injected by JS -->
                </button>
                <input type="range" id="volume-slider" min="0" max="100" value="50" aria-label="Volume">
            </div>
        </div>
    </div>

    <footer class="main-footer">
        <div class="container">
            <p>&copy; 2025 MVPot. All rights reserved.</p>
            <!-- <p><a href="#">Privacy Policy</a> | <a href="#">Terms of Service</a></p> -->
        </div>
    </footer>

    <!-- ========= START JAVASCRIPT ========= -->
    <script type="module">

    // Import necessary modules from Three.js
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element References ---
        const navLinks = document.querySelectorAll('.nav-link');
        const pages = document.querySelectorAll('.page');
        const exploreButton = document.getElementById('explore-button');
        const backButtons = document.querySelectorAll('.btn-back');
        const loadingOverlay = document.getElementById('loading-overlay');
        const languageSelect = document.getElementById('language-select');
        const howToUseButton = document.getElementById('how-to-use-button');
        const guideModal = document.getElementById('guide-modal');
        const closeGuideModal = document.getElementById('close-guide-modal');
        const bgCanvas = document.getElementById('bg-canvas');
        const hoverSound = document.getElementById('hover-sound');
        const clickSound = document.getElementById('click-sound');

        // Feature Page Specific Elements
        const featurePage = document.getElementById('feature-page');
        const inputSidebar = document.querySelector('.input-sidebar');
        const outputArea = document.querySelector('.output-area');
        const initialPrompt = document.getElementById('initial-prompt');
        const conceptDisplayArea = document.getElementById('concept-display-area');
        const conceptTextOutput = document.getElementById('concept-text-output');
        const pickConceptButton = document.getElementById('pick-concept-button');
        const regenerateConceptButtonAlt = document.getElementById('regenerate-concept-button-alt');
        const tabbedResultsArea = document.getElementById('tabbed-results-area');
        const resultsTabsContainer = document.querySelector('.results-tabs');
        const tabLinks = resultsTabsContainer?.querySelectorAll('.tab-link');
        const tabContentArea = document.querySelector('.tab-content-area');
        const tabContents = tabContentArea?.querySelectorAll('.tab-content');
        const downloadActionArea = document.getElementById('download-action-area');
        const downloadTextInfoButton = document.getElementById('download-text-info-button');
        const downloadAllImagesButton = document.getElementById('download-all-images-button');


        // Form Elements
        const featureForm = document.getElementById('feature-form');
        const generateConceptButton = document.getElementById('generate-concept-button');
        const generateLyricsButton = document.getElementById('generate-lyrics-button');
        const lyricsInput = document.getElementById('lyrics-input');
        const keywordsInput = document.getElementById('keywords-input');
        const genreSelect = document.getElementById('genre-select');
        const trackUploadInput = document.getElementById('track-upload');
        const transcriptGroup = document.getElementById('transcript-group');
        const transcriptOutput = document.getElementById('transcript-output');
        const recordAudioButton = document.getElementById('record-audio-button');
        const recordStatus = document.getElementById('record-status');
        const recordingAnimation = document.getElementById('recording-animation');
        const recordStatusText = document.getElementById('record-status-text');
        const errorMessageDiv = document.getElementById('error-message');

        // Music Player Elements
        const backgroundMusic = document.getElementById('background-music');
        const musicSettingsButton = document.getElementById('music-settings-button');
        const musicModal = document.getElementById('music-modal');
        const closeMusicModal = document.getElementById('close-music-modal');
        const playPauseMusicButton = document.getElementById('play-pause-music-button');
        const volumeSlider = document.getElementById('volume-slider');


        // --- State Variables ---
        let currentInputs = null;
        let currentLang = 'en';
        let activePage = 'home';
        let generateStep = 'initial'; // 'initial', 'concept_shown', 'details_shown'
        let currentConceptText = '';
        let currentDetailedResultsText = ''; 
        let musicIsPlaying = false; // For background music state
        let musicInitialized = false; // To track if user interaction allowed music to start

        // To store page-specific data
        let storedPageData = {
            feature: {
                inputs: null,
                conceptText: '',
                detailedResultsText: '',
                step: 'initial',
                formValues: null,
                imagePlaceholders: [] // Initialize as an empty array
            }
        };

        // --- Audio Recording Variables ---
        let mediaRecorder; let audioChunks = []; let isRecording = false; let recordedAudioBlob = null;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition; let finalTranscript = ''; let isSpeechRecognitionSupported = !!SpeechRecognition;

        // --- SVG Icons ---
        const svgIconGear = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22-.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>`;
        const svgIconPlay = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>`;
        const svgIconPause = `<svg viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;


        // --- Mapping for Section Processing & Placeholders (Mapping to Tab Content IDs) ---
        const sectionsToTabs = {
             'Concept / Key Visual': 'tab-content-concept',
             'Requirements for MV': 'tab-content-requirements',
             'Estimated Budget': 'tab-content-budget',
             'Visual Demo (Key Images)': 'tab-content-visuals',
             // 'Visual Demo (Key Image Descriptions)': 'tab-content-visuals', // Handled by 'Visual Demo (Key Images)'
             'Moodboard Influences': 'tab-content-moodboard',
             'Typography/Font Suggestion': 'tab-content-fonts',
             'Color Palette': 'tab-content-palette'
         };
         const tabTitles = {
             'tab-content-concept': 'Concept',
             'tab-content-requirements': 'Requirements',
             'tab-content-budget': 'Budget',
             'tab-content-visuals': 'Key Images',
             'tab-content-moodboard': 'Moodboard',
             'tab-content-fonts': 'Typography',
             'tab-content-palette': 'Color Palette'
         };


        // --- Audio Playback Functions ---
        function playSound(audioElement) { if (audioElement) { audioElement.currentTime = 0; audioElement.play().catch(error => console.warn("Audio play failed:", error)); } }

        // --- Page Navigation ---
        function showPage(pageId) {
            if (activePage === 'feature' && pageId !== 'feature' && generateStep !== 'initial') {
                console.log("Storing feature page data. Step:", generateStep);
                const imageDataToStore = [];
                
                document.querySelectorAll('#tab-content-visuals .image-placeholder, #tab-content-moodboard .image-placeholder').forEach((figure) => {
                    const img = figure.querySelector('img');
                    const figcaption = figure.querySelector('figcaption');
                    const seedSuffix = figure.dataset.seedSuffix; // Retrieve stored seedSuffix
                    const tabId = figure.closest('#tab-content-visuals') ? 'visuals' : 'moodboard';

                    if (img && img.src && figcaption && seedSuffix && !img.src.startsWith('data:')) { // Avoid storing empty/data URIs
                        imageDataToStore.push({
                            seedSuffix: seedSuffix,
                            tabId: tabId,
                            src: img.src,
                            alt: img.alt,
                            figcaptionHTML: figcaption.innerHTML
                        });
                    }
                });

                storedPageData.feature = { // Overwrite or create new feature data object
                    inputs: currentInputs ? JSON.parse(JSON.stringify(currentInputs)) : null,
                    conceptText: currentConceptText,
                    detailedResultsText: currentDetailedResultsText,
                    step: generateStep,
                    formValues: {
                        lyrics: lyricsInput.value,
                        keywords: keywordsInput.value,
                        genre: genreSelect.value,
                        transcript: transcriptOutput.value,
                        transcriptVisible: transcriptGroup.style.display === 'block',
                        trackFileName: trackUploadInput.value ? trackUploadInput.files[0]?.name : null
                    },
                    imagePlaceholders: imageDataToStore // This is now correctly populated with seedSuffix
                };
            }

            activePage = pageId;
            pages.forEach(page => { page.classList.toggle('active', page.id === `${pageId}-page`); });
            navLinks.forEach(link => { const linkPage = link.getAttribute('data-page'); if (linkPage) { link.classList.toggle('active', linkPage === pageId); } });
            window.scrollTo(0, 0);

            if (pageId === 'feature') {
                clearErrors();
                if (storedPageData.feature && storedPageData.feature.step && storedPageData.feature.step !== 'initial') {
                    console.log("Restoring feature page data:", storedPageData.feature);
                    
                    if (storedPageData.feature.formValues) {
                        lyricsInput.value = storedPageData.feature.formValues.lyrics || '';
                        keywordsInput.value = storedPageData.feature.formValues.keywords || '';
                        genreSelect.value = storedPageData.feature.formValues.genre || '';
                        transcriptOutput.value = storedPageData.feature.formValues.transcript || '';
                        transcriptGroup.style.display = storedPageData.feature.formValues.transcriptVisible ? 'block' : 'none';
                    } else {
                         if (featureForm) featureForm.reset();
                         transcriptGroup.style.display = 'none';
                         transcriptOutput.value = '';
                    }

                    currentInputs = storedPageData.feature.inputs ? JSON.parse(JSON.stringify(storedPageData.feature.inputs)) : null;
                    currentConceptText = storedPageData.feature.conceptText || '';
                    currentDetailedResultsText = storedPageData.feature.detailedResultsText || '';
                    generateStep = storedPageData.feature.step;

                    updateGeneratePageUI(generateStep); // This sets up the correct view (initial, concept, or details)

                    if (generateStep === 'concept_shown' && currentConceptText) {
                        conceptTextOutput.textContent = currentConceptText;
                        conceptTextOutput.classList.remove('placeholder-notice');
                    } else if (generateStep === 'details_shown' && currentDetailedResultsText) {
                        clearTabContents(); // Clear and set placeholders
                        
                        // Ensure image containers are ready but empty before parseAndDisplayDetailedResults
                        // as parseAndDisplayDetailedResults will call createImagePlaceholder which handles restoration
                        const visualContainer = document.getElementById('tab-content-visuals')?.querySelector('.image-placeholder-container');
                        const moodboardContainer = document.getElementById('tab-content-moodboard')?.querySelector('.image-placeholder-container');
                        if (visualContainer) visualContainer.innerHTML = ''; 
                        if (moodboardContainer) moodboardContainer.innerHTML = '';
                        
                        parseAndDisplayDetailedResults(currentDetailedResultsText); // This will call createImagePlaceholder, which now checks storedPageData

                        if (resultsTabsContainer?.querySelector('.tab-link')) {
                           activateTab(resultsTabsContainer.querySelector('.tab-link'));
                        }
                    } else if (generateStep === 'initial' || (!currentConceptText && !currentDetailedResultsText && generateStep !== 'initial')) {
                        console.warn("Stored data indicated a non-initial step, but content seems missing or step is 'initial'. Resetting feature page.");
                        if (featureForm) featureForm.reset();
                        transcriptGroup.style.display = 'none';
                        transcriptOutput.value = '';
                        resetGeneratePageUI();
                    }
                } else {
                    console.log("No valid feature page data to restore, or step was initial. Resetting.");
                    if (featureForm) featureForm.reset(); 
                    transcriptGroup.style.display = 'none';
                    transcriptOutput.value = '';
                    resetGeneratePageUI(); 
                }
            }
        }

        // --- Loading Overlay Control ---
        function showLoading(messageKey = "generatingCreativeSparks", fallbackMessage = "Generating...") { if (!loadingOverlay) return; const textElement = loadingOverlay.querySelector('p'); if (textElement) { const translatedMessage = getTranslatedText(textElement, messageKey, false, fallbackMessage); textElement.textContent = translatedMessage; textElement.dataset.lastKey = messageKey; } loadingOverlay.classList.add('show'); [generateConceptButton, generateLyricsButton, pickConceptButton, regenerateConceptButtonAlt, recordAudioButton, downloadTextInfoButton, downloadAllImagesButton].forEach(btn => { if(btn) btn.disabled = true; }); }
        function hideLoading() { if (!loadingOverlay) return; loadingOverlay.classList.remove('show'); if(generateConceptButton) generateConceptButton.disabled = false; if(generateLyricsButton) generateLyricsButton.disabled = false; if(pickConceptButton) pickConceptButton.disabled = (generateStep !== 'concept_shown'); if(regenerateConceptButtonAlt) regenerateConceptButtonAlt.disabled = (generateStep !== 'concept_shown'); if(recordAudioButton) recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported) || isRecording; if(downloadTextInfoButton) downloadTextInfoButton.disabled = (generateStep !== 'details_shown'); if(downloadAllImagesButton) downloadAllImagesButton.disabled = (generateStep !== 'details_shown');}

        // --- Microphone Recording & Speech Recognition Logic (Unchanged) ---
        if (recordAudioButton) { recordAudioButton.addEventListener('click', handleRecordButtonClick); if (!navigator.mediaDevices?.getUserMedia || !isSpeechRecognitionSupported) { const statusKey = !navigator.mediaDevices?.getUserMedia ? 'statusAudioNotSupported' : 'statusSpeechRecNotSupported'; updateRecordStatus(getTranslatedText(null, statusKey, false, 'Audio/Speech input not supported.'), 'error', true, statusKey); recordAudioButton.disabled = true; } }
        async function handleRecordButtonClick() { if (!navigator.mediaDevices?.getUserMedia || !isSpeechRecognitionSupported) return; if (!isRecording) { try { recordedAudioBlob = null; trackUploadInput.value = ''; transcriptOutput.value = ''; finalTranscript = ''; transcriptGroup.style.display = 'none'; clearRecordStatus(); updateRecordStatus('Requesting mic access...', '', false, 'statusRequestingMic'); const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); updateRecordStatus('', 'recording', false); mediaRecorder = new MediaRecorder(stream); mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); }; mediaRecorder.onstop = () => { recordedAudioBlob = (audioChunks.length > 0) ? new Blob(audioChunks, { type: 'audio/webm;codecs=opus' }) : null; audioChunks = []; stream.getTracks().forEach(track => track.stop()); updateRecordingUI(false); if (!recognition || !recognition.recognizing) { updateFinalRecordStatus(); } }; mediaRecorder.onerror = (event) => { console.error("MediaRecorder error:", event.error); const errorMsg = getTranslatedText(null, 'statusRecordingError', false, `Rec. error: ${event.error.name}`).replace('${errorName}', event.error.name); updateRecordStatus(errorMsg, 'error', true); if (recognition?.abort) { try { recognition.abort(); } catch(e){} } stream.getTracks().forEach(track => track.stop()); updateRecordingUI(false); }; recognition = new SpeechRecognition(); recognition.continuous = true; recognition.interimResults = true; const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' }; recognition.lang = bcp47Map[currentLang] || (currentLang.includes('-') ? currentLang : `${currentLang}-${currentLang.toUpperCase()}`); console.log("SpeechRecognition language:", recognition.lang); recognition.onresult = (event) => { let interimTranscript = ''; finalTranscript = ''; for (let i = event.resultIndex; i < event.results.length; ++i) { if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript + ' '; else interimTranscript += event.results[i][0].transcript; } const currentFullTranscript = (finalTranscript + interimTranscript).trim(); transcriptOutput.value = currentFullTranscript; if (currentFullTranscript) transcriptGroup.style.display = 'block'; updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing'); }; recognition.onerror = (event) => { console.error("Speech Recognition Error:", event.error, event.message); let errorMsgKey = 'transcriptionErrorGeneric', errorParam = event.error; if (event.error === 'no-speech') errorMsgKey = 'transcriptionErrorNoSpeech'; else if (event.error === 'audio-capture') errorMsgKey = 'transcriptionErrorMicProblem'; else if (event.error === 'not-allowed') errorMsgKey = 'transcriptionErrorPermission'; else if (event.error === 'network') errorMsgKey = 'transcriptionErrorNetwork'; const translatedError = getTranslatedText(null, errorMsgKey, false, `Transcr. error: ${errorParam}`); if (!recordStatus?.classList.contains('error')) updateRecordStatus(translatedError, 'error', true, errorMsgKey); if (mediaRecorder?.state === "recording" && event.error !== 'no-speech') try { mediaRecorder.stop(); } catch(e){} }; recognition.onstart = () => { console.log("Speech recognition started."); updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing'); }; recognition.onend = () => { console.log("Speech recognition ended."); finalTranscript = finalTranscript.trim(); transcriptOutput.value = finalTranscript; if (!finalTranscript && transcriptGroup.style.display === 'block') transcriptGroup.style.display = 'none'; if (!isRecording) updateFinalRecordStatus(); }; audioChunks = []; mediaRecorder.start(); recognition.start(); updateRecordingUI(true); } catch (err) { console.error("Mic access error:", err); let errorMsgKey = 'micErrorGeneric'; if (err.name === 'NotAllowedError') errorMsgKey = 'micErrorPermission'; else if (err.name === 'NotFoundError') errorMsgKey = 'micErrorNotFound'; else if (err.name === 'NotReadableError') errorMsgKey = 'micErrorHardware'; updateRecordStatus(getTranslatedText(null, errorMsgKey, false, 'Mic access error.'), 'error', true, errorMsgKey); updateRecordingUI(false); } } else { if (mediaRecorder?.state === "recording") { updateRecordStatus(getTranslatedText(null, 'statusStopping', false, 'Stopping...'), '', false, 'statusStopping'); try { mediaRecorder.stop(); } catch(e){} } if (recognition?.stop) { try { recognition.stop(); } catch (e) { if (!isRecording) updateFinalRecordStatus(); } } else if (!isRecording) { updateFinalRecordStatus(); } } }
        function updateFinalRecordStatus() { setTimeout(() => { if (recordStatus?.classList.contains('error')) return; let finalStatusMsgKey = 'stoppedStatus', finalStatusClass = '', isPersistent = false; if (recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'recordTranscriptComplete'; finalStatusClass = 'complete'; isPersistent = true; } else if (recordedAudioBlob && !finalTranscript) { finalStatusMsgKey = 'recordCompleteNoTranscript'; finalStatusClass = 'complete'; isPersistent = true; } else if (!recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'transcriptCompleteNoRecord'; finalStatusClass = 'complete'; isPersistent = true; } updateRecordStatus(getTranslatedText(null, finalStatusMsgKey, false, 'Stopped.'), finalStatusClass, isPersistent, finalStatusMsgKey); }, 100); }
        function updateRecordingUI(recording) { if (!recordAudioButton) return; isRecording = recording; const recordKey = 'record', stopKey = 'stop'; const buttonText = recording ? getTranslatedText(recordAudioButton, stopKey, true, 'Stop Recording') : getTranslatedText(recordAudioButton, recordKey, true, 'Record Audio'); recordAudioButton.textContent = buttonText; recordAudioButton.disabled = false; recordAudioButton.classList.toggle('btn-danger', recording); recordAudioButton.classList.toggle('btn-warning', !recording); if(recordingAnimation) recordingAnimation.style.display = recording ? 'inline-block' : 'none'; if (recording) updateRecordStatus(getTranslatedText(null, 'statusRecording', false, 'Recording...'), 'recording', false, 'statusRecording'); else recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported); }
        function updateRecordStatus(message, statusClass = '', persistent = false, translationKey = '') { if (!recordStatus || !recordStatusText || !recordingAnimation) return; if (updateRecordStatus.timeoutId) clearTimeout(updateRecordStatus.timeoutId); const displayMessage = translationKey ? getTranslatedText(null, translationKey, false, message) : message; recordStatusText.textContent = displayMessage; recordStatus.className = 'record-status-base'; recordStatus.dataset.statusKey = translationKey; recordStatus.dataset.statusFallback = message; if (statusClass) recordStatus.classList.add(statusClass); recordingAnimation.style.display = (statusClass === 'recording' || statusClass === 'transcribing') ? 'inline-block' : 'none'; if (!persistent && statusClass !== 'error' && displayMessage) { updateRecordStatus.timeoutId = setTimeout(() => { if (recordStatusText.textContent === displayMessage && recordStatus.dataset.statusKey === translationKey) clearRecordStatus(); }, 4000); } }
        updateRecordStatus.timeoutId = null;
        function clearRecordStatus() { if (recordStatusText) recordStatusText.textContent = ''; if (recordStatus) { recordStatus.className = 'record-status-base'; delete recordStatus.dataset.statusKey; delete recordStatus.dataset.statusFallback; } if (recordingAnimation) recordingAnimation.style.display = 'none'; if (updateRecordStatus.timeoutId) { clearTimeout(updateRecordStatus.timeoutId); updateRecordStatus.timeoutId = null; } }
        if(trackUploadInput) { trackUploadInput.addEventListener('change', () => { if (trackUploadInput.files.length > 0) { if (isRecording) handleRecordButtonClick(); recordedAudioBlob = null; transcriptOutput.value = ''; finalTranscript = ''; transcriptGroup.style.display = 'none'; updateRecordStatus(getTranslatedText(null, 'statusFileSelected', false, 'File selected.'), 'complete', true, 'statusFileSelected'); } }); }

        // --- Random Lyric Generation (Unchanged) ---
        function generateRandomLyrics() { const structures = ['Intro', 'Verse', 'Chorus', 'Verse', 'Chorus', 'Bridge', 'Chorus', 'Outro']; const lines = { Intro: ["Yeah...", "Listen...", "In the quiet of the dawn...", "Another day begins...", "(Instrumental intro vibe)"], Verse: ["Walking down these empty streets again,", "Lost in thought, the city sleeps,", "Remember echoes of a distant past,", "Sunlight paints the window pane,", "Another coffee, numb the pain,", "Trying to find where I belong,", "The rhythm of the falling rain,", "Whispers carried on the breeze,", "A photograph begins to fade,", "Watching shadows start to grow,"], Chorus: ["Oh, this feeling takes me higher,", "Burning bright, a hidden fire,", "Can we turn back time somehow?", "Just let go, right here and now.", "We're searching for a guiding light,", "Through the darkness of the night,", "Holding on to what we know,", "Where do we go, where do we go?", "This melody, it sets me free,", "Just you and I, wild and carefree,", "A moment caught, eternally,", "Is this dream reality?"], Bridge: ["Maybe we were meant to stray,", "Find a different path, a different way,", "Worlds apart, yet still connected,", "Underneath the silver moon's soft glow,", "There's a truth I need to know,", "Before the final curtain falls,"], Outro: ["Fading out... into the night...", "Just an echo...", "Yeah, gone...", "(Fade out)", "Until next time..."] }; let fullLyrics = ""; let sentenceCount = 0; const minSentences = 10; const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)]; let currentStructure = []; while (sentenceCount < minSentences || structures.length > 0) { const part = structures.length > 0 ? structures.shift() : getRandom(['Verse', 'Chorus']); currentStructure.push(part); const numLines = (part === 'Chorus' || part === 'Verse') ? getRandom([2, 3]) : 1; for (let i = 0; i < numLines; i++) { if (lines[part]) sentenceCount++; } if (sentenceCount >= minSentences && structures.length === 0 && !currentStructure.includes('Outro')) currentStructure.push('Outro'); } if (currentStructure.includes('Outro') && currentStructure[currentStructure.length - 1] !== 'Outro') { currentStructure = currentStructure.filter(p => p !== 'Outro'); currentStructure.push('Outro'); } currentStructure.forEach((part, index) => { if (lines[part]) { fullLyrics += `[${part}${index > 0 && part === currentStructure[index-1] ? ' 2' : ''}]\n`; const numLines = (part === 'Chorus' || part === 'Verse') ? getRandom([2, 3]) : 1; let usedLines = new Set(); for (let i = 0; i < numLines; i++) { let line; do { line = getRandom(lines[part]); } while (usedLines.has(line) && lines[part].length > 1); usedLines.add(line); fullLyrics += line + "\n"; } fullLyrics += "\n"; } }); lyricsInput.value = fullLyrics.trim(); }

        // --- Gemini API Call Helper (Unchanged) ---
        async function callGeminiAPI(promptText, loadingMessageKey = "generatingCreativeSparks", loadingFallback = "Generating...") { const GEMINI_API_KEY = "AIzaSyB5c-hp-QeKBpBTz8qwANe4j5Kc4dZ_bWM"; if (!GEMINI_API_KEY || GEMINI_API_KEY.startsWith("YOUR_") || GEMINI_API_KEY.length < 30) { displayError(getTranslatedText(null, 'errorApiKeyInvalid', false, "API Key is missing or invalid."), 'errorApiKeyInvalid'); return null; } const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`; showLoading(loadingMessageKey, loadingFallback); const requestBody = { contents: [{ parts: [{ text: promptText }] }], generationConfig: { temperature: 0.75, maxOutputTokens: 4096, }, safetySettings: [ { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }, ] }; try { console.log("Sending API request..."); const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) }); const responseData = await response.json(); if (!response.ok) { const errorDetail = responseData?.error?.message || `HTTP Error: ${response.status}`; if (response.status === 0) throw new Error(getTranslatedText(null, 'errorCorsOrNetwork', false, 'Network/CORS error.')); throw new Error(getTranslatedText(null, 'errorApiHttp', false, `API fail: ${errorDetail}`).replace('${errorDetail}', errorDetail)); } const candidate = responseData?.candidates?.[0]; if (!candidate || responseData?.promptFeedback?.blockReason || candidate.finishReason === "SAFETY") { const reason = candidate?.finishReason || responseData?.promptFeedback?.blockReason || "Unknown"; throw new Error(getTranslatedText(null, 'errorApiBlocked', false, `Blocked by safety (Reason: ${reason}).`).replace('${reason}', reason)); } if (responseData?.error) throw new Error(getTranslatedText(null, 'errorApiGeneral', false, `API Error: ${responseData.error.message}`).replace('${errorMessage}', responseData.error.message)); const finishReason = candidate.finishReason; if (finishReason && !["STOP", "MAX_TOKENS"].includes(finishReason)) console.warn(`Abnormal finish: ${finishReason}`); if (finishReason === "MAX_TOKENS") console.warn("Max tokens reached."); if (candidate?.content?.parts?.[0]?.text) return candidate.content.parts[0].text.trim(); else throw new Error(getTranslatedText(null, 'errorApiEmptyResponse', false, "Empty response from AI.")); } catch (error) { console.error("API Error:", error); let errorKey = 'errorUnknown'; const msg = String(error.message).toLowerCase(); if (msg.includes("api key") || msg.includes("invalid")) errorKey = 'errorApiKeyInvalid'; else if (msg.includes("http error")) errorKey = 'errorApiHttp'; else if (msg.includes("blocked") || msg.includes("safety")) errorKey = 'errorApiBlocked'; else if (msg.includes("api error")) errorKey = 'errorApiGeneral'; else if (msg.includes("empty text response")) errorKey = 'errorApiEmptyResponse'; else if (msg.includes('network') || msg.includes('cors') || msg.includes('failed to fetch')) errorKey = 'errorCorsOrNetwork'; displayError(error.message, errorKey); return null; } finally { hideLoading(); } }

        // --- Generate Initial Concept (Step 1 -> 2) ---
        async function handleGenerateConcept() {
            const lyrics = lyricsInput.value.trim();
            const keywords = keywordsInput.value.trim();
            const selectedGenre = genreSelect.value;
            const singingTranscript = transcriptOutput.value.trim();
            let validationError = false, errorMsg = '', errorKey = '', focusEl = null;
             if (!lyrics) { errorMsg = getTranslatedText(lyricsInput, 'placeholder', true) || "Provide lyrics."; errorKey = 'validationLyricsMissing'; focusEl = lyricsInput; validationError = true; }
             else if (!keywords) { errorMsg = getTranslatedText(keywordsInput, 'placeholder', true) || "Provide keywords."; errorKey = 'validationKeywordsMissing'; focusEl = keywordsInput; validationError = true; }
             else if (!selectedGenre) { errorMsg = getTranslatedText(genreSelect.options[0]) || "Select genre."; errorKey = 'validationGenreMissing'; focusEl = genreSelect; validationError = true; }
             if(validationError) { displayError(errorMsg, errorKey); focusEl?.focus(); return; }
            currentInputs = { lyrics, keywords, selectedGenre, singingTranscript };
            currentDetailedResultsText = ''; 
            // Clear previously stored images when generating a new concept
            if (storedPageData.feature && storedPageData.feature.imagePlaceholders) {
                storedPageData.feature.imagePlaceholders = [];
            }

            clearErrors(); updateGeneratePageUI('loading');
            const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Analyze the following song details:
**Lyrics:**
\`\`\`
${lyrics}
\`\`\`${singingTranscript ? `
**Singing Transcript (Optional Context):**
\`\`\`
${singingTranscript}
\`\`\`
` : ''}
**Keywords/Theme:** ${keywords}
**Music Genre:** ${selectedGenre}

Generate **ONLY** the "Concept / Key Visual" section for a music video based on these details. Provide a concise, compelling core concept description (around 2-5 sentences). Mention 1-2 key visual motifs or scenes. Output *only the description text itself*, without any headers like "## Concept / Key Visual".`;
            const generatedText = await callGeminiAPI(prompt, "generatingConcept", "Generating Concept...");
            if (generatedText) {
                currentConceptText = generatedText; conceptTextOutput.textContent = currentConceptText;
                conceptTextOutput.classList.remove('placeholder-notice');
                updateGeneratePageUI('concept_shown');
                errorMessageDiv.style.display = 'none';
            } else { updateGeneratePageUI('initial'); }
        }

        // --- Pick Concept -> Fetch Details (Step 2 -> 3) ---
        async function handlePickConcept() {
             if (!currentInputs || !currentConceptText) { displayError(getTranslatedText(null, 'errorExploreNoConcept', false, "Generate concept first."), 'errorExploreNoConcept'); return; }
             if(pickConceptButton) pickConceptButton.disabled = true; if(regenerateConceptButtonAlt) regenerateConceptButtonAlt.disabled = true;
             // Clear previously stored images when fetching new details for the chosen concept
             if (storedPageData.feature && storedPageData.feature.imagePlaceholders) {
                storedPageData.feature.imagePlaceholders = [];
             }

             updateGeneratePageUI('loading');
            const { lyrics, keywords, selectedGenre, singingTranscript } = currentInputs;
            const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Based on the original song details:
**Lyrics:**
\`\`\`
${lyrics}
\`\`\`${singingTranscript ? `
**Singing Transcript (Optional Context):**
\`\`\`
${singingTranscript}
\`\`\`
` : ''}
**Keywords/Theme:** ${keywords}
**Music Genre:** ${selectedGenre}

And this CHOSEN "Concept / Key Visual":
\`\`\`
${currentConceptText.replace(/`/g, '\\`')} 
\`\`\`

Provide the following detailed sections for the music video. Structure *exactly* like this in English:

## Requirements for MV
(* or - list item: Detail about location, casting, props, wardrobe, cinematography, VFX, editing style, etc. Be specific and relevant.)

## Estimated Budget
(**Low Budget:** ~$Range (Optional). Description of approach.
- Example Item - $Cost (Optional, list a few key cost drivers if applicable)

**Mid Budget:** ~$Range (Optional). Description of approach, potentially scaling up elements from Low.
- Example Item - $Cost

**High Budget:** ~$Range (Optional). Description of approach, allowing for higher production value.
- Example Item - $Cost
)

## Visual Demo (Key Images)
(1. Vivid description of a key scene or visual moment suitable for image generation.
2. Another vivid description for image generation.
3. A third vivid description for image generation.)

## Moodboard Influences
(A short sentence describing the overall mood and visual style.
* Specific visual element or reference suitable for image generation (e.g., Film noir lighting, rainy cityscape).
* Another specific element for image generation (e.g., Wes Anderson symmetrical composition, pastel diner).
* Style reference for image generation (e.g., Surrealist painting style, dreamlike forest).
* Color influence (e.g., Muted pastels).
* Textural element (e.g., Grainy film stock).
)

## Typography/Font Suggestion
(Suggest ONE suitable font combination (1 or 2 fonts).
**Font Combination:** [Font Name 1] & [Font Name 2 (Optional)]
*Reason:* [Explain why this combination (or single font) fits the song's lyrics, theme, genre, and mood. Be specific.]
*Sample Title (Using Font 1):* "[Create a short, relevant sample sentence using the first font]"
*[Optional] Sample Body (Using Font 2):* "[Create a short, relevant sample sentence using the second font, if applicable]"
Provide actual, common font names (e.g., 'Montserrat', 'Playfair Display', 'Roboto Mono'). Ensure samples showcase the font's feel.)

## Color Palette
(List 3-5 colors. Indicate the DOMINANT color first. For each color, provide its name, hex code, and a brief application suggestion for the MV. Use the exact format below, one color per line.)
Dominant Color Name (#XXXXXX) - Application: [Use this for main backgrounds or character outfits to set the core mood.]
Secondary Color Name (#YYYYYY) - Application: [Apply to secondary elements like set dressing or subtle gradients.]
Accent Color Name (#ZZZZZZ) - Application: [Use sparingly to highlight key props, text overlays, or create visual contrast.]
(Add more secondary/accent colors if appropriate, following the same format)

Adhere strictly to the format: Use the exact headers (##), use bullet points (* or -) for Requirements and Moodboard lists, use numbering (1., 2., 3.) for Visual Demo, use the bold format **Level Budget:** for budget tiers. For Fonts, use the exact format with **Font Combination:**, *Reason:*, *Sample Title:*, *Sample Body:*. For Colors, use the exact format 'Color Name (#XXXXXX) - Application: [description]', starting with 'Dominant'. Provide detailed, relevant content for each section. Use plausible USD ($) ranges for budget. Ensure Visual Demo and Moodboard list items are descriptive image prompts.`;
            const generatedText = await callGeminiAPI(prompt, "fetchingDetails", "Fetching More Details...");
            if (generatedText) {
                currentDetailedResultsText = generatedText; 
                clearTabContents();
                parseAndDisplayDetailedResults(generatedText); // This will now trigger new image generations if not restored
                updateGeneratePageUI('details_shown');
                errorMessageDiv.style.display = 'none';
            } else {
                 updateGeneratePageUI('concept_shown');
                 if(pickConceptButton) pickConceptButton.disabled = false;
                 if(regenerateConceptButtonAlt) regenerateConceptButtonAlt.disabled = false;
            }
        }

        // --- Re-Generate Concept (Step 2 -> Step 1 -> Step 2) (Unchanged) ---
        function handleRegenerateConceptAlt() { handleGenerateConcept(); }

        // --- Parsing and Displaying Detailed Results into Tabs ---
        function parseAndDisplayDetailedResults(text) {
             console.log("--- Parsing Detailed AI Response for Tabs---");
             const lines = text.split('\n'); let currentSectionKey = null; let currentTargetTabId = null; let contentBuffer = ''; let foundAnySection = false; const processedTabIds = new Set(); let unrecognizedHeaders = [];
             
             const conceptTabContent = document.getElementById('tab-content-concept');
             if (conceptTabContent && currentConceptText) {
                processSectionContent('tab-content-concept', 'Concept / Key Visual', currentConceptText);
                processedTabIds.add('tab-content-concept');
                foundAnySection = true;
             } else {
                console.warn("Could not inject stored concept text for #tab-content-concept.");
             }

             lines.forEach((line, lineIndex) => {
                const trimmedLine = line.trim();
                let matchedHeader = false;
                let sectionTitleMatch = null;
                let targetTabIdMatch = null;

                if (trimmedLine.startsWith('##')) {
                    for (const title in sectionsToTabs) {
                        const escapedTitle = title.trim().replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&').replace(/\\s\*\\\/\\s\*/, '\\s*\\/?\\s*');
                        const headerRegex = new RegExp(`^##\\s*\\*?\\*?${escapedTitle}\\*?\\*?\\s*$`, 'i');
                        if (headerRegex.test(trimmedLine)) {
                            sectionTitleMatch = title;
                            targetTabIdMatch = sectionsToTabs[title];
                            matchedHeader = true;
                            console.log(`>>> MATCHED Header: ${sectionTitleMatch} -> #${targetTabIdMatch}`);
                            break;
                        }
                    }
                    if (!matchedHeader && trimmedLine.startsWith('##')) {
                        console.warn(`Unrecognized header: "${trimmedLine}"`);
                        unrecognizedHeaders.push(trimmedLine);
                    }
                }

                if (matchedHeader && sectionTitleMatch && targetTabIdMatch) {
                    if (currentSectionKey && currentTargetTabId && contentBuffer.trim()) {
                        if (currentTargetTabId !== 'tab-content-concept') { 
                            console.log(`Processing buffered content for: ${currentSectionKey} -> #${currentTargetTabId}`);
                            try {
                                processSectionContent(currentTargetTabId, currentSectionKey, contentBuffer.trim());
                                processedTabIds.add(currentTargetTabId);
                                foundAnySection = true;
                            } catch (processError) {
                                handleProcessingErrorInTab(currentTargetTabId, currentSectionKey, processError);
                                processedTabIds.add(currentTargetTabId);
                            }
                        }
                    }
                    currentSectionKey = sectionTitleMatch;
                    currentTargetTabId = targetTabIdMatch;
                    contentBuffer = ''; 
                } else if (currentSectionKey && currentTargetTabId) {
                    if (!unrecognizedHeaders.includes(trimmedLine)) {
                        contentBuffer += line + '\n';
                    }
                }
            });
            
             if (currentSectionKey && currentTargetTabId && contentBuffer.trim()) {
                if (currentTargetTabId !== 'tab-content-concept') { 
                    console.log(`Processing final content for: ${currentSectionKey} -> #${currentTargetTabId}`);
                    try {
                        processSectionContent(currentTargetTabId, currentSectionKey, contentBuffer.trim());
                        processedTabIds.add(currentTargetTabId);
                        foundAnySection = true;
                    } catch (processError) {
                        handleProcessingErrorInTab(currentTargetTabId, currentSectionKey, processError);
                        processedTabIds.add(currentTargetTabId);
                    }
                }
             }

             console.log("--- Finished Parsing Details ---"); console.log("Found any detailed section (incl. concept):", foundAnySection); console.log("Processed Tab IDs:", Array.from(processedTabIds));
             Object.keys(tabTitles).forEach(tabId => { if (!processedTabIds.has(tabId)) { const contentDiv = document.getElementById(tabId); const sectionTitleKey = Object.keys(sectionsToTabs).find(key => sectionsToTabs[key] === tabId); if (contentDiv && sectionTitleKey) { console.warn(`Tab content for "${tabTitles[tabId]}" (#${tabId}) not found/processed. Setting placeholder.`); setPlaceholderForMissingTab(contentDiv, sectionTitleKey); } else if (contentDiv) { console.warn(`Tab content for #${tabId} not found, unknown section key.`); contentDiv.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Content unavailable.')}</p>`; contentDiv.classList.add('placeholder-notice'); } } });
              if (!foundAnySection) { console.error("Parsing detailed results failed: No sections processed."); displayError(getTranslatedText(null, 'errorParsingFailed', false, "Could not parse details."), 'errorParsingFailed'); }
         }
         function handleProcessingErrorInTab(targetTabId, sectionKey, error) { console.error(`Error processing section "${sectionKey}" for tab #${targetTabId}:`, error); const contentDiv = document.getElementById(targetTabId); if (contentDiv) { contentDiv.innerHTML = `<p class="placeholder-notice error">${getTranslatedText(null, 'errorDisplayingSection', false, 'Error displaying section content.')}</p>`; contentDiv.classList.add('placeholder-notice'); } }

        // --- Process Individual Section Content (TARGETS TAB CONTENT) (Unchanged) ---
        function processSectionContent(targetTabId, sectionTitleKey, content) {
            const contentDiv = document.getElementById(targetTabId); if (!contentDiv) { console.error(`Target tab content div #${targetTabId} not found!`); return; } contentDiv.innerHTML = ''; contentDiv.classList.remove('placeholder-notice'); let sectionHasContent = false;
            try {
                if (targetTabId === 'tab-content-visuals') { const container = document.createElement('div'); container.className = 'image-placeholder-container'; contentDiv.appendChild(container); const descs = content.split(/^\s*[1-9][0-9]*[\.\)\-]\s+/gm).filter(Boolean).map(d => d.trim().replace(/\n$/, '')); if (descs.length > 0) { descs.slice(0, 3).forEach((d, i) => { if(d) { createImagePlaceholder(container, d, `v-${i}`, 'visuals'); sectionHasContent = true; } }); } if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noVisualsFound', false, 'No key image descriptions provided.')}</p>`; container.classList.add('placeholder-notice'); } const note = document.createElement('small'); note.dataset.langEn = "Illustrative images based on descriptions."; note.dataset.placeholderKey="visualsNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note); }
                else if (targetTabId === 'tab-content-moodboard') { const descEl = document.createElement('p'); descEl.id = 'moodboard-description'; contentDiv.appendChild(descEl); const imgContainer = document.createElement('div'); imgContainer.className = 'image-placeholder-container'; imgContainer.id = 'moodboard-images'; contentDiv.appendChild(imgContainer); const lines = content.trim().split('\n'); let mainDesc = '', items = []; let readingDesc = true; for (const line of lines) { const trimmed = line.trim(); if (trimmed.match(/^[\*\-]\s+/)) { readingDesc = false; items.push(trimmed.replace(/^[\*\-]\s+/, '').trim()); } else if (readingDesc && trimmed) { mainDesc += line + '\n'; } else if (!readingDesc && trimmed && items.length > 0) { items[items.length - 1] += '\n' + trimmed; } } mainDesc = mainDesc.trim(); items = items.filter(Boolean); if (mainDesc) { descEl.innerHTML = mainDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); descEl.style.display = 'block'; descEl.classList.remove('placeholder-notice'); sectionHasContent = true; } else { descEl.innerHTML = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Moodboard description missing.'); descEl.style.display = 'block'; descEl.classList.add('placeholder-notice'); descEl.dataset.placeholderKey="moodboardDescPlaceholder"; } if (items.length > 0) { imgContainer.innerHTML = ''; imgContainer.classList.remove('placeholder-notice'); items.slice(0, 5).forEach((d, i) => { if(d) { createImagePlaceholder(imgContainer, d, `m-${i}`, 'moodboard'); sectionHasContent = true; } }); } else { imgContainer.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'noMoodboardItemsFound', false, 'No moodboard images provided.')}</p>`; imgContainer.classList.add('placeholder-notice'); } if (sectionHasContent) { const note = document.createElement('small'); note.dataset.langEn = "Visual styles and elements for inspiration."; note.dataset.placeholderKey="moodboardNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note); } else if (!mainDesc && items.length === 0) { contentDiv.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardDescPlaceholder">${getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Moodboard description missing.')}</p><div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'No moodboard images provided.')}</p></div>`; contentDiv.classList.add('placeholder-notice'); } }
                 else if (targetTabId === 'tab-content-budget') { let container = contentDiv.querySelector('.budget-columns-container'); if (!container) { container = document.createElement('div'); container.className = 'budget-columns-container'; contentDiv.appendChild(container); } else { container.innerHTML = ''; } container.classList.remove('placeholder-notice'); const budgetRegex = /\*\*(Low\s*Budget|Mid\s*Budget|High\s*Budget)\*\*\s*:?\s*([\s\S]*?)(?=\n?\s*\*\*(?:Low|Mid|High)\s*Budget\*\*|$)/gi; const budgetLevels = {}; let match; let parsingSuccess = false; while ((match = budgetRegex.exec(content)) !== null) { parsingSuccess = true; const levelTitle = match[1].replace(/\s+/g, ' ').trim(); const levelKey = levelTitle.split(' ')[0]; let rawContent = match[2].trim(); let range = ''; let description = ''; const rangePatterns = [ /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*[-–—]\s*[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*USD|EUR|GBP)?/i, /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*\+(?:\s*USD|EUR|GBP)?/i, /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*USD|EUR|GBP)?/i ]; for (const pattern of rangePatterns) { const rangeMatch = rawContent.match(new RegExp(`^\\s*\\(?(${pattern.source})\\)?\\s*`, 'i')); if (rangeMatch) { range = rangeMatch[1].trim(); description = rawContent.substring(rangeMatch[0].length).trim(); break; } } if (!range) description = rawContent; budgetLevels[levelKey] = { title: levelTitle, range: range, description: description }; } const order = ["Low", "Mid", "High"]; let anyColumnHasContent = false; order.forEach(levelKey => { const colDiv = document.createElement('div'); colDiv.className = 'budget-column'; const titleH3 = document.createElement('h3'); const descP = document.createElement('p'); if (budgetLevels[levelKey]) { const data = budgetLevels[levelKey]; titleH3.textContent = data.title + (data.range ? ` (${data.range})` : ''); let processedDesc = data.description; let itemBoxesHTML = ''; const itemCostRegex = /^\s*[-*]\s*(.+?)\s*[-–—:]\s*([\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*[-–—]\s*[\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b)?(?:\s*USD|\s*EUR|\s*GBP)?)\s*$/gm; processedDesc = processedDesc.replace(itemCostRegex, (matchStr, item, cost) => { itemBoxesHTML += `<div class="budget-item-box">${item.trim()}: <strong>${cost.trim()}</strong></div>`; return ''; }).trim(); processedDesc = processedDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); descP.innerHTML = processedDesc + itemBoxesHTML; if(descP.innerHTML.trim() === ''){ descP.innerHTML = `(${getTranslatedText(null, 'budgetDetailsMissing', false, 'Details missing')})`; descP.classList.add('placeholder-notice'); } else { anyColumnHasContent = true; } } else { titleH3.textContent = getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`); descP.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`; descP.classList.add('placeholder-notice'); colDiv.classList.add('placeholder-notice'); } colDiv.appendChild(titleH3); colDiv.appendChild(descP); container.appendChild(colDiv); }); if (!parsingSuccess && content.trim()) { container.innerHTML = `<div class="raw-budget-output"><pre>${content}</pre></div>`; container.classList.add('placeholder-notice'); console.warn("Budget parsing failed, raw display."); } else if (!anyColumnHasContent && !parsingSuccess) { container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noBudgetContentFound', false, 'No budget details provided.')}</p>`; container.classList.add('placeholder-notice'); } else { sectionHasContent = true; } let note = contentDiv.querySelector('small'); if (!note) { note = document.createElement('small'); note.dataset.langEn = "Note: Budgets are conceptual estimates..."; note.dataset.placeholderKey="budgetNotePlaceholder"; contentDiv.appendChild(note); } note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); }
                 else if (targetTabId === 'tab-content-requirements') { const listEl = document.createElement('ul'); contentDiv.appendChild(listEl); const items = content.trim().split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(item => item.trim().replace(/\n$/, '')); if (items.length > 0) { items.forEach(item => { const li = document.createElement('li'); li.innerHTML = item.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); listEl.appendChild(li); }); sectionHasContent = true; } else { listEl.innerHTML = `<li class="placeholder-notice" data-placeholder-key="requirementsPlaceholder">${getTranslatedText(null, 'noRequirementsFound', false, 'No requirements listed.')}</li>`; listEl.classList.add('placeholder-notice'); } }
                 else if (targetTabId === 'tab-content-fonts') { const suggestionDiv = document.createElement('div'); suggestionDiv.className = 'font-suggestion'; const combinationMatch = content.match(/\*\*Font Combination:\*\*\s*(.*?)(?:\s*&\s*(.*?))?\s*$/im); const reasonMatch = content.match(/\*Reason:\*\s*([\s\S]*?)(?=\n\s*\*Sample|\n\s*$)/i); const sampleTitleMatch = content.match(/\*Sample Title(?: \(Using Font 1\))?:\*\s*"(.*?)"/i); const sampleBodyMatch = content.match(/\*Sample Body(?: \(Using Font 2\))?:\*\s*"(.*?)"/i); if (combinationMatch && reasonMatch && sampleTitleMatch) { sectionHasContent = true; const font1 = combinationMatch[1]?.trim(); const font2 = combinationMatch[2]?.trim(); const reason = reasonMatch[1]?.trim(); const sampleTitle = sampleTitleMatch[1]?.trim(); const sampleBody = sampleBodyMatch?.[1]?.trim(); const comboH3 = document.createElement('h3'); comboH3.textContent = font1 + (font2 ? ` & ${font2}` : ''); suggestionDiv.appendChild(comboH3); const reasonP = document.createElement('p'); reasonP.className = 'font-reason'; reasonP.innerHTML = reason.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); suggestionDiv.appendChild(reasonP); const sampleTitleDiv = document.createElement('div'); sampleTitleDiv.className = 'font-sample'; sampleTitleDiv.style.fontFamily = `'${font1}', ${fontFamilyFallback(font1)}`; sampleTitleDiv.innerHTML = `<strong>${getTranslatedText(null, 'fontSampleTitleLabel', false, 'Title:')}</strong> "${sampleTitle}"`; suggestionDiv.appendChild(sampleTitleDiv); if (font2 && sampleBody) { const sampleBodyDiv = document.createElement('div'); sampleBodyDiv.className = 'font-sample'; sampleBodyDiv.style.fontFamily = `'${font2}', ${fontFamilyFallback(font2)}`; sampleBodyDiv.innerHTML = `<strong>${getTranslatedText(null, 'fontSampleBodyLabel', false, 'Body:')}</strong> "${sampleBody}"`; suggestionDiv.appendChild(sampleBodyDiv); } contentDiv.appendChild(suggestionDiv); } else { console.warn("Font parsing failed."); } if (!sectionHasContent) { contentDiv.innerHTML = `<p class="placeholder-notice" data-placeholder-key="fontsPlaceholder">${getTranslatedText(null, 'noFontsFound', false, 'No font suggestions provided.')}</p>`; contentDiv.classList.add('placeholder-notice'); } }
                 else if (targetTabId === 'tab-content-palette') { const container = document.createElement('div'); container.className = 'color-palette-display'; contentDiv.appendChild(container); sectionHasContent = createColorSwatches(container, content.trim()); if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice" data-placeholder-key="palettePlaceholder">${getTranslatedText(null, 'noColorsFound', false, 'No color palette provided.')}</p>`; container.classList.add('placeholder-notice'); } }
                 else if (targetTabId === 'tab-content-concept') { const pEl = document.createElement('p'); pEl.style.whiteSpace = 'pre-wrap'; const processedContent = content.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); pEl.innerHTML = processedContent; contentDiv.appendChild(pEl); if (processedContent) sectionHasContent = true; }
                 else { console.warn(`No specific handler for tab ${targetTabId}, using default paragraph.`); const pEl = document.createElement('p'); const processedContent = content.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); pEl.innerHTML = processedContent; contentDiv.appendChild(pEl); if (processedContent) sectionHasContent = true; }
                if (!sectionHasContent && contentDiv.innerHTML.trim() === '') { console.warn(`Section "${sectionTitleKey}" processed but resulted in empty content for tab #${targetTabId}.`); setPlaceholderForMissingTab(contentDiv, sectionTitleKey); }
            } catch (error) { handleProcessingErrorInTab(targetTabId, sectionTitleKey, error); }
        }

        // --- Helper for Font Fallback CSS (Unchanged) ---
        function fontFamilyFallback(fontName = '') { const lower = fontName.toLowerCase(); if (lower.includes('serif') || lower.includes('playfair') || lower.includes('lora')) return 'serif'; if (lower.includes('mono') || lower.includes('courier')) return 'monospace'; if (lower.includes('script') || lower.includes('cursive')) return 'cursive'; if (lower.includes('display') || lower.includes('oswald')) return 'sans-serif'; return 'sans-serif'; }

        // --- Helper to set placeholders for MISSING tab content (Unchanged) ---
         function setPlaceholderForMissingTab(contentDiv, sectionTitleKey) {
             if (!contentDiv) return; contentDiv.innerHTML = ''; contentDiv.classList.add('placeholder-notice'); const targetTabId = sectionsToTabs[sectionTitleKey] || ''; let placeholderKey = 'placeholderGeneric', fallbackText = 'Missing content.', placeholderHTML = '';
              switch (targetTabId) {
                  case 'tab-content-requirements': placeholderKey = 'requirementsPlaceholder'; fallbackText = 'Requirements list will appear here...'; placeholderHTML = `<ul class="placeholder-notice"><li class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</li></ul>`; break;
                  case 'tab-content-budget': placeholderKey = 'budgetPlaceholder'; fallbackText = 'Budget details will appear here...'; const noteText = getTranslatedText(null, 'budgetNotePlaceholder', false, 'Note: Budgets are estimates...'); placeholderHTML = `<div class="budget-columns-container placeholder-notice">`; ["Low", "Mid", "High"].forEach(levelKey => { placeholderHTML += `<div class="budget-column placeholder-notice"><h3>${getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`)}</h3><p class="placeholder-notice" data-placeholder-key="budgetDetailsMissing">(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})</p></div>`; }); placeholderHTML += `</div><small data-placeholder-key="budgetNotePlaceholder">${noteText}</small>`; break;
                  case 'tab-content-visuals': placeholderKey = 'visualsPlaceholder'; fallbackText = 'Key visual descriptions will appear here...'; const visualsNote = getTranslatedText(null, 'visualsNotePlaceholder', false,'Illustrative images...'); placeholderHTML = `<div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div><small data-placeholder-key="visualsNotePlaceholder">${visualsNote}</small>`; break;
                  case 'tab-content-moodboard': const moodDesc = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Moodboard description will appear here...'); const moodImgs = getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'Moodboard influence images will appear here...'); const moodNote = getTranslatedText(null, 'moodboardNotePlaceholder', false,'Visual styles...'); placeholderHTML = `<p data-placeholder-key="moodboardDescPlaceholder" id="moodboard-description" class="placeholder-notice">${moodDesc}</p><div class="image-placeholder-container placeholder-notice" id="moodboard-images"><p data-placeholder-key="moodboardImgsPlaceholder">${moodImgs}</p></div><small data-placeholder-key="moodboardNotePlaceholder">${moodNote}</small>`; break;
                  case 'tab-content-fonts': placeholderKey = 'fontsPlaceholder'; fallbackText = 'Font suggestions will appear here...'; placeholderHTML = `<p data-placeholder-key="${placeholderKey}" class="placeholder-notice">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`; break;
                  case 'tab-content-palette': placeholderKey = 'palettePlaceholder'; fallbackText = 'Color palette will appear here...'; placeholderHTML = `<div class="color-palette-display placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div>`; break;
                  case 'tab-content-concept': placeholderKey = 'conceptPlaceholder'; fallbackText = 'Concept description will appear here...'; placeholderHTML = `<p data-placeholder-key="${placeholderKey}" class="placeholder-notice" style="white-space: pre-wrap;">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`; break;
                  default: placeholderHTML = `<p class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
              }
              contentDiv.innerHTML = placeholderHTML;
         }

        // --- Image Generation & Restoration Functions ---
        async function createImagePlaceholder(container, description, seedSuffix, tabType) { 
            const figure = document.createElement('figure'); 
            figure.className = 'image-placeholder';
            figure.dataset.seedSuffix = seedSuffix; // Store seedSuffix on the element for later retrieval

            const img = document.createElement('img'); 
            img.alt = `Loading...`; 
            img.src = ''; 
            img.loading = 'lazy'; 
            let phHeight = (tabType === 'moodboard') ? 130 : 160; 
            img.style.cssText = `height: ${phHeight}px; width: 100%; object-fit: cover; background-color: #444; border-bottom: 1px solid var(--border-color);`; 
            
            const figcaption = document.createElement('figcaption'); 
            figcaption.innerHTML = description.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); 
            
            figure.appendChild(img); 
            figure.appendChild(figcaption); 
            container.appendChild(figure); 
            container.classList.remove('placeholder-notice');
            
            const promptForApi = description.replace(/<[^>]*>/g, '').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim(); 

            // Check for stored image data
            const storedImage = storedPageData.feature?.imagePlaceholders?.find(imgData => imgData.seedSuffix === seedSuffix);

            if (storedImage && storedImage.src && storedImage.src !== '' && !storedImage.src.startsWith('data:')) {
                console.log(`Restoring image for ${seedSuffix} from stored data:`, storedImage.src);
                img.src = storedImage.src;
                img.alt = storedImage.alt || promptForApi; 
                if (storedImage.figcaptionHTML) { // Use stored figcaption if available for consistency with the image
                    figcaption.innerHTML = storedImage.figcaptionHTML;
                }
                img.onload = () => { img.style.backgroundColor = 'transparent'; };
                img.onerror = () => {
                    console.warn(`Failed to load stored image for ${seedSuffix}: ${storedImage.src}. Attempting fallback.`);
                    setFallbackImage(img, figcaption, description, seedSuffix, 'stored-img-load-err', phHeight);
                };
                return; // Image restored, no need to fetch
            }
            
            if (!promptForApi) { 
                setFallbackImage(img, figcaption, description, seedSuffix, 'empty-prompt', phHeight); 
                return; 
            } 
            
            const BACKEND_API_URL = '/api/generate-image'; 
            try { 
                await new Promise(resolve => setTimeout(resolve, 50)); 
                const response = await fetch(BACKEND_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ description: promptForApi }) }); 
                const responseData = await response.json(); 
                if (!response.ok) { const errorDetail = responseData?.error || `Backend Error: ${response.status}`; console.error("Backend proxy error:", errorDetail); displayError(`${getTranslatedText(null, 'errorBackendProxy', false, 'Img Gen Err:')} ${errorDetail}`, 'errorBackendProxy'); setFallbackImage(img, figcaption, description, seedSuffix, `backend-err-${response.status}`, phHeight); return; } 
                
                if (responseData.imageUrl?.startsWith('http')) { 
                    img.onload = () => { img.style.backgroundColor = 'transparent'; }; 
                    img.onerror = () => { setFallbackImage(img, figcaption, description, seedSuffix, 'backend-img-load-err', phHeight); }; 
                    img.src = responseData.imageUrl; 
                    img.alt = promptForApi;

                    // Update/add to storedPageData.feature.imagePlaceholders
                    if (!storedPageData.feature.imagePlaceholders) {
                        storedPageData.feature.imagePlaceholders = [];
                    }
                    storedPageData.feature.imagePlaceholders = storedPageData.feature.imagePlaceholders.filter(
                        item => item.seedSuffix !== seedSuffix
                    );
                    storedPageData.feature.imagePlaceholders.push({
                        seedSuffix: seedSuffix,
                        tabId: tabType,
                        src: responseData.imageUrl,
                        alt: promptForApi,
                        figcaptionHTML: figcaption.innerHTML // Current figcaption content
                    });

                } else { 
                    setFallbackImage(img, figcaption, description, seedSuffix, 'backend-invalid-url', phHeight); 
                } 
            } catch (error) { 
                console.error("Error fetching from Backend Proxy:", error); 
                let reason = 'backend-fetch-error'; 
                let userMsgKey = 'errorBackendFetch'; 
                if (error instanceof TypeError) reason = 'backend-network'; 
                displayError(getTranslatedText(null, userMsgKey, false, 'Network error contacting server for image gen.'), reason); 
                setFallbackImage(img, figcaption, description, seedSuffix, reason, phHeight); 
            } 
        }


        // --- Fallback Image Logic (Unchanged) ---
        function setFallbackImage(imgEl, figcaptionEl, desc, seed, reason, height) { console.warn(`Setting fallback. Reason: ${reason}`); const seedEnc = encodeURIComponent(desc.substring(0, 15) + seed + '-' + reason); const picSumH = Math.max(150, Math.round(height * 1.5)); const picSumW = Math.round(picSumH * 1.6); imgEl.onload = () => { imgEl.style.backgroundColor = 'transparent'; }; imgEl.onerror = () => { imgEl.style.backgroundColor = '#555'; imgEl.alt = `Fallback failed (${reason})` }; imgEl.src = `https://picsum.photos/seed/${seedEnc}/${picSumW}/${picSumH}.webp`; imgEl.alt = `Placeholder: ${desc.substring(0, 50)}... (${reason})`; figcaptionEl.querySelector('.generation-source')?.remove(); figcaptionEl.querySelector('.fallback-notice')?.remove(); const notice = document.createElement('span'); notice.className = 'fallback-notice'; notice.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${reason})`; figcaptionEl.appendChild(notice); }

        // --- Color Swatch Creation (Unchanged Core Logic) ---
         function createColorSwatches(container, text) { if (!container) return false; container.innerHTML = ''; container.classList.remove('placeholder-notice'); let foundColors = false; let swatchIndex = 0; const lines = text.trim().split('\n'); lines.forEach(line => { const colorRegex = /^(Dominant\s+)?([\w\s\-\/()]+?)\s*\(?\s*(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})\s*\)?\s*-\s*Application:\s*(.*)$/i; const match = line.trim().match(colorRegex); if (match) { const isDominant = !!match[1]; let name = match[2].trim(); let hex = match[3].trim().toUpperCase(); const application = match[4].trim(); if (!name || name.length < 2) return; if (hex.length === 4) hex = '#' + hex[1].repeat(2) + hex[2].repeat(2) + hex[3].repeat(2); if (!/^#[0-9A-F]{6}$/.test(hex)) { console.warn(`Invalid hex: ${match[3]}`); return; } foundColors = true; const swatch = document.createElement('div'); swatch.className = 'color-swatch'; if (isDominant) swatch.classList.add('dominant-swatch'); const colorBlock = document.createElement('div'); colorBlock.className = 'color-block'; try { colorBlock.style.backgroundColor = hex; colorBlock.style.color = isColorDarkGuess(hex) ? 'var(--text-primary)' : 'var(--bg-dark)'; } catch (e) { console.warn(`Invalid color ${hex}`); return; } const hexSpan = document.createElement('span'); hexSpan.className = 'hex-code'; hexSpan.textContent = hex; colorBlock.appendChild(hexSpan); const infoDiv = document.createElement('div'); infoDiv.className = 'color-info'; const nameSpan = document.createElement('span'); nameSpan.className = 'color-name'; nameSpan.textContent = name; infoDiv.appendChild(nameSpan); const appP = document.createElement('p'); appP.className = 'color-application'; appP.innerHTML = application.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); infoDiv.appendChild(appP); swatch.appendChild(colorBlock); swatch.appendChild(infoDiv); container.appendChild(swatch); requestAnimationFrame(() => setTimeout(() => swatch.classList.add('visible'), 50 + swatchIndex * 70)); swatchIndex++; } else if (line.trim()) { console.warn("Could not parse color line:", line); } }); return foundColors; }

        // --- Color Lightness Guess (Unchanged) ---
        function isColorDarkGuess(hexColor) { try { if (!hexColor?.startsWith('#')) return false; let hex = hexColor.substring(1); if (hex.length === 3) hex = hex[0].repeat(2) + hex[1].repeat(2) + hex[2].repeat(2); if (hex.length !== 6) return false; const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); return (0.299 * r + 0.587 * g + 0.114 * b) / 255 < 0.5; } catch (e) { return false; } }

        // --- Utility Functions ---
        function clearTabContents() { if (!tabContents) return; tabContents.forEach(tab => { const tabId = tab.id; const sectionTitleKey = Object.keys(sectionsToTabs).find(key => sectionsToTabs[key] === tabId); if (sectionTitleKey) setPlaceholderForMissingTab(tab, sectionTitleKey); else { tab.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Cleared.')}</p>`; tab.classList.add('placeholder-notice'); } }); resultsTabsContainer?.querySelectorAll('.tab-link.active').forEach(link => link.classList.remove('active')); tabContentArea?.querySelectorAll('.tab-content.active').forEach(content => content.classList.remove('active')); }
        function clearErrors() { errorMessageDiv.style.display = 'none'; errorMessageDiv.textContent = ''; errorMessageDiv.removeAttribute('data-error-key'); }
        function resetGeneratePageUI() {
            clearTabContents();
            conceptTextOutput.textContent = getTranslatedText(null, 'conceptPlaceholder', false, 'Concept text will appear here...');
            conceptTextOutput.classList.add('placeholder-notice');
            currentConceptText = '';
            currentDetailedResultsText = ''; 
            currentInputs = null;
            // Ensure imagePlaceholders is reset for the feature page state
            if (storedPageData.feature) {
                storedPageData.feature.imagePlaceholders = [];
            } else { // Should not happen due to initial declaration, but safe
                storedPageData.feature = { imagePlaceholders: [] };
            }
            updateGeneratePageUI('initial'); 
            console.log("Reset Generate Page UI to initial state.");
        }
        function updateGeneratePageUI(newState) {
            generateStep = newState; console.log("Updating Generate UI State:", newState);
            if (initialPrompt) initialPrompt.style.display = (newState === 'initial') ? 'flex' : 'none';
            if (conceptDisplayArea) conceptDisplayArea.style.display = (newState === 'concept_shown') ? 'flex' : 'none';
            if (tabbedResultsArea) tabbedResultsArea.style.display = (newState === 'details_shown') ? 'flex' : 'none';
            if (downloadActionArea) downloadActionArea.style.display = (newState === 'details_shown') ? 'flex' : 'none';

            if(generateConceptButton) generateConceptButton.disabled = (newState === 'loading');
            if(pickConceptButton) pickConceptButton.disabled = (newState !== 'concept_shown');
            if(regenerateConceptButtonAlt) regenerateConceptButtonAlt.disabled = (newState !== 'concept_shown');
            if(downloadTextInfoButton) downloadTextInfoButton.disabled = (newState !== 'details_shown');
            if(downloadAllImagesButton) downloadAllImagesButton.disabled = (newState !== 'details_shown');


            if (newState === 'details_shown') {
                const firstTabLink = resultsTabsContainer?.querySelector('.tab-link');
                if (firstTabLink && !resultsTabsContainer?.querySelector('.tab-link.active')) {
                    activateTab(firstTabLink);
                }
            }
        }
        function activateTab(tabLinkElement) { if (!tabLinkElement || !tabContents) return; const targetId = tabLinkElement.dataset.tabTarget; const targetContent = document.getElementById(targetId); tabLinks.forEach(link => link.classList.remove('active')); tabContents.forEach(content => content.classList.remove('active')); tabLinkElement.classList.add('active'); if (targetContent) { targetContent.classList.add('active'); } else { console.error(`Target content #${targetId} not found for tab.`); } }
        function displayError(message, errorKey = 'errorUnknown') { message = String(message || getTranslatedText(null, errorKey, false, 'Unknown error.')); errorMessageDiv.textContent = message; errorMessageDiv.dataset.errorKey = errorKey; errorMessageDiv.style.display = 'block'; hideLoading(); console.error("Displayed error:", message, `(Key: ${errorKey})`); if (outputArea?.contains(errorMessageDiv)) { errorMessageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' }); } }

        // --- Language Switching ---
        const internalTranslations = {
            // ... (Your existing translations) ...
            fontSampleTitleLabel: { en: "Title:", es: "Título:", vi: "Tiêu đề:", ja: "タイトル：", zhcn: "标题：" },
            fontSampleBodyLabel: { en: "Body:", es: "Cuerpo:", vi: "Nội dung:", ja: "本文：", zhcn: "正文：" },
            fontsPlaceholder: { en: "Font suggestions...", es: "Sugerencias de fuentes...", vi: "Gợi ý phông chữ...", ja: "フォントの提案...", zhcn: "字体建议..." },
            noFontsFound: { en: "No font suggestions.", es: "No sugerencias de fuentes.", vi: "Không có gợi ý phông chữ.", ja: "フォントの提案なし。", zhcn: "无字体建议。" },
            errorParsingFailed: { en: "Parse error. AI response format incorrect?", es: "Error de análisis. ¿Formato IA incorrecto?", vi: "Lỗi phân tích. Định dạng AI sai?", ja: "解析エラー。AI形式不正？", zhcn: "解析错误。AI 格式不正确？" },
            generatedViaBackend: { en: "Gen. via Server", es: "Gen. vía Servidor", vi: "Tạo bởi Máy chủ", ja: "サーバー生成", zhcn: "服务器生成" },
            placeholderReason: { en: "Placeholder", es: "Marcador", vi: "Giữ chỗ", ja: "プレースホルダ", zhcn: "占位符" },
            errorBackendProxy: { en: "Img Gen Error:", es: "Error Gen Imagen:", vi: "Lỗi Tạo ảnh:", ja: "画像生成エラー：", zhcn: "图像生成错误：" },
            errorBackendFetch: { en: "Network error fetching image.", es: "Error de red al obtener imagen.", vi: "Lỗi mạng lấy ảnh.", ja: "画像取得ネットワークエラー。", zhcn: "获取图像网络错误。" },
            errorCorsOrNetwork: { en: "Network/CORS error calling API.", es: "Error Red/CORS llamando API.", vi: "Lỗi Mạng/CORS gọi API.", ja: "APIネットワーク/CORSエラー。", zhcn: "API 网络/CORS 错误。" },
            validationLyricsMissing: { en: "Provide/generate lyrics.", es: "Proporciona/genera letra.", vi: "Cung cấp/tạo lời.", ja: "歌詞を提供/生成。", zhcn: "提供/生成歌词。" },
            validationKeywordsMissing: { en: "Provide keywords.", es: "Proporciona palabras clave.", vi: "Cung cấp từ khóa.", ja: "キーワード提供。", zhcn: "提供关键词。" },
            validationGenreMissing: { en: "Select genre.", es: "Selecciona género.", vi: "Chọn thể loại.", ja: "ジャンル選択。", zhcn: "选择流派。" },
            errorApiKeyInvalid: { en: "API Key invalid/missing.", es: "Clave API inválida/faltante.", vi: "Khóa API sai/thiếu.", ja: "APIキー不正/欠落。", zhcn: "API 密钥无效/丢失。" },
            errorApiHttp: { en: "API fail: ${errorDetail}", es: "Fallo API: ${errorDetail}", vi: "API thất bại: ${errorDetail}", ja: "API失敗：${errorDetail}", zhcn: "API 失败：${errorDetail}" },
            errorApiBlocked: { en: "Blocked by safety (Reason: ${reason}).", es: "Bloqueado por seguridad (Razón: ${reason}).", vi: "Bị chặn an toàn (Lý do: ${reason}).", ja: "安全ブロック（理由：${reason}）。", zhcn: "安全阻止（原因：${reason}）。" },
            errorApiGeneral: { en: "API Error: ${errorMessage}", es: "Error API: ${errorMessage}", vi: "Lỗi API: ${errorMessage}", ja: "APIエラー：${errorMessage}", zhcn: "API 错误：${errorMessage}" },
            errorApiNoCandidate: { en: "No API response candidate.", es: "Sin candidato API.", vi: "Không có phản hồi API.", ja: "API応答候補なし。", zhcn: "无 API 响应候选项。" },
            errorApiEmptyResponse: { en: "Empty AI response.", es: "Respuesta IA vacía.", vi: "Phản hồi AI trống.", ja: "AI応答空。", zhcn: "AI 响应为空。" },
            statusRequestingMic: { en: "Requesting mic...", es: "Solicitando micro...", vi: "Yêu cầu mic...", ja: "マイク要求中...", zhcn: "请求麦克风..." },
            statusRecording: { en: "Recording...", es: "Grabando...", vi: "Đang ghi...", ja: "録音中...", zhcn: "录音中..." },
            statusTranscribing: { en: "Transcribing...", es: "Transcribiendo...", vi: "Chuyển ghi...", ja: "文字起こし中...", zhcn: "转录中..." },
            statusStopping: { en: "Stopping...", es: "Deteniendo...", vi: "Đang dừng...", ja: "停止中...", zhcn: "停止中..." },
            stoppedStatus: { en: "Stopped.", es: "Detenido.", vi: "Đã dừng.", ja: "停止。", zhcn: "已停止。" },
            recordTranscriptComplete: { en: "Rec & transcript done.", es: "Grab. y transcr. listo.", vi: "Ghi & bản ghi xong.", ja: "録音・文字起こし完了。", zhcn: "录音转录完成。" },
            recordCompleteNoTranscript: { en: "Rec done (no transcript).", es: "Grab. lista (sin transcr.).", vi: "Ghi xong (ko bản ghi).", ja: "録音完了（文字起こし無）。", zhcn: "录音完成（无转录）。" },
            transcriptCompleteNoRecord: { en: "Transcript done (no rec).", es: "Transcr. lista (sin grab.).", vi: "Bản ghi xong (ko ghi).", ja: "文字起こし完了（録音無）。", zhcn: "转录完成（无录音）。" },
            statusFileSelected: { en: "File selected.", es: "Archivo seleccionado.", vi: "Đã chọn tệp.", ja: "ファイル選択済。", zhcn: "文件已选。" },
            statusAudioNotSupported: { en: "Audio recording unsupported.", es: "Grabación audio no soportada.", vi: "Ghi âm không hỗ trợ.", ja: "録音非対応。", zhcn: "不支持录音。" },
            statusSpeechRecNotSupported: { en: "Speech recognition unsupported.", es: "Reconoc. voz no soportado.", vi: "Nhận dạng giọng nói không hỗ trợ.", ja: "音声認識非対応。", zhcn: "不支持语音识别。" },
            micErrorGeneric: { en: "Mic access error.", es: "Error acceso micro.", vi: "Lỗi truy cập mic.", ja: "マイクアクセスエラー。", zhcn: "麦克风错误。" },
            micErrorPermission: { en: "Mic permission denied.", es: "Permiso micro denegado.", vi: "Quyền mic bị từ chối.", ja: "マイク許可拒否。", zhcn: "麦克风权限拒绝。" },
            micErrorNotFound: { en: "No mic found.", es: "No se encontró micro.", vi: "Không tìm thấy mic.", ja: "マイク未検出。", zhcn: "未找到麦克风。" },
            micErrorHardware: { en: "Mic hardware error.", es: "Error hardware micro.", vi: "Lỗi phần cứng mic.", ja: "マイクHWエラー。", zhcn: "麦克风硬件错误。" },
            statusRecordingError: { en: "Rec. error: ${errorName}", es: "Error grab.: ${errorName}", vi: "Lỗi ghi: ${errorName}", ja: "録音エラー：${errorName}", zhcn: "录音错误：${errorName}" },
            transcriptionErrorGeneric: { en: "Transcr. error: ${errorParam}", es: "Error transcr.: ${errorParam}", vi: "Lỗi chuyển ghi: ${errorParam}", ja: "文字起こしエラー：${errorParam}", zhcn: "转录错误：${errorParam}" },
            transcriptionErrorNoSpeech: { en: "No speech detected.", es: "No se detectó habla.", vi: "Không phát hiện giọng nói.", ja: "音声未検出。", zhcn: "未检测到语音。" },
            transcriptionErrorMicProblem: { en: "Transcr. failed (mic issue?).", es: "Fallo transcr. (¿micro?).", vi: "Chuyển ghi thất bại (lỗi mic?).", ja: "文字起こし失敗（マイク？）。", zhcn: "转录失败（麦克风问题？）。" },
            transcriptionErrorPermission: { en: "Transcr. needs mic permission.", es: "Transcr. necesita permiso micro.", vi: "Chuyển ghi cần quyền mic.", ja: "文字起こしマイク許可要。", zhcn: "转录需麦克风权限。" },
            transcriptionErrorNetwork: { en: "Transcr. network error.", es: "Error red transcr.", vi: "Lỗi mạng chuyển ghi.", ja: "文字起こしNWエラー。", zhcn: "转录网络错误。" },
            budgetLowTitle: { en: "Low Budget", es: "Bajo Presupuesto", vi: "Ngân sách thấp", ja: "低予算", zhcn:"低预算"},
            budgetMidTitle: { en: "Mid Budget", es: "Presupuesto Medio", vi: "Ngân sách trung bình", ja: "中予算", zhcn:"中预算"},
            budgetHighTitle: { en: "High Budget", es: "Alto Presupuesto", vi: "Ngân sách cao", ja: "高予算", zhcn:"高预算"},
            budgetDetailsMissing: { en: "Details missing.", es: "Detalles faltantes.", vi: "Thiếu chi tiết.", ja: "詳細なし。", zhcn:"缺细节。"},
            noVisualsFound: { en: "No visuals.", es: "No visuales.", vi: "Không hình ảnh.", ja: "ビジュアルなし。", zhcn:"无视觉。"},
            noMoodboardItemsFound: { en: "No moodboard items.", es: "No elementos moodboard.", vi: "Không mục moodboard.", ja: "ムードボード項目なし。", zhcn:"无情绪板项目。"},
            noBudgetContentFound: { en: "No budget details.", es: "No detalles presupuesto.", vi: "Không chi tiết ngân sách.", ja: "予算詳細なし。", zhcn:"无预算细节。"},
            noRequirementsFound: { en: "No requirements.", es: "No requisitos.", vi: "Không yêu cầu.", ja: "要件なし。", zhcn:"无要求。"},
            noColorsFound: { en: "No colors.", es: "No colores.", vi: "Không màu sắc.", ja: "色なし。", zhcn:"无颜色。"},
            placeholderGeneric: { en: "Content unavailable.", es: "Contenido no disponible.", vi: "Nội dung không có.", ja: "内容利用不可。", zhcn:"内容不可用。"},
            errorDisplayingSection: { en: "Error displaying section.", es: "Error mostrando sección.", vi: "Lỗi hiển thị phần.", ja: "セクション表示エラー。", zhcn:"显示部分错误。"},
            errorExploreNoConcept: { en: "Generate concept first.", es: "Genera concepto primero.", vi: "Tạo ý tưởng trước.", ja: "まずコンセプト生成。", zhcn:"先生成概念。"},
            generatingConcept: { en: "Generating Concept...", es: "Generando Concepto...", vi: "Đang tạo ý tưởng...", ja: "コンセプト生成中...", zhcn:"生成概念中..."},
            fetchingDetails: { en: "Fetching Details...", es: "Obteniendo Detalles...", vi: "Lấy chi tiết...", ja: "詳細取得中...", zhcn:"获取细节中..."},
            generatingCreativeSparks: { en: "Generating sparks...", es: "Generando chispas...", vi: "Tạo tia sáng...", ja: "火花生成中...", zhcn:"生成火花中..."},
            conceptPlaceholder: { en: "Concept appears here...", es: "Concepto aquí...", vi: "Ý tưởng ở đây...", ja: "コンセプト表示...", zhcn: "概念在此显示..." },
            requirementsPlaceholder: { en: "Requirements list...", es: "Lista requisitos...", vi: "Danh sách yêu cầu...", ja: "要件リスト...", zhcn: "要求列表..." },
            budgetPlaceholder: { en: "Budget details...", es: "Detalles presupuesto...", vi: "Chi tiết ngân sách...", ja: "予算詳細...", zhcn: "预算细节..." },
            budgetNotePlaceholder: { en: "Note: Budgets are estimates...", es: "Nota: Presupuestos estimados...", vi: "Lưu ý: Ngân sách ước tính...", ja: "注：予算は見積もり...", zhcn: "注：预算为估算..." },
            visualsPlaceholder: { en: "Visual descriptions...", es: "Descripciones visuales...", vi: "Mô tả hình ảnh...", ja: "ビジュアル説明...", zhcn: "视觉描述..." },
            visualsNotePlaceholder: { en: "Illustrative images.", es: "Imágenes ilustrativas.", vi: "Ảnh minh họa.", ja: "説明画像。", zhcn: "说明图片。" },
            moodboardDescPlaceholder: { en: "Moodboard description...", es: "Descripción moodboard...", vi: "Mô tả moodboard...", ja: "ムードボード説明...", zhcn: "情绪板描述..." },
            moodboardImgsPlaceholder: { en: "Moodboard images...", es: "Imágenes moodboard...", vi: "Ảnh moodboard...", ja: "ムードボード画像...", zhcn: "情绪板图片..." },
            moodboardNotePlaceholder: { en: "Visuals for inspiration.", es: "Visuales para inspiración.", vi: "Hình ảnh cảm hứng.", ja: "インスピレーション用ビジュアル。", zhcn: "灵感视觉。" },
            palettePlaceholder: { en: "Color palette...", es: "Paleta colores...", vi: "Bảng màu...", ja: "カラーパレット...", zhcn: "调色板..." },
            preparingDownload: { en: "Preparing Download...", es: "Preparando Descarga...", vi: "Chuẩn bị Tải xuống...", ja: "ダウンロード準備中...", zhcn: "准备下载..." },
            errorDownloadPrep: { en: "Failed to prepare download.", es: "Fallo al preparar descarga.", vi: "Lỗi chuẩn bị tải xuống.", ja: "ダウンロード準備失敗。", zhcn: "准备下载失败。" },
            downloadingImages: { en: "Downloading Images for ZIP...", es: "Descargando Imágenes para ZIP...", vi: "Đang tải Ảnh cho ZIP...", ja: "ZIP用画像ダウンロード中...", zhcn: "正在下载ZIP图片..." },
            errorImageFetchZip: { en: "Error fetching image for ZIP.", es: "Error al obtener imagen para ZIP.", vi: "Lỗi lấy ảnh cho ZIP.", ja: "ZIP用画像取得エラー。", zhcn: "获取ZIP图片错误。" },
            errorZipCreation: { en: "Error creating ZIP file.", es: "Error al crear archivo ZIP.", vi: "Lỗi tạo tệp ZIP.", ja: "ZIPファイル作成エラー。", zhcn: "创建ZIP文件错误。" },
            noImagesToDownload: { en: "No images to download.", es: "No hay imágenes para descargar.", vi: "Không có ảnh để tải.", ja: "ダウンロードする画像がありません。", zhcn: "没有可下载的图像。" },
            // New music player translations
            backgroundMusicTitle: { en: "Background Music", es: "Música de Fondo", vi: "Nhạc Nền", ja: "背景音楽", zhcn: "背景音乐" },
            playMusic: { en: "Play Music", es: "Reproducir Música", vi: "Phát Nhạc", ja: "音楽を再生", zhcn: "播放音乐" },
            pauseMusic: { en: "Pause Music", es: "Pausar Música", vi: "Tạm Dừng Nhạc", ja: "音楽を一時停止", zhcn: "暂停音乐" },
            musicSettings: { en: "Music Settings", es: "Ajustes de Música", vi: "Cài Đặt Nhạc", ja: "音楽設定", zhcn: "音乐设置" },
            closeMusicSettings: { en: "Close Music Settings", es: "Cerrar Ajustes de Música", vi: "Đóng Cài Đặt Nhạc", ja: "音楽設定を閉じる", zhcn: "关闭音乐设置" },
        };
        function formatDatasetKey(langCode, suffix = '') { let keyBase = (langCode === 'zh-CN') ? 'zhcn' : langCode.toLowerCase().split('-')[0]; const capitalizedBase = keyBase.charAt(0).toUpperCase() + keyBase.slice(1); let key = 'lang' + capitalizedBase; if (suffix) { let camelSuffix = suffix.replace(/[-_](.)/g, (_, c) => c.toUpperCase()); camelSuffix = camelSuffix.charAt(0).toUpperCase() + camelSuffix.slice(1); key += camelSuffix; } return key.charAt(0).toLowerCase() + key.slice(1); }
        function getTranslatedText(element, keyOrSuffix = '', isPlaceholderAttr = false, fallbackText = '') { if (internalTranslations[keyOrSuffix] && internalTranslations[keyOrSuffix][currentLang]) { return internalTranslations[keyOrSuffix][currentLang]; } else if (internalTranslations[keyOrSuffix] && internalTranslations[keyOrSuffix]['en']) { return internalTranslations[keyOrSuffix]['en']; } let translation = ''; if (element) { const primaryDataKey = formatDatasetKey(currentLang, keyOrSuffix); const englishDataKey = formatDatasetKey('en', keyOrSuffix); const baseLangKey = formatDatasetKey(currentLang); const baseEnKey = formatDatasetKey('en'); translation = element.dataset[primaryDataKey] ?? element.dataset[englishDataKey] ?? element.dataset[baseLangKey] ?? element.dataset[baseEnKey]; } if ((translation === undefined || translation === null || translation === '') && currentLang === 'en') { if (isPlaceholderAttr && element?.hasAttribute('placeholder')) { translation = element.getAttribute('placeholder'); } else if (!isPlaceholderAttr && element?.textContent && element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE) { translation = element.textContent; } } return String(translation ?? fallbackText).trim(); }
        
        function updateLanguage(langCode) {
            currentLang = langCode; console.log(`Switching UI language to: ${langCode}`); document.documentElement.lang = langCode;
            const currentTranslatableElements = document.querySelectorAll('[data-lang-en], [data-lang-en-placeholder], #music-modal-content h3'); // Added music modal title
            currentTranslatableElements.forEach(el => { const isPlaceholderTarget = (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') && (el.hasAttribute('data-lang-en-placeholder') || el.hasAttribute('placeholder')); const suffixCheck = el.dataset.langEnRecord ? 'record' : (el.dataset.langEnStop ? 'stop' : ''); const suffix = isPlaceholderTarget ? 'placeholder' : suffixCheck; const fallbackValue = isPlaceholderTarget ? (el.dataset[formatDatasetKey('en','placeholder')] || el.getAttribute('data-lang-en-placeholder') || el.getAttribute('placeholder')) : (el.dataset[formatDatasetKey('en',suffix)] || el.getAttribute('data-lang-en')); let translation = getTranslatedText(el, suffix, isPlaceholderTarget, fallbackValue); if (isPlaceholderTarget) { el.placeholder = translation; } else if (el.tagName === 'TITLE') { document.title = translation; } else { const safeTags = ['BUTTON', 'P', 'SMALL', 'LABEL', 'H1', 'H2', 'H3', 'H4', 'LI', 'A', 'OPTION', 'SPAN', 'DIV']; const isSafeToUpdate = safeTags.includes(el.tagName) && !el.closest('.tab-content') && el.id !== 'record-status-text' && el.id !== 'error-message'; if (isSafeToUpdate || el.classList.contains('tab-link') || el.closest('#initial-prompt') ) { if (el.children.length === 1 && ['STRONG', 'EM', 'B', 'I'].includes(el.children[0].tagName)) { const tagName = el.children[0].tagName.toLowerCase(); el.innerHTML = `<${tagName}>${translation}</${tagName}>`; } else if (!el.children.length || Array.from(el.childNodes).every(n => n.nodeType === Node.TEXT_NODE) || (el.id === 'initial-prompt' && el.querySelector('p'))) { const targetEl = (el.id === 'initial-prompt' && el.querySelector('p')) ? el.querySelector('p') : el; targetEl.textContent = translation; } } } });
            if (recordAudioButton) updateRecordingUI(isRecording);
            if (recordStatus?.dataset?.statusKey) { let statusKey = recordStatus.dataset.statusKey; let fallback = recordStatus.dataset.statusFallback || ''; let statusClass = Array.from(recordStatus.classList).find(c => ['complete', 'error', 'recording', 'transcribing'].includes(c)) || ''; let isPersistent = statusClass === 'complete' || statusClass === 'error'; updateRecordStatus(getTranslatedText(null, statusKey, false, fallback), statusClass, isPersistent, statusKey); } else if (!isRecording) clearRecordStatus();
            if (loadingOverlay.classList.contains('show')) { const loadingP = loadingOverlay.querySelector('p'); if (loadingP?.dataset.lastKey) loadingP.textContent = getTranslatedText(loadingP, loadingP.dataset.lastKey, false, 'Loading...'); }
            if (errorMessageDiv.style.display === 'block' && errorMessageDiv.dataset.errorKey) { errorMessageDiv.textContent = getTranslatedText(null, errorMessageDiv.dataset.errorKey, false, errorMessageDiv.textContent); }
             if (isSpeechRecognitionSupported && recognition) { const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' }; const newRecLang = bcp47Map[langCode] || (langCode.includes('-') ? langCode : `${langCode}-${langCode.toUpperCase()}`); if (recognition.lang !== newRecLang) { if (isRecording) handleRecordButtonClick(); recognition.lang = newRecLang; console.log("Updated speech lang:", newRecLang); } }
            if (generateStep === 'details_shown' && tabbedResultsArea?.style.display === 'flex') {
                tabContents?.forEach(contentDiv => {
                    contentDiv.querySelectorAll('[data-placeholder-key]').forEach(ph => { const isTruePlaceholder = ph.classList.contains('placeholder-notice') || ph.closest('.placeholder-notice'); const isNote = (ph.tagName === 'SMALL' || ph.tagName === 'SPAN') && ph.dataset.placeholderKey.toLowerCase().includes('note'); if (isTruePlaceholder || isNote) { ph.textContent = getTranslatedText(null, ph.dataset.placeholderKey, false, ph.textContent); } });
                     contentDiv.querySelectorAll('.budget-column.placeholder-notice h3').forEach(h3 => { const m = h3.textContent.match(/^(Low|Mid|High)/i); if(m) h3.textContent = getTranslatedText(null, `budget${m[1]}Title`, false, `${m[1]} Budget`); });
                     contentDiv.querySelectorAll('.budget-column.placeholder-notice p[data-placeholder-key="budgetDetailsMissing"]').forEach(p => p.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`);
                     contentDiv.querySelectorAll('.image-placeholder figcaption .fallback-notice').forEach(span => { const m = span.textContent.match(/\(([^:]+):\s*(.*)\)/); if(m) span.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${m[2]})`; });
                     contentDiv.querySelectorAll('.font-sample strong').forEach(strong => { if (strong.nextSibling?.textContent.includes('"')) { const key = strong.textContent.toLowerCase().startsWith('title') ? 'fontSampleTitleLabel' : 'fontSampleBodyLabel'; strong.textContent = getTranslatedText(null, key, false, strong.textContent); } });
                });
            }
             if (generateStep === 'concept_shown' && conceptTextOutput?.classList.contains('placeholder-notice')) { conceptTextOutput.textContent = getTranslatedText(null, 'conceptPlaceholder', false, 'Concept text will appear here...'); }
            // Update music player modal ARIA labels
            if (musicSettingsButton) {
                musicSettingsButton.setAttribute('aria-label', getTranslatedText(null, 'musicSettings', false, 'Music Settings'));
            }
            if (closeMusicModal) {
                closeMusicModal.setAttribute('aria-label', getTranslatedText(null, 'closeMusicSettings', false, 'Close Music Settings'));
            }
            updatePlayPauseMusicButtonUI(musicIsPlaying); // Re-translate play/pause button
        }
        function saveLanguagePreference(langCode) { try { localStorage.setItem('mvGeneratorLang', langCode); } catch (e) { console.warn("Failed to save lang pref:", e)} }
        function loadLanguagePreference() { try { const saved = localStorage.getItem('mvGeneratorLang'); if (saved && Array.from(languageSelect.options).some(o => o.value === saved)) { languageSelect.value = saved; return saved; } } catch (e) {} return languageSelect ? languageSelect.value : 'en'; }

        // --- Guide Modal Logic (Unchanged) ---
         function showGuideModal() { if (guideModal) { updateLanguage(currentLang); guideModal.classList.add('show'); } }
         function hideGuideModal() { if (guideModal) guideModal.classList.remove('show'); }

        // --- Download Functionality ---
        function gatherAllTextData() {
            let fullText = `MV CONCEPT REPORT\nGenerated by MVPot (${new Date().toLocaleString()})\n\n`;
            const getCleanText = (el) => el ? el.innerText.trim() : 'N/A';
            const getHtmlAsText = (el) => {
                if (!el) return 'N/A';
                let temp = document.createElement('div');
                temp.innerHTML = el.innerHTML;
                // Convert <br> to newlines, <li> to "- item", etc. for better text readability
                temp.querySelectorAll('br').forEach(br => br.replaceWith('\n'));
                temp.querySelectorAll('li:not(.placeholder-notice)').forEach(li => li.prepend('- '));
                temp.querySelectorAll('strong, b').forEach(strong => strong.textContent = `**${strong.textContent}**`); // Markdown-ish bold
                temp.querySelectorAll('em, i').forEach(em => em.textContent = `_${em.textContent}_`);     // Markdown-ish italic
                return temp.innerText.trim() || 'N/A';
            };
            
            fullText += "## CONCEPT / KEY VISUAL\n";
            fullText += (document.getElementById('tab-content-concept')?.querySelector('p')?.innerText.trim() || currentConceptText || 'N/A') + "\n\n";

            fullText += "## REQUIREMENTS FOR MV\n";
            const reqItems = document.getElementById('tab-content-requirements')?.querySelectorAll('ul li:not(.placeholder-notice)');
            if (reqItems && reqItems.length > 0) {
                reqItems.forEach(li => fullText += `- ${li.innerText.trim()}\n`);
            } else { fullText += "N/A\n"; }
            fullText += "\n";

            fullText += "## ESTIMATED BUDGET\n";
            const budgetCols = document.getElementById('tab-content-budget')?.querySelectorAll('.budget-column:not(.placeholder-notice)');
            if (budgetCols && budgetCols.length > 0) {
                budgetCols.forEach(col => {
                    fullText += `**${col.querySelector('h3')?.innerText.trim()}**\n`;
                    fullText += getHtmlAsText(col.querySelector('p:not(.placeholder-notice)')) + "\n\n";
                });
            } else {
                const rawBudget = document.getElementById('tab-content-budget')?.querySelector('.raw-budget-output pre');
                fullText += (rawBudget ? rawBudget.innerText.trim() : 'N/A') + "\n\n";
            }

            fullText += "## VISUAL DEMO (KEY IMAGES DESCRIPTIONS)\n";
            const keyImgFigures = document.getElementById('tab-content-visuals')?.querySelectorAll('.image-placeholder:not(.placeholder-notice)');
            if (keyImgFigures && keyImgFigures.length > 0) {
                keyImgFigures.forEach((fig, i) => fullText += `${i+1}. ${getCleanText(fig.querySelector('figcaption'))}\n`);
            } else { fullText += "N/A\n"; }
            fullText += "\n";

            fullText += "## MOODBOARD INFLUENCES\n";
            const moodboardDesc = document.getElementById('moodboard-description:not(.placeholder-notice)');
            fullText += (moodboardDesc ? moodboardDesc.innerText.trim() : 'N/A') + "\n";
            const moodboardItems = document.getElementById('moodboard-images')?.querySelectorAll('.image-placeholder:not(.placeholder-notice)');
            if (moodboardItems && moodboardItems.length > 0) {
                moodboardItems.forEach(fig => fullText += `* ${getCleanText(fig.querySelector('figcaption'))}\n`);
            } else if (!moodboardDesc || moodboardDesc.innerText.trim() === 'N/A') { fullText += "N/A\n"; }
            fullText += "\n";

            fullText += "## TYPOGRAPHY/FONT SUGGESTION\n";
            const fontSuggestion = document.getElementById('tab-content-fonts')?.querySelector('.font-suggestion');
            if (fontSuggestion) {
                fullText += `Font Combination: ${getCleanText(fontSuggestion.querySelector('h3'))}\n`;
                fullText += `Reason: ${getCleanText(fontSuggestion.querySelector('.font-reason'))}\n`;
                fontSuggestion.querySelectorAll('.font-sample').forEach(sample => fullText += `${getCleanText(sample)}\n`);
            } else { fullText += "N/A\n"; }
            fullText += "\n";

            fullText += "## COLOR PALETTE\n";
            const swatches = document.getElementById('tab-content-palette')?.querySelectorAll('.color-swatch:not(.placeholder-notice)');
            if (swatches && swatches.length > 0) {
                swatches.forEach(sw => {
                    fullText += `${sw.classList.contains('dominant-swatch') ? 'Dominant ' : ''}${getCleanText(sw.querySelector('.color-name'))} (${getCleanText(sw.querySelector('.hex-code'))}) - Application: ${getCleanText(sw.querySelector('.color-application'))}\n`;
                });
            } else { fullText += "N/A\n"; }
            
            console.log("Generated Text Data:\n", fullText);
            return fullText;
        }

        async function handleDownloadTextInfo() {
            showLoading("preparingDownload", "Preparing Text Download...");
            await new Promise(resolve => setTimeout(resolve, 100)); // UI update
            try {
                const textData = gatherAllTextData();
                const blob = new Blob([textData], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'mv_concept_info.txt';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            } catch (err) {
                console.error("Error preparing text download:", err);
                displayError(getTranslatedText(null, "errorDownloadPrep", false, "Failed to prepare text download."), "errorDownloadPrep");
            } finally {
                hideLoading();
            }
        }

        async function handleDownloadAllImages() {
            showLoading("downloadingImages", "Downloading Images for ZIP...");
            const zip = new JSZip();
            const imagesToFetch = [];
            let imgCounter = 1;

            document.querySelectorAll('#tab-content-visuals .image-placeholder img[src], #tab-content-moodboard .image-placeholder img[src]').forEach(imgEl => {
                if (imgEl.src && !imgEl.src.startsWith('data:')) { // Skip empty or data URIs if any
                    const isMoodboard = imgEl.closest('#tab-content-moodboard');
                    const figcaption = imgEl.closest('.image-placeholder')?.querySelector('figcaption');
                    let nameHint = figcaption ? figcaption.innerText.trim().split('\n')[0].substring(0, 30) : (isMoodboard ? 'mood' : 'key');
                    nameHint = nameHint.replace(/[^\w\s-]/g, '').replace(/\s+/g, '_').toLowerCase();
                    if (!nameHint) nameHint = (isMoodboard ? 'moodboard_item_' : 'key_image_');

                    imagesToFetch.push({ 
                        url: imgEl.src, 
                        filename: `${nameHint}_${imgCounter++}.png` // Assume png, actual type will be from fetch
                    });
                }
            });

            if (imagesToFetch.length === 0) {
                displayError(getTranslatedText(null, "noImagesToDownload", false, "No images found to download."), "noImagesToDownload");
                hideLoading();
                return;
            }
            
            const fetchImageAsBlob = async (imageData) => {
                try {
                    // For picsum URLs, we need to fetch them as if they were external if they are to be included in ZIP
                    // If the URL is already a blob URL from a previous fetch, try to re-fetch it if it's not directly usable.
                    // However, for simplicity, we assume external URLs here.
                    const response = await fetch(imageData.url);
                    if (!response.ok) throw new Error(`HTTP error ${response.status} for ${imageData.url}`);
                    const blob = await response.blob();
                    let extension = '.png';
                    if (blob.type.startsWith('image/')) {
                        extension = '.' + blob.type.split('/')[1];
                         if (extension === '.jpeg') extension = '.jpg';
                    }
                    imageData.filename = imageData.filename.replace(/\.png$/, extension);
                    zip.file(imageData.filename, blob);
                } catch (error) {
                    console.error(`Failed to fetch image ${imageData.url}:`, error);
                    zip.file(`${imageData.filename}_FETCH_ERROR.txt`, `Could not download image from: ${imageData.url}\nError: ${error.message}`);
                }
            };

            try {
                await Promise.all(imagesToFetch.map(fetchImageAsBlob));
                const content = await zip.generateAsync({ type: "blob" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = "mv_concept_images.zip";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            } catch (error) {
                console.error("Error creating ZIP file:", error);
                displayError(getTranslatedText(null, "errorZipCreation", false, "Error creating ZIP file."), "errorZipCreation");
            } finally {
                hideLoading();
            }
        }

        // --- Background Music Player Logic ---
        function updatePlayPauseMusicButtonUI(isPlaying) {
            if (playPauseMusicButton) {
                playPauseMusicButton.innerHTML = isPlaying ? svgIconPause : svgIconPlay;
                const labelKey = isPlaying ? 'pauseMusic' : 'playMusic';
                const fallbackLabel = isPlaying ? 'Pause Music' : 'Play Music';
                playPauseMusicButton.setAttribute('aria-label', getTranslatedText(null, labelKey, false, fallbackLabel));
            }
        }

        async function tryPlayBackgroundMusic() {
            if (backgroundMusic && !musicIsPlaying && musicInitialized) {
                try {
                    await backgroundMusic.play();
                    // musicIsPlaying will be set by 'play' event listener
                } catch (err) {
                    console.warn('Background music play was prevented:', err);
                    updatePlayPauseMusicButtonUI(false); // Show play icon as it failed
                }
            }
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            navLinks.forEach(link => { link.addEventListener('click', (e) => { const page = link.getAttribute('data-page'); if (page) { e.preventDefault(); playSound(hoverSound); showPage(page); } }); link.addEventListener('mouseenter', () => playSound(hoverSound)); });
            if (exploreButton) { exploreButton.addEventListener('click', () => { playSound(clickSound); showPage('feature'); }); exploreButton.addEventListener('mouseenter', () => playSound(hoverSound)); }
            backButtons.forEach(button => { button.addEventListener('click', (e) => { e.preventDefault(); playSound(hoverSound); showPage('home'); }); button.addEventListener('mouseenter', () => playSound(hoverSound)); });
            if (generateConceptButton) { generateConceptButton.addEventListener('click', () => { playSound(clickSound); handleGenerateConcept(); }); generateConceptButton.addEventListener('mouseenter', () => playSound(hoverSound)); }
            if (generateLyricsButton) { generateLyricsButton.addEventListener('click', () => { playSound(hoverSound); generateRandomLyrics(); }); generateLyricsButton.addEventListener('mouseenter', () => playSound(hoverSound)); }
            if (pickConceptButton) { pickConceptButton.addEventListener('click', () => { playSound(clickSound); handlePickConcept(); }); pickConceptButton.addEventListener('mouseenter', () => playSound(hoverSound)); }
            if (regenerateConceptButtonAlt) { regenerateConceptButtonAlt.addEventListener('click', () => { playSound(hoverSound); handleRegenerateConceptAlt(); }); regenerateConceptButtonAlt.addEventListener('mouseenter', () => playSound(hoverSound)); }
            if (recordAudioButton) recordAudioButton.addEventListener('mouseenter', () => playSound(hoverSound));
            if (languageSelect) { languageSelect.addEventListener('change', (e) => { playSound(hoverSound); updateLanguage(e.target.value); saveLanguagePreference(e.target.value); }); }
            if (howToUseButton) { howToUseButton.addEventListener('click', () => { playSound(hoverSound); showGuideModal(); }); howToUseButton.addEventListener('mouseenter', () => playSound(hoverSound)); }
            if (closeGuideModal) { closeGuideModal.addEventListener('click', () => { playSound(hoverSound); hideGuideModal(); }); closeGuideModal.addEventListener('mouseenter', () => playSound(hoverSound)); }
            if (guideModal) guideModal.addEventListener('click', (e) => { if (e.target === guideModal) { hideGuideModal(); } });
            if (tabLinks) { tabLinks.forEach(link => { link.addEventListener('click', (e) => { e.preventDefault(); playSound(hoverSound); activateTab(link); }); link.addEventListener('mouseenter', () => playSound(hoverSound)); }); }
            
            if (downloadTextInfoButton) {
                downloadTextInfoButton.addEventListener('click', () => { playSound(clickSound); handleDownloadTextInfo(); });
                downloadTextInfoButton.addEventListener('mouseenter', () => playSound(hoverSound));
            }
            if (downloadAllImagesButton) {
                downloadAllImagesButton.addEventListener('click', () => { playSound(clickSound); handleDownloadAllImages(); });
                downloadAllImagesButton.addEventListener('mouseenter', () => playSound(hoverSound));
            }

            // Music Player Event Listeners
            if (musicSettingsButton) {
                musicSettingsButton.innerHTML = svgIconGear; // Set the gear icon
                musicSettingsButton.addEventListener('click', () => {
                    playSound(hoverSound); 
                    musicModal.classList.add('show');
                    if (!musicInitialized) {
                        musicInitialized = true;
                        const savedVolume = localStorage.getItem('musicVolume');
                        if (savedVolume !== null) {
                            backgroundMusic.volume = parseFloat(savedVolume);
                            volumeSlider.value = parseFloat(savedVolume) * 100;
                        } else {
                            backgroundMusic.volume = volumeSlider.value / 100; // Default from slider
                        }
                        tryPlayBackgroundMusic(); 
                    }
                });
                musicSettingsButton.addEventListener('mouseenter', () => playSound(hoverSound));
            }

            if (closeMusicModal) {
                closeMusicModal.addEventListener('click', () => {
                    playSound(hoverSound);
                    musicModal.classList.remove('show');
                });
            }

            if (musicModal) { // Click outside to close
                musicModal.addEventListener('click', (e) => {
                    if (e.target === musicModal) {
                        musicModal.classList.remove('show');
                    }
                });
            }

            if (playPauseMusicButton && backgroundMusic) {
                playPauseMusicButton.addEventListener('click', () => {
                    playSound(clickSound); // Using main click sound for this
                    if (!musicInitialized) {
                        musicInitialized = true; // Should be initialized if modal is open
                         const savedVolume = localStorage.getItem('musicVolume');
                        if (savedVolume !== null) {
                            backgroundMusic.volume = parseFloat(savedVolume);
                            volumeSlider.value = parseFloat(savedVolume) * 100;
                        } else {
                            backgroundMusic.volume = volumeSlider.value / 100;
                        }
                    }
                    if (backgroundMusic.paused) {
                        tryPlayBackgroundMusic();
                    } else {
                        backgroundMusic.pause();
                    }
                });
                playPauseMusicButton.addEventListener('mouseenter', () => playSound(hoverSound));
            }

            if (volumeSlider && backgroundMusic) {
                volumeSlider.addEventListener('input', () => {
                    const newVolume = volumeSlider.value / 100;
                    backgroundMusic.volume = newVolume;
                    try { localStorage.setItem('musicVolume', newVolume.toString()); }
                    catch(e) { console.warn("Could not save volume to localStorage", e); }
                });
            }

            if (backgroundMusic) {
                backgroundMusic.addEventListener('play', () => {
                    musicIsPlaying = true;
                    updatePlayPauseMusicButtonUI(true);
                });
                backgroundMusic.addEventListener('pause', () => {
                    musicIsPlaying = false;
                    updatePlayPauseMusicButtonUI(false);
                });
                // Initialize button based on actual state after potential autoplay or first click
                updatePlayPauseMusicButtonUI(!backgroundMusic.paused && musicIsPlaying);
            }


            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Three.js Background Setup (Unchanged) ---
        let scene, camera, renderer, model, clock; let modelVelocity = new THREE.Vector3(); let modelSize = new THREE.Vector3(); let boundaries = { x: 0, y: 0 }; const modelSpeed = 1.5;
        function init3DBackground() { if (!bgCanvas) { console.error("BG canvas not found!"); return; } console.log("Init 3D background..."); scene = new THREE.Scene(); clock = new THREE.Clock(); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 10; renderer = new THREE.WebGLRenderer({ canvas: bgCanvas, alpha: true, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); scene.add(new THREE.AmbientLight(0xffffff, 1.5)); const dirLight = new THREE.DirectionalLight(0xffffff, 2); dirLight.position.set(5, 10, 7.5); scene.add(dirLight); const loader = new GLTFLoader(); const modelPath = '/xe-ban-hu-tiu(vertice-color-baked).glb'; loader.load(modelPath, (gltf) => { console.log("Model loaded."); model = gltf.scene; const box = new THREE.Box3().setFromObject(model); box.getSize(modelSize); const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z); const scaleFactor = 2.5 / maxDim; model.scale.set(scaleFactor, scaleFactor, scaleFactor); model.position.set(0, 0, 0); box.setFromObject(model); box.getSize(modelSize); console.log("Scaled Size:", modelSize); calculateBoundaries(); modelVelocity.set(Math.random() - 0.5, Math.random() - 0.5, 0).normalize().multiplyScalar(modelSpeed); scene.add(model); animate3D(); }, undefined, (error) => { console.error('Error loading model:', error); bgCanvas.style.display = 'none'; }); }
        function calculateBoundaries() { if (!camera) return; const distance = camera.position.z; const vFOV = THREE.MathUtils.degToRad(camera.fov); const height = 2 * Math.tan(vFOV / 2) * distance; const width = height * camera.aspect; boundaries.x = width / 2; boundaries.y = height / 2; }
        function onWindowResize() { if (!camera || !renderer) return; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); calculateBoundaries(); }
        function animate3D() { if (!renderer || !scene || !camera) return; requestAnimationFrame(animate3D); const delta = clock.getDelta(); if (model && modelSize.x > 0) { model.position.x += modelVelocity.x * delta; model.position.y += modelVelocity.y * delta; model.rotation.y += 0.1 * delta; model.rotation.x += 0.05 * delta; const halfWidth = modelSize.x / 2; const halfHeight = modelSize.y / 2; if (model.position.x + halfWidth > boundaries.x || model.position.x - halfWidth < -boundaries.x) { modelVelocity.x *= -1; model.position.x = THREE.MathUtils.clamp(model.position.x, -boundaries.x + halfWidth, boundaries.x - halfWidth); } if (model.position.y + halfHeight > boundaries.y || model.position.y - halfHeight < -boundaries.y) { modelVelocity.y *= -1; model.position.y = THREE.MathUtils.clamp(model.position.y, -boundaries.y + halfHeight, boundaries.y - halfHeight); } } renderer.render(scene, camera); }

        // --- Initialize ---
        init3DBackground();
        setupEventListeners(); 
        
        // Load saved volume for music player and set initial slider/button state
        if (backgroundMusic && volumeSlider && playPauseMusicButton) {
            const savedVolume = localStorage.getItem('musicVolume');
            if (savedVolume !== null) {
                backgroundMusic.volume = parseFloat(savedVolume);
                volumeSlider.value = parseFloat(savedVolume) * 100;
            } else {
                // Default volume if nothing is saved (e.g., 0.5 for 50%)
                backgroundMusic.volume = 0.5; 
                volumeSlider.value = 50;
            }
            updatePlayPauseMusicButtonUI(false); // Initially set to play icon
        }

        const initialLangLoaded = loadLanguagePreference();
        updateLanguage(initialLangLoaded); 
        showPage('home'); 

        console.log("MV Generator Initialized. Lang:", initialLangLoaded, "Speech Support:", isSpeechRecognitionSupported);
         if (recordAudioButton && recordAudioButton.disabled && (!navigator.mediaDevices?.getUserMedia || !isSpeechRecognitionSupported)) { const errorKey = !navigator.mediaDevices?.getUserMedia ? 'statusAudioNotSupported' : 'statusSpeechRecNotSupported'; const errorMsg = getTranslatedText(null, errorKey, false, 'Audio/Speech input not supported.'); updateRecordStatus(errorMsg, 'error', true, errorKey); }

    }); // End DOMContentLoaded
    </script>
    <!-- ========= END JAVASCRIPT ========= -->

</body>
</html>
